<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习ahooks之useLongPress</title>
      <link href="/2023/03/17/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseLongPress/"/>
      <url>/2023/03/17/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseLongPress/</url>
      
        <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>可能是小程序api用多了，前几天写网页有个需求是监听长按，竟然有点生疏，幸好ahooks实现了useLongPress这个hook。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLongPress/index.ts">原版代码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touchSupported =</span><br><span class="line">  isBrowser &amp;&amp;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  (<span class="string">&#x27;ontouchstart&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> || (<span class="variable language_">window</span>.<span class="property">DocumentTouch</span> &amp;&amp; <span class="variable language_">document</span> <span class="keyword">instanceof</span> <span class="title class_">DocumentTouch</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useLongPress</span>(<span class="params"></span></span><br><span class="line"><span class="params">  onLongPress: (event: EventType) =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  target: BasicTarget,</span></span><br><span class="line"><span class="params">  &#123; delay = <span class="number">300</span>, moveThreshold, onClick, onLongPressEnd &#125;: Options = &#123;&#125;,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> onLongPressRef = <span class="title function_">useLatest</span>(onLongPress);</span><br><span class="line">  <span class="keyword">const</span> onClickRef = <span class="title function_">useLatest</span>(onClick);</span><br><span class="line">  <span class="keyword">const</span> onLongPressEndRef = <span class="title function_">useLatest</span>(onLongPressEnd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timerRef = useRef&lt;<span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">const</span> isTriggeredRef = <span class="title function_">useRef</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> pervPositionRef = <span class="title function_">useRef</span>(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> hasMoveThreshold = !!(</span><br><span class="line">    (moveThreshold?.<span class="property">x</span> &amp;&amp; moveThreshold.<span class="property">x</span> &gt; <span class="number">0</span>) ||</span><br><span class="line">    (moveThreshold?.<span class="property">y</span> &amp;&amp; moveThreshold.<span class="property">y</span> &gt; <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffectWithTarget</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> targetElement = <span class="title function_">getTargetElement</span>(target);</span><br><span class="line">      <span class="keyword">if</span> (!targetElement?.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">overThreshold</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">        <span class="keyword">const</span> offsetX = <span class="title class_">Math</span>.<span class="title function_">abs</span>(clientX - pervPositionRef.<span class="property">current</span>.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">const</span> offsetY = <span class="title class_">Math</span>.<span class="title function_">abs</span>(clientY - pervPositionRef.<span class="property">current</span>.<span class="property">y</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !!(</span><br><span class="line">          (moveThreshold?.<span class="property">x</span> &amp;&amp; offsetX &gt; moveThreshold.<span class="property">x</span>) ||</span><br><span class="line">          (moveThreshold?.<span class="property">y</span> &amp;&amp; offsetY &gt; moveThreshold.<span class="property">y</span>)</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">getClientPosition</span>(<span class="params">event: EventType</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> <span class="title class_">TouchEvent</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">clientX</span>: event.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">clientY</span>: event.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> <span class="title class_">MouseEvent</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">clientX</span>: event.<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">clientY</span>: event.<span class="property">clientY</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Unsupported event type&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">clientX</span>: <span class="number">0</span>, <span class="attr">clientY</span>: <span class="number">0</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onStart</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; clientX, clientY &#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">          pervPositionRef.<span class="property">current</span>.<span class="property">x</span> = clientX;</span><br><span class="line">          pervPositionRef.<span class="property">current</span>.<span class="property">y</span> = clientY;</span><br><span class="line">        &#125;</span><br><span class="line">        timerRef.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onLongPressRef.<span class="title function_">current</span>(event);</span><br><span class="line">          isTriggeredRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onMove</span> = (<span class="params">event: TouchEvent</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span> &amp;&amp; <span class="title function_">overThreshold</span>(event)) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">          timerRef.<span class="property">current</span> = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onEnd</span> = (<span class="params">event: EventType, shouldTriggerClick: boolean = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isTriggeredRef.<span class="property">current</span>) &#123;</span><br><span class="line">          onLongPressEndRef.<span class="property">current</span>?.(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldTriggerClick &amp;&amp; !isTriggeredRef.<span class="property">current</span> &amp;&amp; onClickRef.<span class="property">current</span>) &#123;</span><br><span class="line">          onClickRef.<span class="title function_">current</span>(event);</span><br><span class="line">        &#125;</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onEndWithClick</span> = (<span class="params">event: EventType</span>) =&gt; <span class="title function_">onEnd</span>(event, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">          isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">          <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">          <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    [],</span><br><span class="line">    target,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略种种细节，useLongPress这个函数接收三个参数：</p><ol><li>onLongPress，顾名思义，触发长按事件的回调函数。</li><li>target：可以是dom元素，也可以是存储dom元素的ref。</li><li>第三个参数是个对象，有四个子参数：delay(长按多长时间以后触发长按事件，也就是触发长按事件的时间)、moveThreshold（在长按的过程中鼠标或者手指如果有移动，并且这个值存在，会根据这个参数的值决定是否响应长按事件）、onClick(如果有这个值，并且鼠标或者手指按压结束，并且按压时间小于delay，会调用onClick函数)、onLongPressEnd(如果按压结束已经触发过长按事件，在真正结束的时候如果有这个值会调用onLongPressEnd函数)。</li></ol><p>代码开头那个useEffectWithTarget先认为就是useEffect，先忽略useEffectWithTarget大多数代码，直接看这几句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据是否支持触摸事件，分别监听鼠标或者touch事件，响应的事件很有规律，只不过鼠标事件多了个mouseleave，这里我觉得touch事件也应该加个对应的，比如touchcancel。</p><p>onStart</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onStart</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;clientX, clientY&#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">        pervPositionRef.<span class="property">current</span>.<span class="property">x</span> = clientX;</span><br><span class="line">        pervPositionRef.<span class="property">current</span>.<span class="property">y</span> = clientY;</span><br><span class="line">    &#125; <span class="comment">// 假设没有moveThreshold，这一句先忽略</span></span><br><span class="line">    timerRef.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onLongPressRef.<span class="title function_">current</span>(event);</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay); <span class="comment">//delay秒后执行onLongPressRef.current，isTriggeredRef.current表示是否执行过onLongPress</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>onEndWithClick</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onEndWithClick</span> = (<span class="params">event: EventType</span>) =&gt; <span class="title function_">onEnd</span>(event, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onEnd</span> = (<span class="params">event: EventType, shouldTriggerClick: boolean = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>); <span class="comment">//鼠标抬起或者触摸结束时，如果onLongPress还没有调用，清除定时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTriggeredRef.<span class="property">current</span>) &#123; <span class="comment">//如果onLongPress已经被调用过了，调用onLongPressEnd（如果有）</span></span><br><span class="line">        onLongPressEndRef.<span class="property">current</span>?.(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTriggerClick &amp;&amp; !isTriggeredRef.<span class="property">current</span> &amp;&amp; onClickRef.<span class="property">current</span>) &#123; </span><br><span class="line">        onClickRef.<span class="title function_">current</span>(event);</span><br><span class="line">    &#125; <span class="comment">// 这里的shouldTriggerClick为true，如果onLongPress还没有被触发并且有onClick，调用onClick</span></span><br><span class="line">    isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>onStart与onEndWithClick其实就是onLongPress函数的核心。有时候按压的时候会移动，这时候是否触发longpress事件，这种情况就需要传moveThreshold。</p><p>这个值是个对象{x:0,y:0}，如果按压的过程中有移动，移动的距离(x&#x2F;y)大于moveThreshold.x或者moveThreshold.y，就会取消响应longPress。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onMove</span> = (<span class="params">event: TouchEvent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span> &amp;&amp; <span class="title function_">overThreshold</span>(event)) &#123; <span class="comment">//移动的时候还没有响应longPress，并且移动的距离超了，就会取消定时器</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        timerRef.<span class="property">current</span> = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是useLongPress的主要内容。</p><h2 id="useEffectWithTarget"><a href="#useEffectWithTarget" class="headerlink" title="useEffectWithTarget"></a>useEffectWithTarget</h2><p>这里顺便提一下这个hook，代码在<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/utils/createEffectWithTarget.ts">这里</a>，看起来功能和useEffect差不多，只不过多了对前后dom元素的对比，<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/utils/createEffectWithTarget.ts#L42">代码</a>，参数也由useEffect的两个变成了三个。我觉得这个hook的意义更多的在于代码的可读性，由于第三个参数的存在，可以明确表示这个hook是与哪个dom元素相关联。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>亮度、对比度、饱和度的区别</title>
      <link href="/2023/03/06/%E4%BA%AE%E5%BA%A6%E3%80%81%E5%AF%B9%E6%AF%94%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/06/%E4%BA%AE%E5%BA%A6%E3%80%81%E5%AF%B9%E6%AF%94%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始之前先看网上对这三者的解释。</p><p>亮度、对比度和饱和度是图像处理中的三个基本概念。亮度是指图像的明亮程度，对比度是指图像中最亮和最暗部分之间的差异，饱和度是指图像中颜色的鲜艳程度。一般来说，对比度越大，图像越清晰醒目，色彩也越鲜明艳丽；而对比度小，则会让整个画面都灰蒙蒙的。</p><p>看这些文字并不能完全理解这三者，反而容易混淆，看起来这三者都能调整画面的明暗，但又有所不同。</p><p>作为一个程序员，代码语言是比人言更加精确的。既然理解不了文字，就看代码如何实现。</p><h1 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustBrightness</span>(<span class="params">imageData, brightness</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    data[i] = data[i] * brightness;</span><br><span class="line">    data[i + <span class="number">1</span>] = data[i + <span class="number">1</span>] * brightness;</span><br><span class="line">    data[i + <span class="number">2</span>] = data[i + <span class="number">2</span>] * brightness;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给rgb每个值乘以一个大于0的系数brightness，brightness大于1就是增加亮度，brightness小于1就是降低亮度。所以用一句话总结：调整亮度就是给图片上每个点像素的rgb值分别乘以一个相同的系数。</p><h1 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustContrast</span>(<span class="params">imageData, contrast</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> factor = (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    data[i] = factor * (data[i] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">    data[i + <span class="number">1</span>] = factor * (data[i + <span class="number">1</span>] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">    data[i + <span class="number">2</span>] = factor * (data[i + <span class="number">2</span>] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路和调整亮度差不多，都是给rgb分别乘以某个系数，但没那么简单，主要是这两行让人很费解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> factor = (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast)); <span class="comment">// 代码1</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">data[i] = factor * (data[i] - <span class="number">128</span>) + <span class="number">128</span>; <span class="comment">// 代码2</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>公式中的255表示rgb颜色空间的最大取值，259是一个经过反复试验得出的数字，contrast取值-255到255，把contrast带入这个公式，259可以让这个公式的取值范围最接近0到128，至于整个公式的推导过程，我也搞不清楚。</p><p>我们写一些代码来看一下factor具体都有哪些值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFactor</span>(<span class="params">contrast</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=-<span class="number">255</span>;i&lt;=<span class="number">255</span>;i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getFactor</span>(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果factor取值从0到129.5，129.5趋近128，你可以试一试，把259改成258或者260，结果都不趋近128。</p><p>其实用坐标系表示更为合适：y&#x3D;(259*(x+255))&#x2F;(255*(259-x))</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/817d9b1e-a8ef-4b65-916b-031c3e94169e-image.png" alt="817d9b1e-a8ef-4b65-916b-031c3e94169e-image.png"></p><p>把这条曲线分成两部分，如果-255&lt;x&lt;0,0&lt;y&lt;1;如果0&lt;x&lt;255,1&lt;y&lt;128。</p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>假设0&lt;x&lt;255，y从1到128，把y带入代码2。带入之前先解释一下代码2，rgb颜色空间的取值范围是0-255，128是中点，之所以先用色值减去128，是为了判断色值的强弱，位于128左边的色值弱，反之则强，由于factor取值1到128，正数乘以factor，结果是比原值还大的正数，负数乘以factor，结果是比原值还小的负数。</p><p>所以如果x(对比度)大于0，代码2就能保证强者更强，弱者更弱的效果。</p><p>反之如果x(对比度)小于0，代码2也能保证强者更弱，弱者更强的效果，因为正数乘以大于0小于1的数，会变小;负数乘以大于0小于1的数，会变大。</p><h1 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h1><p>这个和前两个不一样，前两个都是先计算出一个合适的factor，然后每个像素rgb分别乘以这个factor，而饱和度却没有合适的factor，通常都是先把rgb转换成hls调节饱和度，完了再转成rgb。就像下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustSaturation</span>(<span class="params">imageData, saturation</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = data[i];</span><br><span class="line">    <span class="keyword">const</span> g = data[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> b = data[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 HSL 颜色空间</span></span><br><span class="line">    <span class="keyword">const</span> hsl = <span class="title function_">rgbToHsl</span>(r, g, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变饱和度</span></span><br><span class="line">    hsl.<span class="property">s</span> += saturation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 RGB 颜色空间</span></span><br><span class="line">    <span class="keyword">const</span> rgb = <span class="title function_">hslToRgb</span>(hsl.<span class="property">h</span>, hsl.<span class="property">s</span>, hsl.<span class="property">l</span>);</span><br><span class="line"></span><br><span class="line">    data[i] = rgb.<span class="property">r</span>;</span><br><span class="line">    data[i + <span class="number">1</span>] = rgb.<span class="property">g</span>;</span><br><span class="line">    data[i + <span class="number">2</span>] = rgb.<span class="property">b</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饱和度又叫纯度，颜色的纯度由某种颜色的主色占比决定的，所以调节饱和度就是调整某种颜色主色的占比，那如何调节这个比例，这和一些生活经验很相似，比如我们有一些浓墨，如何稀释，对没错，加水就能稀释。</p><p>那如何稀释主色，这就不能加水了，是加灰，在rgb颜色空间中，所有rgb三种一样的颜色都是灰色。</p><p>所以综上，调整某种颜色的饱和度首先要找到它的主色，然后往里面加&#x2F;减灰色。有的颜色主色很容易找到，比如rgb(255,10,10)，要增加这个颜色的饱和度，只需要减少g、b的值，比如饱和度最大的rgb(255,0,0)。有的颜色则没有这么简单，比如rgb(230,233,232)，可能就是大多数颜色都难以简单的计算出主色，所以调整饱和度不能简单的给rgb乘以一个factor。</p><h1 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h1><p>最后说一下hls颜色空间，通过上面对饱和度的解释你会发现使用rgb颜色空间可能有利于计算机存储颜色，但是不方便人类理解，hls便是解决这个问题的，hls由色相、饱和度、亮度组成，色相就是我上面说的主色，取值从0到360，所以可以理解有360种色相;饱和度指的是某种颜色色相的占比(色相与灰度的比例)。</p><p>亮度与饱和度也是容易混淆的，其实借用生活中的经验很容易区分。我们知道大多数物体本身是不发光的，光线照到物体上，物体反射光线到人眼，我们才会看到东西，这里的反射强度就是亮度的概念，而饱和度指的是某种颜色主色的占比，比如rgb(255,0,0)这种颜色，虽然红色的纯度很高，但是没有光源照射，也是看不到的，这种现象用hls描述就是hsl(0, 100%, 0%)。</p><p>明白了光源的存在，亮度与饱和度很容易区分，大多数颜色(除了灰色)都有饱和度，但是不一定有亮度，因为可能没有光源。有了以上理解，那色温就很好理解了，亮度反应的是光源与被照射物体反光的强度，而色温顾名思义则表示光的温度，关于色温的详细介绍可以参考<a href="https://zhuanlan.zhihu.com/p/56252445">这篇</a>。色温用生活中的经验也很好理解，同样的物体在日光的照耀下与在灯光的照耀下，效果肯定不一样，尤其是像自如配套的那种大黄灯。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百度云盘to阿里云盘</title>
      <link href="/2022/08/07/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98to%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"/>
      <url>/2022/08/07/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98to%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2T百度云终究还是满了，常年的日积月累，删又不知道该该删啥。阿里云盘最近兴起，如果能把部分文件移到阿里云盘里就好了，由于众所周知的原因，百度与阿里的数据是不可能相通的，也不可能会出现官方的xxx迁移工具之类的。所以，这又是一个八仙过海各显神通的活，大家的思路普遍都是先把百度云盘里的资料下载下来，然后再上传到阿里云，这让我想起来宋丹丹的一句名言，把大象装冰箱分几步…</p><p>思路是这样没错，但是大神的做法跟普通人就是不一样，可以参考<a href="https://www.zhihu.com/question/451854774">这个</a> 帖子。本文介绍的是用webdav的那个。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/5e45b33c-8480-4dba-8cf1-8508e26acfa3-image.png" alt="5e45b33c-8480-4dba-8cf1-8508e26acfa3-image.png"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文只适用于windows操作系统。</p><p>整体的流程就是帖子里说的1、2、3、4、5，不过作为一个务实的搬运工，实际操作过程中有跟帖子不一样的地方。</p><h2 id="第一处："><a href="#第一处：" class="headerlink" title="第一处："></a>第一处：</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d98d7fa0-8ced-43b5-9fd8-e09b8bd0e6ca-image.png" alt="d98d7fa0-8ced-43b5-9fd8-e09b8bd0e6ca-image.png"></p><p>作者一笔带过…。正常操作是这样的，找到你电脑的“启动或关闭windows功能”，然后找到Hyper-V选项，勾上。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/2ac146d3-b31d-45d0-a7d6-1afa9d862691-image.png" alt="2ac146d3-b31d-45d0-a7d6-1afa9d862691-image.png"></p><p>有些人可能找不到Hyper-V选项（比如我），这种情况需要单独安装Hyper-V，参考<a href="https://blog.csdn.net/weixin_37695006/article/details/91589895">这篇</a> .</p><p>在实际操作过程中发现Hyper-V.cmd下载资源很慢，所以最好加上这一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winhttp set proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>如果一切顺利，你的“启动或关闭windows功能“里面就能找到Hyper-V了。</p><h2 id="第二处："><a href="#第二处：" class="headerlink" title="第二处："></a>第二处：</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/c83d80c9-7029-442a-9909-7ae7104cfeaf-image.png" alt="c83d80c9-7029-442a-9909-7ae7104cfeaf-image.png"></p><p>又是一笔带过。实际情况是下载安装都没问题，但是运行不起来，类似于这张图：</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/ee5cccf5-a51c-4c0e-8d7d-cbf87c801fba-image.png" alt="ee5cccf5-a51c-4c0e-8d7d-cbf87c801fba-image.png"></p><p>这个问题搞得我都快放弃了，后来搞了个低版本的<a href="mailto:&#x64;&#x6f;&#x63;&#107;&#x65;&#114;&#x40;&#x34;&#x2e;&#x35;&#x2e;&#49;">&#x64;&#x6f;&#x63;&#107;&#x65;&#114;&#x40;&#x34;&#x2e;&#x35;&#x2e;&#49;</a>，装上后，还是一样的症状，不过弹了另一个提示，大概内容是我机器上的wsl版本太低，打开给定的链接更新wsl，然后再restart。</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">链接</a></p><p>按照链接里面的步骤搞完后，docker果然跑起来了。</p><p>其实也可以升级windows版本，我原先是家庭版，升级到pro，docker也跑起来了。</p><h2 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/07339a99-030b-4140-b899-366904904ea7-image.png" alt="07339a99-030b-4140-b899-366904904ea7-image.png"></p><p>这个也很坑，老说我没权限什么的，为此，我还专门注册了个docker账号，最后的结果是zx5253&#x2F;webdav-aliyundriver的作者删库了。好吧，那就找替代品，最后用的是<a href="https://github.com/messense/aliyundrive-webdav">这个</a></p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/fad8809b-61e5-42bf-9f79-7d553a827bd1-image.png" alt="fad8809b-61e5-42bf-9f79-7d553a827bd1-image.png"></p><h2 id="第四处"><a href="#第四处" class="headerlink" title="第四处"></a>第四处</h2><p>这一步需要注意的是那个截图</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/72cef2ba-086b-4c61-b62e-0f532d30471d-image.png" alt="72cef2ba-086b-4c61-b62e-0f532d30471d-image.png"></p><p>红色框图里面的小盾牌表示是否启用https，不要勾选。</p><h2 id="第五处"><a href="#第五处" class="headerlink" title="第五处"></a>第五处</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/38dd9679-108d-4ff1-a924-59787038a263-image.png" alt="38dd9679-108d-4ff1-a924-59787038a263-image.png"></p><p>简简单单三个字：连接后。问题是我根本就连接不上。也是弹了个错误提示：“由于目标计算机积极拒绝，无法连接”。</p><p>这一步也搞得我快要放弃了，网上找了各种办法都没用，最后还是重启大法好，不过重启的是docker的container，也就是这一步在重启的过程中出问题了，解决了这一问题，上一步奇迹般的连接上了。</p><p><a href="https://stackoverflow.com/questions/65272764/ports-are-not-available-listen-tcp-0-0-0-0-50070-bind-an-attempt-was-made-to">参考</a> </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">docker <span class="built_in">start</span> container_name</span><br><span class="line">net <span class="built_in">start</span> winnat</span><br></pre></td></tr></table></figure><p>经过后来的实践，我发现先启动raidriver，然后再启动docker，是直接可以连上的。第一次按教程上的步骤，顺序反而是反的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>写一个左划删除功能</title>
      <link href="/2022/02/13/%E5%86%99%E4%B8%80%E4%B8%AA%E5%B7%A6%E5%88%92%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/02/13/%E5%86%99%E4%B8%80%E4%B8%AA%E5%B7%A6%E5%88%92%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>需求是写一个小程序，用来实现一个app大部分功能。里面有个功能是列表的左划删除，可能app那边有现成的组件&#x2F;库可以用，小程序官方没有提供这样的组件，于是求助于google。</p><p>搜到了<a href="https://segmentfault.com/a/1190000014831500">这个</a> ,看起来挺好的，但是要求高度固定，我列表里面有图片，我无法确定图片的高度固定，跟相关人员沟通起来又是一堆废话，算是备选。</p><p>然后找到了<a href="https://nutui.jd.com/#/swipe">这个</a></p><p>nutui的swipe组件，<a href="https://github.com/jdf2e/nutui/blob/6e63e992565ce404fbbe3a63d459794f141cb4a9/src/packages/__VUE/swipe/index.taro.vue">源码</a> vue写的，我项目用的是react，不过没关系，vue3的Composition api与react hooks是师出同门。看懂它然后翻译一下(我又找到了一个适合自己的巨人)。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>html、css、js永远是一家人，不要看不起html、css，优秀的布局可以省好多代码。</p><iframe src="https://codesandbox.io/embed/distracted-haibt-9sp3o?fontsize=14&hidenavigation=1&theme=light" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:250px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>布局分为3部分，content、left、right，content为列表的主要内容，left&#x2F;right分别表示向右&#x2F;左滑所展示的额外内容，然后left、right分别绝对定位，并且配合translate移出content的可见范围。</p><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view</span><br><span class="line">    :class=&quot;classes&quot;</span><br><span class="line">    :style=&quot;touchStyle&quot;</span><br><span class="line">    @touchstart=&quot;onTouchStart&quot;</span><br><span class="line">    @touchmove=&quot;onTouchMove&quot;</span><br><span class="line">    @touchend=&quot;onTouchEnd&quot;</span><br><span class="line">    @touchcancel=&quot;onTouchEnd&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;view class=&quot;nut-swipe__left&quot; ref=&quot;leftRef&quot; :id=&quot;&#x27;leftRef-&#x27; + refRandomId&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view class=&quot;nut-swipe__content&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view class=&quot;nut-swipe__right&quot; ref=&quot;rightRef&quot; :id=&quot;&#x27;rightRef-&#x27; + refRandomId&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touchStyle = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="string">`translate3d(<span class="subst">$&#123;state.offset&#125;</span>px, 0, 0)`</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一目了然。有三个slot，分别对应上述布局中的content、left、right。监听了最外层view的touch事件，目的是根据touch时的各种值来控制offset的值，从而生成touchStyle，使最外层的view移动。</p><p>那么如何得到touch事件的各种值呢，他们封装了个<a href="https://github.com/jdf2e/nutui/blob/6e63e992565ce404fbbe3a63d459794f141cb4a9/src/packages/utils/useTouch/index.ts">useTouch</a> </p><p>代码还是挺简的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startX = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">//滑动起始x值</span></span><br><span class="line"><span class="keyword">const</span> startY = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// 滑动起始y值</span></span><br><span class="line"><span class="keyword">const</span> deltaX = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// 滑动的x值</span></span><br><span class="line"><span class="keyword">const</span> deltaY = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// 滑动的y值</span></span><br><span class="line"><span class="keyword">const</span> offsetX = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// deltaX的绝对值</span></span><br><span class="line"><span class="keyword">const</span> offsetY = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// deltaY的绝对值</span></span><br><span class="line"><span class="keyword">const</span> direction = ref&lt;<span class="title class_">Direction</span>&gt;(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 滑动的方向</span></span><br></pre></td></tr></table></figure><p>有三个函数，reset&#x2F;start&#x2F;move，start与move分别在touchStart与touchMove时调用，用来记录滑动的距离，调用start时会调用reset。</p><p>值得一提的是，这里计算滑动方向的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDirection</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y &amp;&amp; x &gt; <span class="variable constant_">MIN_DISTANCE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;horizontal&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; x &amp;&amp; y &gt; <span class="variable constant_">MIN_DISTANCE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;vertical&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是根据每次滑动offsetX与offsetY的大小以及滑动距离是否大于10决定的。</p><p>再来看swipe组件处理滑动的逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initWidth</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    leftRefWidth.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">getRefWidth</span>(leftRef);</span><br><span class="line">    rightRefWidth.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">getRefWidth</span>(rightRef);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">initWidth</span>();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先拿到left slot与right slot的宽度，如果没有，就是0。然后会监听touchstart、touchmove、touchend事件。</p><p>touchstart</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onTouchStart</span>(<span class="params">event: Event</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (props.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line">    touch.<span class="title function_">start</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平淡无奇，核心是调用了touch.start方法。</p><p>onTouchMove</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">onTouchMove</span>(<span class="params">event: Event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line">    touch.<span class="title function_">move</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (touch.<span class="title function_">isHorizontal</span>()) &#123;</span><br><span class="line">      state.<span class="property">moving</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">setoffset</span>(touch.<span class="property">deltaX</span>.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">if</span> (props.<span class="property">touchMovePreventDefault</span>) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props.<span class="property">touchMoveStopPropagation</span>) &#123;</span><br><span class="line">        event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是调用touch.move以及setoffset方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setoffset</span> = (<span class="params">deltaX: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">      position = deltaX &gt; <span class="number">0</span> ? <span class="string">&#x27;right&#x27;</span> : <span class="string">&#x27;left&#x27;</span>;</span><br><span class="line">      <span class="keyword">let</span> offset = deltaX;</span><br><span class="line">      <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> (opened &amp;&amp; oldPosition === position) &#123;</span><br><span class="line">            offset = -rightRefWidth.<span class="property">value</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; rightRefWidth.<span class="property">value</span> ? -rightRefWidth.<span class="property">value</span> : deltaX;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> (opened &amp;&amp; oldPosition === position) &#123;</span><br><span class="line">            offset = leftRefWidth.<span class="property">value</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; leftRefWidth.<span class="property">value</span> ? leftRefWidth.<span class="property">value</span> : deltaX;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      state.<span class="property">offset</span> = offset;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>这几行if else写的很精妙。swipe组件同时支持左&#x2F;右滑，先来看左划的逻辑。</p><p>opened表示是否已经打开，如果是true并且本次滑动方向与上一次一致，那么offset永远等于-rightRefWidth。</p><p>假设是第一次滑，并且right slot不为空，走的是这句代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; rightRefWidth.<span class="property">value</span> ? -rightRefWidth.<span class="property">value</span> : deltaX;</span><br></pre></td></tr></table></figure><p>精妙的三元表达式，无形中处理了很多边界情况，先看最正常的：第一次滑，并且right slot不为空。</p><p>这时Math.abs(deltaX) &lt; rightRefWidth，所以offset为deltaX。</p><p>那什么时候Math.abs(deltaX) &gt;&#x3D; rightRefWidth呢，要么right slot完全被划出，要么right slot 为空。假设right slot为空，这时再左滑是滑不动的。</p><p>右滑同理。</p><p>onTouchEnd</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onTouchEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (state.<span class="property">moving</span>) &#123;</span><br><span class="line">  state.<span class="property">moving</span> = <span class="literal">false</span>;</span><br><span class="line">  oldPosition = position;</span><br><span class="line">  <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(state.<span class="property">offset</span>) &lt;= rightRefWidth.<span class="property">value</span> / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.<span class="property">offset</span> = -rightRefWidth.<span class="property">value</span>;</span><br><span class="line">        <span class="title function_">open</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(state.<span class="property">offset</span>) &lt;= leftRefWidth.<span class="property">value</span> / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.<span class="property">offset</span> = leftRefWidth.<span class="property">value</span>;</span><br><span class="line">        <span class="title function_">open</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法隐藏着一个小小的交互体验。假设onTouchEnd触发时，左滑的距离小于rightRefWidth的一半，会自动close，反之open。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">open</span> = (<span class="params">p: SwipePosition = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">     opened = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (p) &#123;</span><br><span class="line">       state.<span class="property">offset</span> = p === <span class="string">&#x27;left&#x27;</span> ? -rightRefWidth.<span class="property">value</span> : leftRefWidth.<span class="property">value</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// emit(&#x27;open&#x27;, &#123;</span></span><br><span class="line">     <span class="comment">//   name: props.name,</span></span><br><span class="line">     <span class="comment">//   position: position || p</span></span><br><span class="line">     <span class="comment">// &#125;);</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">close</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">     state.<span class="property">offset</span> = <span class="number">0</span>;</span><br><span class="line">     opened = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// emit(&#x27;close&#x27;, &#123;</span></span><br><span class="line">     <span class="comment">//   name: props.name,</span></span><br><span class="line">     <span class="comment">//   position</span></span><br><span class="line">     <span class="comment">// &#125;);</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>open与close所做的事是分别让offset达到最大值或者最小值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何下载腾讯课堂视频</title>
      <link href="/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/"/>
      <url>/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>腾讯课堂“贴心”的给我们提供了回放功能，但是图心理安慰，老想着如何下载下来才安心。（自己看，不传播）</p><p>随便打开一个腾讯课堂视频，比如<a href="https://ke.qq.com/course/2994329?taid=12141623440683161">这个</a> 随便找一个。chrome浏览器右击检查，打开开发者控制台，NetWork面板，再次刷新网页，NetWork筛选m3u8关键词。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png" alt="f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png"></p><p>这便是该视频不同分辨率的资源，这些链接是不能直接下载的，需要解密，用<a href="https://github.com/nilaoda/N_m3u8DL-CLI/tree/master/N_m3u8DL-CLI">这个</a> 解，貌似c#写的。</p><p>对，没错，我就是搬用工，一点技术含量也没有。</p><p>如果有多个视频需要下载，上述过程略显麻烦。可以移步火狐浏览器，下载Video DownloadHelper 插件，这玩意能直接识别出资源，并且告诉你不同的分辨率，然后还是需要解密m3u8。</p><p>如果需要下载的视频巨多，连用插件copy链接都觉的麻烦，后续看能不能写个爬虫什么的，自动copy链接。然后研究下解密m3u8那工具支不支持批量下载，暂时就这样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习java内部类</title>
      <link href="/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个只擅长javascript的伪程序员，学习java还是挺费劲的，不过没关系，再庞然大物，也能分而治之。</p><p>google搜内部类，好多文章都说java有四种内部类。成员内部类，静态内部类、局部内部类、匿名内部类。记性好的可以直接记住，彷佛回到了读书时代。</p><h1 id="四大内部类"><a href="#四大内部类" class="headerlink" title="四大内部类"></a>四大内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>java是一门强大的面向对象编程语言。在java中，一个类的成员变量，可以是字符串、数字这样的基础数据类型，也可以是数组、Map这样的复杂数据类型，甚至可以是别的类的实例，那为什么不能是一个类呢？</p><p>所以把一个类放在java的成员变量位置上，这个类就是成员内部类，放到静态变量位置上，这个类就是静态内部类。</p><p>所以很容易写出这样的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a); <span class="comment">//标记1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxOuterClass</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>();</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> n.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">//标记2</span></span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java这门语言单从长相上还是挺像typescript的。但是typescript是没有内部类概念的。上面那段代码有几处奇怪的地方，首先是标记1那个孤零零的a变量，实际上java会先找Inner上有没有叫a的成员变量，如果没有，再去找xxxOuterClass。</p><p>再来看标记2，内部类是怎么被实例化的。成员内部类依附于它所对应的外部类，所以需要先实例化一个外部类。这不奇怪，想也能想通，奇怪的是new 操作符就然可以那样使用。按照正常的思维，难道不是xxxOuterClass.Inner m &#x3D; new n.Inner()吗？</p><p>既然一个类可以作为另一个类的成员，那么Inner是否能被访问修饰符修饰呢？实际上分别用public、protected、private修饰Inner，并不报错，只不过用private修饰Inner，在TY中不能实例化Inner。那继承呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TY2</span> <span class="keyword">extends</span> <span class="title class_">xxxOuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TY2</span> <span class="variable">ty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TY2</span>();</span><br><span class="line">        TY2.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> ty.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来也是可以的。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cwwd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>.Inner();</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和静态变量差不多。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>所谓局部内部类就是说一个类可以写到某个方法内部。 你用学js的思维去学java就感觉特别烦，什么花花草草都要起个名字。这不是理所当然的吗？</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类不是说某个类没有名字，而是说你可以直接继承&#x2F;实现某个类，然后直接new，不用写那么多繁文缛节。通常配合接口与抽象类来使用。看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo2 log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，在java中，抽象类只能被继承，不能直接实例化，接口只能被实现，不能直接实例化。现在有了特例，除非被用于匿名内部类。</p><p>上面的代码按正常思路应该这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo3</span> <span class="keyword">extends</span> <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">xxxFoo3</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo3</span>();</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo4</span> <span class="keyword">implements</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此，在这个例子中，所谓匿名，确实省了两个名字。但是转念一想，这不是概念冲突嘛，明明抽象类和接口都不能直接实例化，为啥用于匿名内部类就可以。其实匿名内部类是一种语法糖，java编译器会帮忙补齐缺失的语法。稍微改一下上面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        foo.log();</span><br><span class="line">        foo2.log2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，还是会有类，只不过不用开发者操心。</p><h1 id="直接继承内部类"><a href="#直接继承内部类" class="headerlink" title="直接继承内部类"></a>直接继承内部类</h1><p>我们可以先实例化出外部类，然后再实例化出内部类。我们也可以直接继承一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxxxOuter</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">xxxInner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxxInner2</span> <span class="keyword">extends</span> <span class="title class_">xxxxOuter</span>.xxxInner&#123;</span><br><span class="line">    xxxInner2(xxxxOuter wi)&#123;</span><br><span class="line">        wi.<span class="built_in">super</span>(); <span class="comment">//标记1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxInner2</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxInner2</span>(<span class="keyword">new</span> <span class="title class_">xxxxOuter</span>());</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于成员内部类依赖与外部类，所以xxxInner2的构造函数必须接收一个xxxxOuter的实例，然后调用其super方法。</p><p>但是奇怪的是，在我的idea上wi.super标红了，idea认为wi上没有super这个方法？但却可以运行！为啥这里需要调用wi上的super方法，super不是表示父类&#x2F;父类构造器嘛，xxxxOuter并没有父类，为啥这里不写成wi.constructor()之类的更语义化的api？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习vue-clamp</title>
      <link href="/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/"/>
      <url>/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/Justineo/vue-clamp">项目地址</a></p><p>无意间看到这个库，利用getClientRects与二分法实现多行文字的超出截断，虽说flex更简洁，但是想起我n年前兼容IE时的痛楚，虽说现在不用兼容IE了，但是原理什么的还是忍不住瞅一眼。</p><p>关键是知不知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects">getClientRects</a> 。这玩意兼容性好强大。假如是行内元素调用getClientRects，会返回一个rects集合，这个集合的length就是文本的行数，好简洁，完全不用关心行高什么的。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><ol><li>tag: 由于内部是由render函数生成的vnode，比起template，tag是可以变的，默认是div。</li><li>autoresize: 内部使用resize-detector这个库监听组件的resize事件，size变化时，更新截断状态。</li><li>max-lines: 最大行数</li><li>max-height: 最大高度。max-height与max-lines指定一个即可。</li><li>ellipsis: 省略符号，默认…</li><li>location: ellipsis的位置，默认end。</li><li>expanded: 初始状态是否展开，默认false。</li></ol><p>slot</p><ol><li>default：默认插槽为文本的实际内容（非展示内容）。</li><li>after&#x2F;before：这俩插槽取其一，关于它们的slot scope后面会说。</li></ol><h1 id="用代码简述原理"><a href="#用代码简述原理" class="headerlink" title="用代码简述原理"></a>用代码简述原理</h1><p>vue组件不好解释，语法灵活&#x2F;随意，各种数据自动响应，计算属性什么的互相依赖，读起来挺爽的，给别人解释可太难了。所以我先写个小而美的clamp，方便理解核心原理。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">      <span class="attr">lines</span>:&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">          <span class="attr">default</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">text</span>:<span class="variable language_">this</span>.<span class="title function_">getText</span>(),</span><br><span class="line">            <span class="attr">offsetSet</span>: <span class="variable language_">this</span>.<span class="title function_">getText</span>().<span class="property">length</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> [content] = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;content&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">search</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">search</span>(<span class="params"><span class="keyword">from</span>=<span class="number">0</span>,to=<span class="variable language_">this</span>.text.length</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(to-<span class="keyword">from</span>&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">offset</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="keyword">from</span> + to) / <span class="number">2</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">text</span>.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="keyword">from</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="variable language_">this</span>.<span class="property">offset</span>,to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getText</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> [content] = (<span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> || []).<span class="title function_">filter</span>(</span><br><span class="line">                <span class="function">(<span class="params">node</span>) =&gt;</span> !node.<span class="property">tag</span> &amp;&amp; !node.<span class="property">isComment</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> content ? content.<span class="property">text</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getLines</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="title function_">getClientRects</span>().<span class="property">length</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">isOverflow</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLines</span>() &gt; <span class="variable language_">this</span>.<span class="property">lines</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个props（lines：表示文本的行数），data里面有两个属性text与offset，text表示原始的文本，offset是个信标，表示发生截断的位置，只要offset不等于text的长度，就认为文本发生了截断。</p><p>render函数里面拿到了默认插槽的vnode，并用span渲染出来，为什么是span，因为只有行内元素调用getClientRects才会返回文本长度。从这里还可以看出，插槽与渲染竟然可以分开！！<br>第一次渲染会渲染出全部文本，在mounted里面通过isOverflow判断是否溢出，即文本的实际行数是否大于props.lines，如果发生了溢出，调用search方法，search方法使用了二分法不停的改变offset的位置，直到from与to的差值小于等于3，为什么是3呢，我猜是省略号(…)的长度，这样就算出了最佳的offset以及最佳的截断文本。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>源码与我那个有什么不同：</p><ol><li>支持更多的props</li><li>检测元素的尺寸是否发生变化</li><li>支持更多的插槽</li></ol><p>可以自定义tag，设置是否检测元素的尺寸变化，是否以maxHeight代替maxLines，设置省略号的文本（默认是…），以及省略号的位置。expanded设置初次渲染是否展开文本.</p><p>先从render函数看起。<br><a href="https://github.com/Justineo/vue-clamp/blob/master/src/components/Clamp.js#L227">render</a><br>整体来看，多了before与after插槽的逻辑，before与after取其一。值得注意的是this.$scopedSlots这个api，作用域插槽在render函数里面竟然是这样用的，scope就是传递给插槽的作用域，this.$scopedSlots.before&#x2F;afer(scope)的结果是vnode。然后竟然可以把组件的方法传给scope，又学到了。</p><p>mounted调用init，init内部有一些是否检测元素尺寸变化的逻辑，用了resize-detector，这个库也是作者写的，init最终调用update。update开篇有个localExpanded，这个就是props.expanded，内部写了几个watch来同步两者的状态。然后调用search，和上面的精简版不一样的是多了个stepToFit方法，这个方法的作用是微调offset，即在用二分法得到最终的文本后，最后一行文本的长度可能不满一行，先调用fill方法使文本充满一行（可能发生换行），然后调用clamp方法使文本刚好充满一行。</p><p>原理就是这样。看一下github上的demo。</p><p>before&#x2F;after插槽是个button，点击button调用了toggle方法。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toggle () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">localExpanded</span> = !<span class="variable language_">this</span>.<span class="property">localExpanded</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句话会触发localExpanded的watch</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clampAt</span>(<span class="variable language_">this</span>.<span class="property">text</span>.<span class="property">length</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果localExpanded为true，还原文本，否则，重新截断文本。</p><p>最后，值得注意的是mounted里面的watch写法</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$watch(</span><br><span class="line">  <span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">maxLines</span>, vm.<span class="property">maxHeight</span>, vm.<span class="property">ellipsis</span>, vm.<span class="property">isClamped</span>].<span class="title function_">join</span>(),</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">update</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">tag</span>, vm.<span class="property">text</span>, vm.<span class="property">autoresize</span>].<span class="title function_">join</span>(), <span class="variable language_">this</span>.<span class="property">init</span>)</span><br></pre></td></tr></table></figure><p>又学到了，这种做法可以同时watch多个参数，执行相同的逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习ahooks之useRequest</title>
      <link href="/2021/12/03/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseRequest/"/>
      <url>/2021/12/03/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseRequest/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ahooks算是react hooks生态库重要的一环，其中useRequest算是使用比较多的hooks。（试问哪个前端页面没有http请求）</p><h1 id="useRequest的自我介绍"><a href="#useRequest的自我介绍" class="headerlink" title="useRequest的自我介绍"></a>useRequest的自我介绍</h1><p>useRequest 是一个强大的异步数据管理的 Hooks，React 项目中的网络请求场景使用 useRequest 就够了。</p><p>useRequest 通过插件式组织代码，核心代码极其简单，并且可以很方便的扩展出更高级的功能。目前已有能力包括….</p><p>主要是第二句：useRequest的核心代码很简单，其他什么防抖、节流都是通过插件实现的。</p><h1 id="代码分层"><a href="#代码分层" class="headerlink" title="代码分层"></a>代码分层</h1><p>带着上一节的官方介绍来看useRequest的代码分层<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequest.ts">入口文件</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useRequest&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(</span><br><span class="line">  <span class="attr">service</span>: <span class="title class_">Service</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  options?: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  plugins?: <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[],</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> useRequestImplement&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;(service, options, [</span><br><span class="line">    ...(plugins || []),</span><br><span class="line">    useDebouncePlugin,</span><br><span class="line">    useLoadingDelayPlugin,</span><br><span class="line">    usePollingPlugin,</span><br><span class="line">    useRefreshOnWindowFocusPlugin,</span><br><span class="line">    useThrottlePlugin,</span><br><span class="line">    useRefreshDeps,</span><br><span class="line">    useCachePlugin,</span><br><span class="line">    useRetryPlugin,</span><br><span class="line">    useReadyPlugin,</span><br><span class="line">  ] <span class="keyword">as</span> <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useRequest接收service、options、plugin三个参数，随后又调用了useRequestImplement函数，参数为service、options，plugins变成自定义plugins与内置plugins的集合。</p><p>其中service是一个返回promise的函数，也就是封装http request的函数。options则是一个参数大集合，除了 <a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-request/basic#options">base option</a> 以外，还包括内置插件的options。</p><p>从这里其实印证了官方的说法：useRequest的核心功能简单，其他的功能都是插件实现的（包括内置插件与自定义插件）。扒一扒useRequestImplement的源码，看看大佬所说的简单到底有多简单。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequestImplement.ts#L12">useRequestImplement</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useRequestImplement&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(</span><br><span class="line">  <span class="attr">service</span>: <span class="title class_">Service</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt; = &#123;&#125;,</span><br><span class="line">  <span class="attr">plugins</span>: <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[] = [],</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; manual = <span class="literal">false</span>, ...rest &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchOptions = &#123;</span><br><span class="line">    manual,</span><br><span class="line">    ...rest,</span><br><span class="line">  &#125;;  <span class="comment">//这两句挺费解的，其实可以更简 const fetchOptions = &#123;manual:false,...options&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> serviceRef = <span class="title function_">useLatest</span>(service); <span class="comment">//第一个旁支useLatest。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">useUpdate</span>(); <span class="comment">// 第二个旁支</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchInstance = <span class="title function_">useCreation</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initState = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p?.<span class="property">onInit</span>?.(fetchOptions)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">    <span class="comment">// 第六个旁支</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fetch</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;(</span><br><span class="line">      serviceRef,</span><br><span class="line">      fetchOptions,</span><br><span class="line">      update,</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...initState),</span><br><span class="line">    );</span><br><span class="line">  &#125;, []); <span class="comment">// useCreation第三个旁支</span></span><br><span class="line">  fetchInstance.<span class="property">options</span> = fetchOptions;</span><br><span class="line">  <span class="comment">// run all plugins hook</span></span><br><span class="line">  fetchInstance.<span class="property">pluginImpls</span> = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> <span class="title function_">p</span>(fetchInstance, fetchOptions)); <span class="comment">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class="line">    <span class="comment">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useMount</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 第四个旁支</span></span><br><span class="line">    <span class="keyword">if</span> (!manual) &#123;</span><br><span class="line">      <span class="comment">// useCachePlugin can set fetchInstance.state.params from cache when init</span></span><br><span class="line">      <span class="keyword">const</span> params = fetchInstance.<span class="property">state</span>.<span class="property">params</span> || options.<span class="property">defaultParams</span> || [];</span><br><span class="line">      <span class="comment">// @ts-ignore</span></span><br><span class="line">      fetchInstance.<span class="title function_">run</span>(...params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useUnmount</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 第五个旁支</span></span><br><span class="line">    fetchInstance.<span class="title function_">cancel</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">loading</span>: fetchInstance.<span class="property">state</span>.<span class="property">loading</span>,</span><br><span class="line">    <span class="attr">data</span>: fetchInstance.<span class="property">state</span>.<span class="property">data</span>,</span><br><span class="line">    <span class="attr">error</span>: fetchInstance.<span class="property">state</span>.<span class="property">error</span>,</span><br><span class="line">    <span class="attr">params</span>: fetchInstance.<span class="property">state</span>.<span class="property">params</span> || [],</span><br><span class="line">    <span class="attr">cancel</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">cancel</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">refresh</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">refresh</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">refreshAsync</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">refreshAsync</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">run</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">run</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">runAsync</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">runAsync</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">mutate</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">mutate</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">Result</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;;</span><br><span class="line">&#125;<span class="comment">// 第七个旁支useMemoizedFn</span></span><br></pre></td></tr></table></figure><p>上面一波粗略的阅读虽然遇到了6个旁支，但是根据变量的命名以及官方文档我们可以猜一猜useRequestImplement都干了什么事。</p><p><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-latest">useLatest</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-update">useUpdate</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-creation">useCreation</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-mount">useMount</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-unmount">useUnmount</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn">useMemoizedFn</a></p><p>通过文档可以看出useLatest的作用是返回某个参数的最新值，useCreation的作用是使某个值保持绝对不变（除非依赖发生变化）,useMemoizedFn的作用是使函数的地址永远不变。这三个都属于性能优化hook，对于我们理解useRequest可以暂时忽略。</p><p>而useUpdate，顾名思义，返回一个强制刷新的函数，用于整个组件树重新渲染。</p><p>useMount与useUnmount属于生命周期hook，分别在组件挂载与卸载时触发。</p><p>综上，useRequestImplement做的事其实就是，通过new Fetch生成一个fetchInstance实例，参数除了serviceRef、fetchOptions、update外，还有initState。瞅一眼initState。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p?.<span class="property">onInit</span>?.(fetchOptions)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  (<span class="attr">fetchInstance</span>: <span class="title class_">Fetch</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;, <span class="attr">options</span>: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;): <span class="title class_">PluginReturn</span>&lt;</span><br><span class="line">    <span class="title class_">TData</span>,</span><br><span class="line">    <span class="title class_">TParams</span></span><br><span class="line">  &gt;;</span><br><span class="line">  onInit?: <span class="function">(<span class="params">options: Options&lt;TData, TParams&gt;</span>) =&gt;</span> <span class="title class_">Partial</span>&lt;<span class="title class_">FetchState</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这两处可以看出每个plugin都可以有个onInit函数，返回值是部分FetchState对象，这个对象的集合就是initState。 瞅一眼Fetch的构造函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> options: Options&lt;TData, TParams&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> subscribe: Subscribe,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      ...<span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">      <span class="attr">loading</span>: !options.<span class="property">manual</span>,</span><br><span class="line">      ...initState,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看出，onInit的作用其实就是在初始化fetchInstance时，通过插件的形式生成initState，initState会在new Fetch时作为state的默认值。</p><p>回到主线，生成fetchInstance实例后，会在fetchInstance上放一些东西。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetchInstance.<span class="property">options</span> = fetchOptions;</span><br><span class="line">  <span class="comment">// run all plugins hooks</span></span><br><span class="line">fetchInstance.<span class="property">pluginImpls</span> = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> <span class="title function_">p</span>(fetchInstance, fetchOptions)); <span class="comment">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class="line"><span class="comment">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16">PluginReturn</a></p><p>pluginImpls其实就是一个含有onBefore、onRequest…等生命周期函数的对象集合。而这些生命周期就是插件系统的灵魂。Fetch内部通过一个叫runPluginHandler的函数调用各个插件（pluginImpls）。</p><p>大概瞅一眼<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L37">runPluginHandler</a> 的实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">runPluginHandler</span>(<span class="params">event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="variable language_">this</span>.<span class="property">pluginImpls</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i[event]?.(...rest)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看Fetch内部都在什么时机调用runPluginHandler。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L43">runAsync</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L136">cancel</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155">mutate</a></p><p>runAsync方法会在请求的各个阶段调用runPluginHandler（请求前&#x2F;中&#x2F;后…），onBefore&#x2F;onRequest&#x2F;onSuccess…，而这些钩子函数或者直接干预runAsync的执行，或者通过返回<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16">约定的值</a> 来干预runAsync的执行。</p><p>总的来说，所谓的插件就是一个返回PluginReturn的函数，而PluginReturn中的各个生命周期函数会在Fetch的关键方法执行时调用。</p><p>这就是插件的工作原理，我们也可以写插件来执行上述过程。</p><p>回到主线。在组件挂载时执行fetchInstance.run()（假设manual为false），组件卸载时执行fetchInstance.cancel()，然后返回一大堆fetchInstance的属性&#x2F;方法。</p><h1 id="旁支"><a href="#旁支" class="headerlink" title="旁支"></a>旁支</h1><h2 id="Fetch类"><a href="#Fetch类" class="headerlink" title="Fetch类"></a>Fetch类</h2><p>用面向对象的思维封装了useRequest关于网络请求的几个api，在这里插一句话，我以前不重视面向对象那一套东西，其实在某些场景下，面向对象的可封装性与代码的可读性是优于函数式编程的，配合typescript的类型系统写起来不要太爽。</p><p>Fetch洋洋洒洒150+代码，从run函数开刀。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">run</span>(<span class="params">...params: TParams</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">runAsync</span>(...params).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">onError</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数调用了runAsync函数。那run与runAsync有啥区别呢，文档是这样写的。<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/65b965bf-b6f8-4928-a641-0b986ccc5274-image.png" alt="65b965bf-b6f8-4928-a641-0b986ccc5274-image.png"><br>这句话具有误导作用，runAsync本质上是个async函数.<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L94">onSuccess</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L103">resolve</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L115">onError</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L124">reject</a><br>代码很清晰，run调用了runAsync,后者在执行过程中不管是options里面的success&#x2F;error，还是promise形式的resolve&#x2F;reject都会执行。</p><p>而整个runAsync的执行过程分为三部分，请求前&#x2F;中&#x2F;后。</p><p>请求前：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> currentCount = <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  stopNow = <span class="literal">false</span>,</span><br><span class="line">  returnNow = <span class="literal">false</span>,</span><br><span class="line">  ...state</span><br><span class="line">&#125; = <span class="variable language_">this</span>.<span class="title function_">runPluginHandler</span>(<span class="string">&#x27;onBefore&#x27;</span>, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop request</span></span><br><span class="line"><span class="keyword">if</span> (stopNow) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">  params,</span><br><span class="line">  ...state,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return now</span></span><br><span class="line"><span class="keyword">if</span> (returnNow) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(state.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">onBefore</span>?.(params);</span><br></pre></td></tr></table></figure><p>可以先忽略那个奇怪的count，还是挺简单的，先是调用了所有插件的onBefore钩子。如果stopNow &#x3D;&#x3D;&#x3D; true，返回一个空的promise，否则调用setState设置params和loading，这里的setState和react的setState是雷锋和雷峰塔的关系。<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L29">setState</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(<span class="params">s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        ...<span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">        ...s,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了一个奇怪的subscribe函数，这个subscribe就是Fetch实例化时传入的update函数（useUpdate），目的是使组件rerender，让react组件拿到最新的Fetch成员变量。</p><p>回到runAsync主线。如果returnNow &#x3D;&#x3D;&#x3D; true，返回空的promise，与前一步骤不同的是，这时的loading是true。然后调用options的onBefore函数，说明插件的onBefore是先于options.onBefore执行的，并且可以干预是否执行options.onBefore。</p><p>请求中与请求后分别对应try&#x2F;catch代码块，暂且忽略count，先调用插件的onRequest钩子，请求可以在插件中发起，假如插件没有返回servicePromise或者没有请求，runAsync会自己执行server，请求完成以后设置state，调用options.onSuccess，插件的onSuccess钩子，options.onFinally。</p><p>请求后与请求中思路类似，就不重复了。回过头来看那个count发现除了runAsync，cancel也访问了count，从这里大概能猜到，runAsync中之所以有那么多currentCount与count的比对，目的就是检测请求有没有被取消（并不会真正的取消那条请求）</p><p>剩下的refresh、refreshAsync与mutate，前两个就不说了，来看<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155">mutate</a> 的实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">targetData</span>: <span class="title class_">TData</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  targetData = <span class="title function_">data</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  targetData = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">runPluginHandler</span>(<span class="string">&#x27;onMutate&#x27;</span>, targetData);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: targetData,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码很清晰，所做的事就是不调用server直接setState(data)，顺便调用插件的onMutate钩子，从代码来看，data还可以是个函数。</p><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h3 id="useLatest"><a href="#useLatest" class="headerlink" title="useLatest"></a>useLatest</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts">useLatest</a><br>简简单单几行代码，道不出这个hooks的真谛，我们来看官方<a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-latest">例子</a> 。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> latestCountRef = <span class="title function_">useLatest</span>(count);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(latestCountRef.<span class="property">current</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把useLatest去掉</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以自己用codesanbox运行运行一下这段代码，会发现jsx中count的值永远都是1。为什么会这样呢？这是因为每次setInterval在触发回调时，这个回调函数的地址都是一样的，也就是说每次调用的回调函数都是同一个，一旦函数唯一，该函数在创建时拥有的闭包就唯一，而count在每次rerender时都会重新生成，所以储存在setInterval函数闭包里的count永远都是第一次的count。</p><p>稍微改一点代码，验证一下这个过程。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">  <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>每次输出的func.time都是同一个值，count也是同一个值。这就验证了上述函数唯一，闭包唯一的结论。</p><p>那怎么才能让代码正常运行呢？有两种解决方案：</p><ol><li>函数不唯一。</li><li>函数唯一，但是闭包里的count是不可变的。</li></ol><p>第一种方案：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">      <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">      <span class="title function_">func</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unbind&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br></pre></td></tr></table></figure><p>看起来挺好的，只需要改变一些useEffect的依赖，但是从log可以看出，会不停的输出unbind，所以这种方式是通过不停的unbind&#x2F;bind的方式来实现函数的不唯一，这就不好了。</p><p>第二种方案：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> latesCount = <span class="title function_">useRef</span>(count)</span><br><span class="line">  latesCount.<span class="property">current</span> = count</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">      <span class="title function_">setCount</span>(latesCount.<span class="property">current</span>+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">      <span class="title function_">func</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unbind&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从log可以看出func唯一，func中的count也唯一，但是jsx中的count会持续的增加。这是因为setCount的第一个参数不再是func闭包中不变的count，而是latesCount.current。</p><h3 id="useMemoizedFn"><a href="#useMemoizedFn" class="headerlink" title="useMemoizedFn"></a>useMemoizedFn</h3><p><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn">官方例子</a></p><p>为什么存在这个hook，useCallback又有什么缺点。为什么要保证函数的地址永远不变，举个例子来看一看这个问题。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次点击add count button，Child组件都会rerender，万一Child组件很大，或者嵌套层次很深呢，这无疑带来了巨大的性能问题。</p><p>用React.memo包一下会好一点。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样点击add count button，Child组件就不渲染了。但是React.momo在props变化时还是会rerender，代码改成这样。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">func</span>=<span class="string">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以发现点击add count button，Child组件竟然重新渲染了，由此可见，每次setCount，onClickHandler都会指向一个新的函数地址。怎么规避呢，来看一看useMemoizedFn的实现。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts">useMemoizedFn</a></p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useMemoizedFn&lt;T <span class="keyword">extends</span> noop&gt;(<span class="attr">fn</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`useMemoizedFn expected parameter is a function, got <span class="subst">$&#123;<span class="keyword">typeof</span> fn&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fnRef = useRef&lt;T&gt;(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// why not write `fnRef.current = fn`?</span></span><br><span class="line">  <span class="comment">// https://github.com/alibaba/hooks/issues/728</span></span><br><span class="line">  fnRef.<span class="property">current</span> = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> fn, [fn]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> memoizedFn = useRef&lt;T&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!memoizedFn.<span class="property">current</span>) &#123;</span><br><span class="line">    memoizedFn.<span class="property">current</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line @typescript-eslint/no-invalid-this</span></span><br><span class="line">      <span class="keyword">return</span> fnRef.<span class="property">current</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">as</span> T;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> memoizedFn.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useMemoizedFn本质上是个高阶函数。有两个useRef，一个存储变化的fn，一个存储永远不变的memoizedFn，调用useMemoizedFn时真正调用的是memoizedFn，然后在memoizedFn内部调用最新的fn。高阶函数的思路。</p><p>PS: 这里有个想法，useCallback为啥会有这么多的问题，是不是我们用错了呢？react hooks的设计初衷是使函数式组件拥有状态，那我们要是能保证被useCallback缓存的函数都是纯函数，是不是就不存在闭包问题。假如上面的例子写成这样：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">count</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">          onClickHandler(count)</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;&gt;add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">func</span>=<span class="string">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样写是不是也不存在闭包问题。</p><p>2022.08.02更新，上面的写法还是有问题，虽然解决了函数的引用问题，但却大大增加了心智负担，假如某个方法有好几个依赖，并且有好几处调用，每次调用都要传大一堆“看似无用“的参数，这样就不如在定义函数时“标明”依赖方便。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">a,b,c,d,e</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="title function_">foo</span>(a,b,c,d,e)</span><br><span class="line"><span class="comment">//这样每次调用foo，都必须传a、b、c、d、e。这样倒不如定义foo时只写一遍依赖方便，但这样又会带来函数地址问题，所以还是需要useMemoizedFn，或者关注一下react新的hooks，useEvent</span></span><br></pre></td></tr></table></figure><h3 id="useCreation"><a href="#useCreation" class="headerlink" title="useCreation"></a>useCreation</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts">useCreation</a><br><a href="https://ahooks.js.org/zh-CN/hooks/use-creation">文档</a></p><p>正如官方文档说的那样，useRef并不能保证参数绝对不变，所以需要useCreation，我们来看是怎么实现的。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> useCreation&lt;T&gt;(<span class="attr">factory</span>: <span class="function">() =&gt;</span> T, <span class="attr">deps</span>: <span class="title class_">DependencyList</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; current &#125; = <span class="title function_">useRef</span>(&#123;</span><br><span class="line">    deps,</span><br><span class="line">    <span class="attr">obj</span>: <span class="literal">undefined</span> <span class="keyword">as</span> <span class="literal">undefined</span> | T,</span><br><span class="line">    <span class="attr">initialized</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="property">initialized</span> === <span class="literal">false</span> || !<span class="title function_">depsAreSame</span>(current.<span class="property">deps</span>, deps)) &#123;</span><br><span class="line">    current.<span class="property">deps</span> = deps;</span><br><span class="line">    current.<span class="property">obj</span> = <span class="title function_">factory</span>();</span><br><span class="line">    current.<span class="property">initialized</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.<span class="property">obj</span> <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数不再是实例本身，而是返回实例的工厂函数，第二个参数是依赖，类型和内置hook类型一样。用一个useRef来保存实例相关的一些参数，只有当initialized为false或者deps发生变化时，才重新执行工厂函数，最后返回实例，如果该实例没有依赖，那么该实例就会唯一。</p><h3 id="useUpdate"><a href="#useUpdate" class="headerlink" title="useUpdate"></a>useUpdate</h3><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useUpdate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [, setState] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setState</span>(&#123;&#125;), []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUpdate;</span><br></pre></td></tr></table></figure><p>我们都知道，调用useState的setState会使组件树重新渲染，利用这一点可以达到强制刷新的目的。</p><h3 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h3><h3 id="useUnmount"><a href="#useUnmount" class="headerlink" title="useUnmount"></a>useUnmount</h3><p>useMount与useUnmount。这俩算是最没存在感的hook，内部实现原理都是useEffect。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h2><h3 id="useDebouncePlugin"><a href="#useDebouncePlugin" class="headerlink" title="useDebouncePlugin"></a>useDebouncePlugin</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/plugins/useDebouncePlugin.ts">useDebouncePlugin</a><br>大致看一下代码，发现核心实现是调了lodash的debounce方法，那为什么不直接用lodash，究其原因，还要从debounce的原理说起。</p><p><a href="https://github.com/lodash/lodash/blob/master/debounce.js">debounce</a><br>这东西真反直觉，debounce本质上是个高阶函数，你传一个func函数，它给你返回一个debounced函数，至于剩下的那些lastArgs、lastThis…变量，全存在debounced函数的闭包中，所以保持debounced的唯一（闭包唯一）是重中之重。看一个非react的例子。</p><p><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">vue debounce</a><br>created时在this上放了一个debouncedGetAnswer函数，就是为了保持debounced的闭包唯一。</p><p>所以不论是这里的useDebouncePlugin还是单独的useDebounceFn，所做的事都是让debounced函数在组件多次渲染中保持唯一。</p><h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>PS: 最近业务比较忙，再加上ahooks代码不停在变动。先合到master，等过段时间再看。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习react-whether</title>
      <link href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/"/>
      <url>/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在用react写业务时，常常要处理一些条件逻辑，由于jsx里面只有写表达式，不能写语句，所以有时不得不写一大坨这样的代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么像这样把大片逻辑封装成组件，要么写个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &#123;<span class="variable language_">this</span>.<span class="title function_">renderComponent</span>()&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">renderComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不完美，有时候并不想凭空写一个方法或者封装组件，并且代码可读性也不好。</p><p>那么有没有更优雅的方法，当然有，所谓前人栽树，后人乘凉，我们只要虚心学习就可以了。</p><p><a href="https://github.com/otakustay/react-whether">react-whether</a> ,看文档可以去这里，本文介绍的是其源码。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>首先打开src&#x2F;index.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Whether</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Whether&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Match</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Match&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Else</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Else&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从文档可以看出<a href="https://github.com/otakustay/react-whether/blob/master/src/Whether.tsx">Whether</a> 是其root component。</p><p>从代码可以看出Whether本质上是一个函数式组件，除了children，接收matches和context两个prop。</p><p>代码开篇判断matches是不是一个boolean，本质上是在判断有没有传matches，如果matches是个boolean，走的是IfElseMode或者IfMode，否则走的是SwitchMode。</p><p>通过计算Whether的children的数量count，来判断是IfElseMode或者IfMode，如果count &lt;&#x3D; 1,走的是IfMode，如果count &gt; 1 并且chidren的最后一项是else，走的是IfElseMode，否则走的是IfMode。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/IfMode.tsx">IfMode</a><br><a href="https://github.com/otakustay/react-whether/blob/master/src/IfElseMode.tsx">IfElseMode</a></p><p>这俩货代码很相似，内部都调用了Render组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Render</span>&gt;&#123;matches ? children : <span class="literal">null</span>&#125;&lt;<span class="regexp">/Render&gt; /</span><span class="regexp">/IfMode</span></span><br><span class="line"><span class="regexp">&lt;Render&gt;&#123;matches ? ifChildren : elseChildren&#125;&lt;/</span><span class="title class_">Render</span>&gt; <span class="comment">//IfElseMode</span></span><br></pre></td></tr></table></figure><p>这是只传matches的情况，接下来看只传context的情况，也就是switchMode</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> matches !== <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> elements = <span class="title class_">Children</span>.<span class="title function_">toArray</span>(children) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt;;</span><br><span class="line">        <span class="keyword">const</span> branches = elements.<span class="title function_">map</span>(elementToBranch);</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SwitchMode</span> <span class="attr">context</span>=<span class="string">&#123;context&#125;</span> <span class="attr">branches</span>=<span class="string">&#123;branches&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementToBranch = (&#123;<span class="keyword">type</span>, props&#125;: <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;): <span class="title class_">MatchProp</span> | <span class="function"><span class="params">BranchPropWithSelector</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Match</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">selector</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">children</span>: props.<span class="property">children</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>elementToBranch 的作用是整合props与children，生成统一的branches，因为children可能是Match，也可能不是。最后调用SwitchMode组件。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/SwitchMode.tsx">SwitchMode</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SwitchMode</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">SwitchModeProp</span>&gt; = <span class="function">(<span class="params">&#123;context, branches&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> branch = branches.<span class="title function_">find</span>(<span class="function">(<span class="params">&#123;selector&#125;</span>) =&gt;</span> <span class="title function_">selector</span>(context));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Render</span>&gt;</span>&#123;branch ? branch.children : null&#125;<span class="tag">&lt;/<span class="name">Render</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码与ifMode很相似，唯一的区别是多了个branch，这里用find方法很巧妙。假如我代码这么写。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [user,changeUser] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Whether</span> <span class="attr">context</span>=<span class="string">&#123;user&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;foo&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;bar&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                else</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Whether</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照elementToBranch的逻辑，假如children的某一项不是Match，会生成返回true的selector函数，但是数组的find方法永远只返回第一个符合条件的值。所以最后一项是不是Else组件根本不重要，写成div也可以，关键是顺序。</p><p>最后看一下三个mode都用到的Render组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Render</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">RenderProp</span>&gt; = (&#123;children&#125;): <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;isRenderFunc(children) ? children() : children&#125;<span class="tag">&lt;/&gt;</span></span>; <span class="comment">//懒加载的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习recycler-view</title>
      <link href="/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/"/>
      <url>/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p><p><a href="https://github.com/hdcoo/recycler-view">https://github.com/hdcoo/recycler-view</a></p><h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>先去<a href="https://github.com/hdcoo/recycler-view-demo">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a href="http://localhost:5211/recycler-view-demo/%EF%BC%8C">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p><p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p><iframe src="https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>可是这个库的布局是这样的</p><iframe src="https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p><p>回到官方的两列瀑布流例子</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy"></p><p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png" alt="d8fd84a1-1504-4020-93f7-a550314c1459-image.png"></p><p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p><h1 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p><p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p><h2 id="单行代码分析"><a href="#单行代码分析" class="headerlink" title="单行代码分析"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">getWaterfallRecycler</span>(<span class="params">scroller, container</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Recycler</span>(scroller, <span class="keyword">new</span> <span class="title class_">WaterfallSource</span>(), &#123;</span><br><span class="line">    container,</span><br><span class="line">    <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">NumberRenderer</span>()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p><p>接下来看Recycler的具体实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p><p>我基于作者的注释给与补充</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class="built_in">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化统一 scroller 操作接口</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span> = <span class="keyword">new</span> <span class="title class_">ScrollerOperations</span>(scroller);</span><br><span class="line">        <span class="comment">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">isScrollerValid</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Exceptions</span>.<span class="title class_">TypeError</span>(<span class="string">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroller</span> = scroller;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">        <span class="comment">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认渲染器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">renderer</span> = options.<span class="property">renderer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容纳元素的容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">container</span> = options.<span class="property">container</span> || <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getElement</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶部和底部预留空间</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">topPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">topPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bottomPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">bottomPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动正反方向预渲染元素个数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItems</span> = options.<span class="property">runwayItems</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItemsOpposite</span> = options.<span class="property">runwayItemsOpposite</span> || <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离底部多少个元素时触发加载更多</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">threshold</span> = options.<span class="property">threshold</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br><span class="line">        <span class="comment">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class="line">        <span class="comment">// 稍后会介绍runway</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 Dom 事件监听器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span> = <span class="keyword">new</span> <span class="title class_">ScrollListener</span>(<span class="variable language_">this</span>.<span class="property">scroller</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resizeListener</span> = <span class="keyword">new</span> <span class="title class_">ResizeListener</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撑开滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">sentinel</span>);</span><br><span class="line">        <span class="comment">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据是否启用硬件加速选择模板</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">enableAcceleration</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 container position style</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">container</span>).<span class="property">position</span> === <span class="string">&#x27;static&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哨兵位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">        <span class="comment">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onScroll</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">handleWindowResize</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">resizeListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onResize</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class="line">        <span class="title function_">mapObject</span>(<span class="variable language_">this</span>.<span class="property">runways</span>, <span class="function">(<span class="params">runway</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">execute</span>(<span class="function">() =&gt;</span> runway.<span class="property">source</span>.<span class="title function_">mount</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 可以跳过这一句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 onInitialized</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Initialized</span>, <span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说明constructor中几个重要的步骤。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br></pre></td></tr></table></figure><p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> getInitialRunway&lt;U&gt;(<span class="attr">source</span>: <span class="title class_">ISource</span>&lt;U&gt;): <span class="title class_">IRunway</span>&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstAttachedItem</span>: <span class="number">0</span>, </span><br><span class="line">      <span class="attr">lastAttachedItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">lastScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">requestInProgress</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">runwayMaxScrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">nodes</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">screenNodes</span>: <span class="title function_">newSet</span>(),</span><br><span class="line">      source,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p><p>scrollTop：scroller的scrollTop</p><p>requestInProgress：是否正在请求数据，</p><p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p><p>screenNodes：nodes的缓存</p><p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p><p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p><p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">update</span>(<span class="params">disableRender?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">runwayMaxScrollTop</span> = <span class="variable language_">this</span>.<span class="title function_">getRunwayMaxScrollTop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Update</span>, <span class="variable language_">this</span>, disableRender);</span><br><span class="line">    !disableRender &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">onScroll</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285">onScroll</a></p><p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332">fill</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fixedStart = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, start);</span><br><span class="line"><span class="keyword">const</span> fixedEnd = <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>, end);</span><br></pre></td></tr></table></figure><p>这两句很疑惑，为什么要重新计算start和end呢</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png" alt="d23cee97-7080-4a8f-89b0-24e87b67e522-image.png"></p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh"></p><p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p><p>算出正确的start、end后调用了attachContent。</p><p>attachContent分两步：</p><ol><li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">release</span>(<span class="attr">el</span>: <span class="title class_">HTMLElement</span>, <span class="attr">recycler</span>: <span class="title class_">IRecycler</span>&lt;T&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">using</span>.<span class="title function_">delete</span>(el);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">unused</span>.<span class="title function_">push</span>(el);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用release方法时缓存了废弃的元素。</p><ol start="2"><li>渲染当前滚动屏幕内的元素。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">attachContent</span>(<span class="params">start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> benchNodes = []; <span class="comment">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">changedNodes</span>: <span class="title class_">IChangedNodes</span> = []; <span class="comment">// 有变化的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点是释放在屏幕外的元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeUnusedNodes</span>(start, end, <span class="variable language_">this</span>.<span class="property">isForceUpdate</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isForceUpdate</span> &amp;&amp; runway.<span class="property">nodes</span>[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> renderer = <span class="variable language_">this</span>.<span class="title function_">getRenderer</span>(i);</span><br><span class="line">      <span class="keyword">const</span> data = runway.<span class="property">source</span>.<span class="title function_">getData</span>(i, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用渲染函数，获得一个节点</span></span><br><span class="line">      <span class="comment">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class="line">      <span class="comment">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class="line">      <span class="keyword">const</span> node = runway.<span class="property">nodes</span>[i] = renderer.<span class="title function_">render</span>(data, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向缓存中存入一个节点，用于移除</span></span><br><span class="line">      runway.<span class="property">screenNodes</span>.<span class="title function_">add</span>(node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class="line">      changedNodes.<span class="title function_">push</span>(&#123;node, <span class="attr">index</span>: i&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">parentNode</span> !== <span class="variable language_">this</span>.<span class="property">container</span>) &#123;</span><br><span class="line">        benchNodes.<span class="title function_">push</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量修改节点样式</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setNodesStyles</span>(changedNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量加入元素到容器中</span></span><br><span class="line">    <span class="keyword">while</span> (benchNodes.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">appendChild</span>(benchNodes.<span class="title function_">pop</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许可以加载更多</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">maybeLoadMore</span>(end);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p><p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p><p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p><h1 id="简短的流程"><a href="#简短的流程" class="headerlink" title="简短的流程"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p><p>把attachContent单拎出来。</p><p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p><p>再过滤一遍，核心实现就三步：</p><ol><li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li><li>依据start、end释放屏幕外的元素</li><li>依据start、end更新屏幕内的元素</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getFirstScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt;= scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚动相反</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class="line">        <span class="comment">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class="line">        <span class="comment">// 故加 1</span></span><br><span class="line">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getLastScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果是往上滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) &gt;= scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚相反</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 故减 1</span></span><br><span class="line">      i &gt; <span class="number">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">freeUnusedNodes</span>(<span class="params">start: <span class="built_in">number</span>, end?: <span class="built_in">number</span>, force?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">if</span> (force || start &gt; runway.<span class="property">lastAttachedItem</span> || end &lt; runway.<span class="property">firstAttachedItem</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>), runway.<span class="property">lastAttachedItem</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能处理某种边界情况</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, start);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromEnd</span>(end, runway.<span class="property">lastAttachedItem</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p><p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p><p>所以就库本身来说，性能还是挺高的。</p><p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
