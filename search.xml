<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>发现@babel/plugin-transform-react-jsx一个问题</title>
      <link href="/2023/12/12/%E5%8F%91%E7%8E%B0-babel-plugin-transform-react-jsx%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/12/%E5%8F%91%E7%8E%B0-babel-plugin-transform-react-jsx%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>前几天为fre这个库搭建启动环境时遇到一些问题，首先看我的webpack 配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.jsx&#x27;</span>,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(?:js|mjs|cjs|jsx|ts|tsx)$/</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="attr">use</span>: &#123;</span><br><span class="line">                    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                    <span class="attr">options</span>: &#123;</span><br><span class="line">                        <span class="attr">presets</span>: [</span><br><span class="line">                            [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">targets</span>: <span class="string">&quot;defaults&quot;</span> &#125;]</span><br><span class="line">                        ],</span><br><span class="line">                        <span class="attr">plugins</span>: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">&#x27;@babel/plugin-transform-typescript&#x27;</span> <span class="comment">//用这个插件来解析ts</span></span><br><span class="line">                            ],</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">&#x27;@babel/plugin-transform-react-jsx&#x27;</span>, <span class="comment">//用这个插件来解析fre的jsx</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">runtime</span>: <span class="string">&#x27;automatic&#x27;</span>,</span><br><span class="line">                                    <span class="attr">importSource</span>: <span class="string">&#x27;fre&#x27;</span>,</span><br><span class="line">                                &#125;,</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">modules</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>,<span class="string">&#x27;lib&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>],</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">        <span class="attr">static</span>: &#123;</span><br><span class="line">            <span class="attr">directory</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">template</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./index.html&#x27;</span>)</span><br><span class="line">    &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来没什么问题，但是运行时却报错了<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d0f0b072-eb1f-42ed-b4db-8d9a2768fe35-image.png" alt="d0f0b072-eb1f-42ed-b4db-8d9a2768fe35-image.png"></p><p>从错误的堆栈信息来看，是babel-parser报的错。很明显，这个错误跟正则表达式没什么关系，但是为什么babel-parser会把这段代码看成正则表达式呢，babel-parser的作用是把javascript解析成抽象语法树，常见的js语法肯定都支持，但是jsx不是标准的js语法，看babel-parser的文档，它支持一个plugins选项，比如你可以用以下代码来开启解析jsx与flow。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>).<span class="title function_">parse</span>(<span class="string">&quot;code&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// parse in strict mode and allow module declarations</span></span><br><span class="line">  <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// enable jsx and flow syntax</span></span><br><span class="line">    <span class="string">&quot;jsx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;flow&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是我们毕竟不是直接用的babel-parser，肯定是babel-loader到babel-parser的调用过程中哪一步出错了。带着这个问题，我们来大概扒一扒babel-loader的代码。</p><p><a href="https://github.com/babel/babel-loader/blob/v9.1.3/src/transform.js#L10">transform.js#L10</a> 这里的transform来自babel-core，最终来自这里的<a href="https://github.com/babel/babel/blob/v7.23.6/packages/babel-core/src/transformation/index.ts#L34">run</a>,这个方法有几部分非常关键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过babel-parser把code转换成ast</span></span><br><span class="line"><span class="keyword">const</span> file = <span class="keyword">yield</span>* <span class="title function_">normalizeFile</span>(</span><br><span class="line">    config.<span class="property">passes</span>,</span><br><span class="line">    <span class="title function_">normalizeOptions</span>(config),</span><br><span class="line">    code,</span><br><span class="line">    ast,</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过babel-traverse结合各个plugin对ast进行增删改</span></span><br><span class="line"> <span class="keyword">yield</span>* <span class="title function_">transformFile</span>(file, config.<span class="property">passes</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把更改后的ast通过babel-generator还原成code</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (opts.<span class="property">code</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">        (&#123; outputCode, outputMap &#125; = <span class="title function_">generateCode</span>(config.<span class="property">passes</span>, file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    e.<span class="property">message</span> = <span class="string">`<span class="subst">$&#123;opts.filename ?? <span class="string">&quot;unknown file&quot;</span>&#125;</span>: <span class="subst">$&#123;e.message&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">if</span> (!e.<span class="property">code</span>) &#123;</span><br><span class="line">        e.<span class="property">code</span> = <span class="string">&quot;BABEL_GENERATE_ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的问题是babel-parser不识别jsx语法，也就是normalizeFile方法部分。</p><p><a href="https://github.com/babel/babel/blob/v7.23.6/packages/babel-core/src/transformation/normalize-file.ts#L50">normalize-file.ts#L50</a> 这个parser是通过babel-core&#x2F;src&#x2F;parser&#x2F;index.ts导出的，最终调用了babel-parser导出的parse方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">parse</span>(code, parserOpts);</span><br></pre></td></tr></table></figure><p>是不是和babel-parser文档上的例子很像，所以只要找到这个parserOpts从哪里来的以及包含哪些内容就能解决这个问题。<br>回到<a href="https://github.com/babel/babel/blob/v7.23.6/packages/babel-core/src/transformation/index.ts#L39">run方法</a>，第二个参数normalizeOptions(config)就是parserOpts的来源。</p><p><a href="https://github.com/babel/babel/blob/v7.23.6/packages/babel-core/src/transformation/normalize-opts.ts#L62">normalize-opts.ts#L62</a><br>这里依次判断每个插件上是否有manipulateOptions方法，如果有调用并传入parserOpts。</p><p>我们webpack配置中的@babel&#x2F;plugin-transform-typescript与@babel&#x2F;plugin-transform-react-jsx都有这个方法，先看@babel&#x2F;plugin-transform-typescript，这个插件继承自@babel&#x2F;plugin-syntax-typescript，里面有一句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/babel/babel/blob/v7.23.6/packages/babel-plugin-syntax-typescript/src/index.ts#L59</span></span><br><span class="line"><span class="title function_">manipulateOptions</span>(<span class="params">opts, parserOpts</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!process.<span class="property">env</span>.<span class="property">BABEL_8_BREAKING</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;plugins&#125; = parserOpts;</span><br><span class="line">        <span class="comment">// If the Flow syntax plugin already ran, remove it since Typescript</span></span><br><span class="line">        <span class="comment">// takes priority.</span></span><br><span class="line">        <span class="title function_">removePlugin</span>(plugins, <span class="string">&quot;flow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the JSX syntax plugin already ran, remove it because JSX handling</span></span><br><span class="line">        <span class="comment">// in TS depends on the extensions, and is purely dependent on &#x27;isTSX&#x27;.</span></span><br><span class="line">        <span class="title function_">removePlugin</span>(plugins, <span class="string">&quot;jsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// These are now enabled by default in @babel/parser, but we push</span></span><br><span class="line">        <span class="comment">// them for compat with older versions.</span></span><br><span class="line">        plugins.<span class="title function_">push</span>(<span class="string">&quot;objectRestSpread&quot;</span>, <span class="string">&quot;classProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isTSX) &#123;</span><br><span class="line">            plugins.<span class="title function_">push</span>(<span class="string">&quot;jsx&quot;</span>);</span><br><span class="line">        &#125; <span class="comment">// 这里，如果传递给这个插件的参数里有isTSX，将开启babel-parser的jsx plugin</span></span><br><span class="line">    &#125;</span><br><span class="line">    parserOpts.<span class="property">plugins</span>.<span class="title function_">push</span>([</span><br><span class="line">        <span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">        &#123;disallowAmbiguousJSXLike, dts&#125;,</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看@babel&#x2F;plugin-transform-react-jsx，继承自@babel&#x2F;plugin-syntax-jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://github.com/babel/babel/blob/v7.23.6/packages/babel-plugin-syntax-jsx/src/index.ts</span></span><br><span class="line"><span class="title function_">manipulateOptions</span>(<span class="params">opts, parserOpts</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!process.<span class="property">env</span>.<span class="property">BABEL_8_BREAKING</span>) &#123;</span><br><span class="line">        <span class="comment">// If the Typescript plugin already ran, it will have decided whether</span></span><br><span class="line">        <span class="comment">// or not this is a TSX file.</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            parserOpts.<span class="property">plugins</span>.<span class="title function_">some</span>(</span><br><span class="line">                <span class="function"><span class="params">p</span> =&gt;</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(p) ? p[<span class="number">0</span>] : p) === <span class="string">&quot;typescript&quot;</span>,</span><br><span class="line">            ) <span class="comment">// 这里错了，不能单纯的说我用了@babel/plugin-transform-typescript，就return掉，应该判断是否开启了jsx plugin</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parserOpts.<span class="property">plugins</span>.<span class="title function_">push</span>(<span class="string">&quot;jsx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，应该改成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parserOpts.<span class="property">plugins</span>.<span class="title function_">some</span>(<span class="function"><span class="params">p</span> =&gt;</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(p) ? p[<span class="number">0</span>] : p) === <span class="string">&quot;typescript&quot;</span>) &amp;&amp; parserOpts.<span class="property">plugins</span>.<span class="title function_">includes</span>(<span class="string">&#x27;jsx&#x27;</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何给langchainjs添加代理</title>
      <link href="/2023/12/12/%E5%A6%82%E4%BD%95%E7%BB%99langchainjs%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/"/>
      <url>/2023/12/12/%E5%A6%82%E4%BD%95%E7%BB%99langchainjs%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>langchain这个框架是个好东西，本以为又是python的天下，没想到竟然有js版本，不过openai毕竟是国外的嘛，能否配置代理对我们这些渴望高质量服务的国人来说至关重要。</p><p>你要是用clash，这个软件有个虚拟网卡模式，开启后，电脑上的所有流量都会走这个虚拟网卡，但是毕竟是国人，老是开虚拟网卡有点不方便。</p><p>langchainjs更新很快，老版本可以用以下的方式配置proxy。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> llm = <span class="keyword">new</span> <span class="title class_">OpenAI</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">openAIApiKey</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="comment">// modelName: &#x27;gpt-3.5-turbo&#x27;,</span></span><br><span class="line">      <span class="attr">modelName</span>: <span class="string">&#x27;text-davinci-003&#x27;</span>,</span><br><span class="line">      <span class="comment">// modelName: &#x27;code-davinci-002&#x27;,</span></span><br><span class="line">      <span class="comment">// modelName: &#x27;code-davinci-001&#x27;,</span></span><br><span class="line">      <span class="comment">// modelName: &#x27;gpt-4&#x27;,</span></span><br><span class="line">      <span class="attr">temperature</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">verbose</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">baseOptions</span>: &#123;</span><br><span class="line">        <span class="attr">proxy</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">httpAgent</span>: <span class="keyword">new</span> <span class="title class_">HttpsProxyAgent</span>(<span class="string">&#x27;http://a:30010&#x27;</span>),</span><br><span class="line">        <span class="attr">httpsAgent</span>: <span class="keyword">new</span> <span class="title class_">HttpsProxyAgent</span>(<span class="string">&#x27;http://a:30010&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这种方式已经失效了（0.0.198），新版本推荐以下的方式配置代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> model = <span class="keyword">new</span> <span class="title class_">ChatOpenAI</span>(&#123;</span><br><span class="line">    <span class="attr">temperature</span>: <span class="number">0</span>, <span class="comment">// increase temperature to get more creative answers</span></span><br><span class="line">    <span class="attr">modelName</span>: <span class="string">&#x27;gpt-3.5-turbo&#x27;</span>,</span><br><span class="line">    <span class="attr">openAIApiKey</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">//change this to gpt-4 if you have access</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="attr">httpAgent</span>: <span class="keyword">new</span> <span class="title class_">HttpsProxyAgent</span>(proxy)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过就我用的node18.16.0来说，以上方式并不生效，为此，我大概翻了一下langchain的代码，并且找到了原因。</p><p><a href="https://github.com/langchain-ai/langchainjs/blob/0.0.198/libs/langchain-openai/src/embeddings.ts#L258">embeddings.ts L258</a>。以我用的embedding api为例子，看一下langchian内部是如何发起网络请求的，await this.client.embeddings.create这一句，这里的this.client是怎么来的，243行，this.client &#x3D; new OpenAIClient(params)，这里的OpenAIClient是openai这个js库导出的，所以langchianjs内部实际上调了openai-node。</p><p><a href="https://github.com/openai/openai-node/blob/v4.20.1/src/core.ts#L480">openai-node L480</a> 这里的fetch来自this.getRequestClient()，487行，getRequestClient返回的fetch来自this.fetch，184行，this.fetch &#x3D; overridenFetch ?? fetch，这里的overridenFetch是个实例参数，一般不会传的，所以最终的fetch来自<a href="https://github.com/openai/openai-node/blob/v4.20.1/src/_shims/index.js">_shims<br>&#x2F;index.js</a> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Disclaimer: modules in _shims aren&#x27;t intended to be imported by SDK users.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> shims = <span class="built_in">require</span>(<span class="string">&#x27;./registry&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> auto = <span class="built_in">require</span>(<span class="string">&#x27;openai/_shims/auto/runtime&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!shims.<span class="property">kind</span>) shims.<span class="title function_">setShims</span>(auto.<span class="title function_">getRuntime</span>(), &#123; <span class="attr">auto</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> property <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(shims)) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, property, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> shims[property];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码其实不复杂，registry里面导出了一堆需要shims的方法或者属性，也包括fetch，这些东西最终会通过那个for循环+Object.defineProperty导出给外部使用，可以通过shims.setShims给这些方法或者属性打补丁。看看auto.getRuntime()的实现。</p><p><a href="https://github.com/openai/openai-node/blob/v4.20.1/src/_shims/web-runtime.ts#L20">web-runtime.ts L20</a> 20行这里的fetch赋值找不到定义，说明最终发起网络请求的fetch来自运行这段js的环境。</p><p>我们知道fetch这个api是浏览器上用来替代XMLHttpRequest的，node环境想用一直用node-fetch这个库，但是从node18开始也实现了原生的fetch，，所以这就是httpAgent不生效的原因，因为nodejs18内置的fetch根本不支持传递httpAgent参数。它通过以下的方式配置代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ProxyAgent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;undici&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dispatcher = <span class="keyword">new</span> <span class="title class_">ProxyAgent</span>(<span class="string">&#x27;https://proxy.com&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;google.com&#x27;</span>, &#123; </span><br><span class="line">         dispatcher,</span><br><span class="line">         <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">         <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">hi</span>: <span class="string">&quot;mom&quot;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显，这个dispatcher选项langchainjs没有给我们提供，那怎么办呢，我们可以通过刚才的overridenFetch覆盖掉默认的fetch检测，而这个参数langchainjs提供了。</p><p><a href="https://github.com/langchain-ai/langchainjs/blob/0.0.198/libs/langchain-openai/src/embeddings.ts#L243">embeddings.ts</a> 这里的configuration类型是ClientOptions，而ClientOptions来自openai-node，<a href="https://github.com/openai/openai-node/blob/v4.20.1/src/index.ts#L49">fetch option</a> 这里的fetch就是上面说的overridenFetch，可以给这个参数赋值node-fetch，然后httpAgent参数就起作用了。所以最终的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;node-fetch&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ChatOpenAI</span>(&#123;</span><br><span class="line">    <span class="attr">temperature</span>: <span class="number">0</span>, <span class="comment">// increase temperature to get more creative answers</span></span><br><span class="line">    <span class="attr">modelName</span>: <span class="string">&#x27;gpt-3.5-turbo&#x27;</span>,</span><br><span class="line">    <span class="attr">openAIApiKey</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">//change this to gpt-4 if you have access</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="attr">httpAgent</span>: <span class="keyword">new</span> <span class="title class_">HttpsProxyAgent</span>(proxy),</span><br><span class="line">    fetch</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用nextjs实现上传pdf</title>
      <link href="/2023/12/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nextjs%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0pdf/"/>
      <url>/2023/12/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8nextjs%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0pdf/</url>
      
        <content type="html"><![CDATA[<p>之前研究gpt4-pdf-chatbot-langchain这个项目，觉得挺有意思，竟然可以让chatgpt去读一本书，还是js写的。不过这项目有一点不方便，他需要用nodejs解析pdf，然后用openai提供的api把api向量化，接着在浏览器里才能基于这本书的内容向chatgpt提问。</p><p>然后我就想能不能把所有的操作入口都放在浏览器上，在浏览器上上传一个pdf，然后后端拿到上传的pdf，解析pdf，向量化，后面的操作和原项目一样。基于这样的想法，我写了以下的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pages/index.tsx</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onFileUplload</span> = e=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>?.[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">        formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file)</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/api/upload&#x27;</span>,&#123;</span><br><span class="line">            <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            <span class="attr">body</span>: formData,</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">resp</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(resp.<span class="property">status</span> !== <span class="number">200</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(resp.<span class="property">statusText</span>)</span><br><span class="line">            <span class="keyword">return</span> resp.<span class="title function_">json</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&#x27;dropzone-file2&#x27;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;onFileUplload&#125;</span> <span class="attr">accept</span>=<span class="string">&quot;.pdf&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pegae/api/upload.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    req: NextApiRequest,</span></span><br><span class="line"><span class="params">    res: NextApiResponse,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> buffer =  <span class="title class_">Buffer</span>.<span class="title function_">from</span>(req.<span class="property">body</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(buffer);</span><br><span class="line">    <span class="comment">// 处理buffer，解析pdf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">api</span>:&#123;</span><br><span class="line">        <span class="attr">bodyParser</span>: &#123;</span><br><span class="line">            <span class="attr">sizeLimit</span>: <span class="string">&#x27;10mb&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码后续在解析pdf的过程中报错了，说我的pdf是加密的，很明显不是这个原因。经过一番查找发现，发现用以上代码拿到的buffer与直接用nodejs读pdf拿到的buffer长度不一样。</p><p>buffer from browser upload<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/839ccc20-58c2-4830-94fb-f1ed9af5d960-buffer_from_upload.png" alt="839ccc20-58c2-4830-94fb-f1ed9af5d960-buffer_from_upload.png"></p><p>buffer from nodejs<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/5a5738e6-2085-4381-953b-173466716bd9-image.png" alt="5a5738e6-2085-4381-953b-173466716bd9-image.png"></p><p>显然，[buffer from browser upload]有问题，那这一步的buffer是从哪里来的，const buffer &#x3D;  Buffer.from(req.body)，把这里的req.body打印出来看看，发现是个乱码的字符串，很明显不对，后续再把这个错误的字符串转换成buffer，后面的一系列步骤都错了。</p><p>这个错误到底是怎么来的，怎么会拿到一个乱码的字符串呢？那就从源头查起， 我们知道浏览器上的http请求，不管请求体中是什么数据，最终都会转化为二进制，就是所谓的数字信号，然后数电转模电，单纯的数字信号是不能发射的，只能转换成模拟信号，就是我们说的波，发射出去。目标服务器在接收到这个波以后，需要把模拟信号转换成数字信号，就是二进制，然后才能处理这条http请求。数电模电之间的转换是不可能出错的，按照以上理论，我们在服务端拿到的这条请求应该是个二进制流才对，为什么会是乱码的字符串呢，所以，最大的可能就是nextjs处理了这个二进制流，但是没有处理好。所以我们需要拿到原始的二进制流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getBoundary, parse &#125; <span class="keyword">from</span> <span class="string">&#x27;parse-multipart-data&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span></span><br><span class="line"><span class="params">    req: NextApiRequest,</span></span><br><span class="line"><span class="params">    res: NextApiResponse,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">chunks</span>: <span class="title class_">Uint8Array</span>[] = []</span><br><span class="line">    <span class="keyword">let</span> size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> sizeLimit = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function">(<span class="params">chunk</span>)=&gt;</span>&#123;</span><br><span class="line">        size += chunk.<span class="property">length</span></span><br><span class="line">        <span class="keyword">if</span>(size &gt; sizeLimit)&#123;</span><br><span class="line">            res.<span class="title function_">status</span>(<span class="number">413</span>).<span class="title function_">send</span>(<span class="string">&#x27;payload too large&#x27;</span>)</span><br><span class="line">            req.<span class="property">connection</span>.<span class="title function_">destroy</span>()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        chunks.<span class="title function_">push</span>(chunk)</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> boundary = <span class="title function_">getBoundary</span>(req.<span class="property">rawHeaders</span>.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>))</span><br><span class="line">        <span class="keyword">const</span> completeBuffer = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks)</span><br><span class="line">        <span class="keyword">const</span> parts = <span class="title function_">parse</span>(completeBuffer, boundary)</span><br><span class="line">        <span class="keyword">const</span> [file] = parts</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;file.data&#x27;</span>,file.<span class="property">data</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">        res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">send</span>(<span class="string">&#x27;an error occurred&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">api</span>:&#123;</span><br><span class="line">        <span class="attr">bodyParser</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码一目了然，先禁掉nextjs内置的bodyParser，直接监听req的data与end事件，收集chunk，然后通过getBoundary与parse从formdata中解析出file，这里log出的file.data就是正确的数据，长度是1086938。</p><p>拿到正确的buffer以后就可以调用pdf-parser解析了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RN通过Android Intent打开媒体及播放!</title>
      <link href="/2023/11/21/RN%E9%80%9A%E8%BF%87Android%20Intent%E6%89%93%E5%BC%80%E5%AA%92%E4%BD%93%E5%8F%8A%E6%92%AD%E6%94%BE!/"/>
      <url>/2023/11/21/RN%E9%80%9A%E8%BF%87Android%20Intent%E6%89%93%E5%BC%80%E5%AA%92%E4%BD%93%E5%8F%8A%E6%92%AD%E6%94%BE!/</url>
      
        <content type="html"><![CDATA[<p>最近在阅读lx-music-mobile的代码，原作者代码写的很好，我在他的基础上增加了下载与本地音乐播放功能，原作者不实现肯定有他的考虑，我恰好有这个需求而已。</p><p>以上功能完成以后，我就想着能不能进一步直接在文件管理器中用lx.music打开某音乐，经过一番研究，发现在AndroidManifest.xml加上这些代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span>&gt;</span></span><br><span class="line">    //...</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.APP_MUSIC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;audio/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;application/ogg&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;application/x-ogg&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;application/itunes&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    //...</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在文件管理器里面打开某音乐时，lx.music就会出现在可选择列表里。这样点击lx.music仅仅会唤起app而已，后面还需要实现“响应这个操作并播放音乐文件”。</p><p>先说一下这个intent，以我的初步理解，这东西是android内部不同app之间进行通讯的，在文件管理器打开音乐文件时发送了一个intent，lx.music匹配到这个intent（参见intent-filter的规则）后，需要解析出intent里面的内容，由于播放器的逻辑是rn实现的，所以需要给rn发送一个事件，js那边通过DeviceEventEmitter监听这个事件拿到音乐文件真实的路径。</p><p>这里的顺序很重要，需要js先通过DeviceEventEmitter监听这个事件，然后android发送这个事件，js那边才能收到。</p><p>app冷启动时，首先启动MainActivity，依次执行onCreate onStart onResume这些生命周期，然后加载并执行js代码，执行完毕后，会初始化reactContext对象。在onCreate onStart onResume这些生命周期里是拿不到reactContext的，所以就需要这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReactInstanceManager</span> <span class="variable">reactInstanceManager</span> <span class="operator">=</span> ((MainApplication) getApplication()).getReactNativeHost().getReactInstanceManager();</span><br><span class="line">        reactInstanceManager.addReactInstanceEventListener(<span class="keyword">new</span> <span class="title class_">ReactInstanceManager</span>.ReactInstanceEventListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReactContextInitialized</span><span class="params">(ReactContext context)</span> &#123;</span><br><span class="line">            reactContext = context;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (reactInstanceManager.hasStartedCreatingInitialContext()) &#123;</span><br><span class="line">          reactContext = reactInstanceManager.getCurrentReactContext();</span><br><span class="line">          <span class="comment">// ReactContext已经创建完成，可以直接获取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reactContext不为null，说明js代码执行完毕，在android端执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)</span><br><span class="line">          .emit(<span class="string">&quot;onPathReceived&quot;</span>, event);</span><br></pre></td></tr></table></figure><p>在js端，通过以下代码接收这个消息:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventListener = <span class="title class_">DeviceEventEmitter</span>.<span class="title function_">addListener</span>(<span class="string">&#x27;onPathReceived&#x27;</span>, <span class="function"><span class="params">eventParams</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是，刚才说android会在js执行完毕后初始化reactContext对象，这里的“执行完毕”具体指的是什么，都执行了哪些代码。假如是在浏览器上，一个标准的react组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">app</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个组件是如何渲染到浏览器上的？首先会执行render函数，把虚拟dom转换成真实的dom挂载到浏览器上，dom只是浏览器内部的一种数据结构，真正把画面渲染出来是浏览器做的工作，浏览器渲染完毕，会执行useEffect的回调函数。</p><p>在react-native上，js的宿主环境不是浏览器，渲染工作是由原生完成的，由此可见，上面说的“执行完毕”仅仅执行了render函数，所以不能把DeviceEventEmitter.addListener放在useEffect里面，应该更提前，比如放在组件外面:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventListener = <span class="title class_">DeviceEventEmitter</span>.<span class="title function_">addListener</span>(<span class="string">&#x27;onPathReceived&#x27;</span>, <span class="function"><span class="params">eventParams</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">event</span>.<span class="title function_">emit</span>(<span class="string">&#x27;onPathReceived&#x27;</span>,eventParams.<span class="property">path</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">app</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">global</span>.<span class="property">event</span>.<span class="title function_">on</span>(<span class="string">&#x27;onPathReceived&#x27;</span>,<span class="function"><span class="params">path</span>=&gt;</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>a page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样又带来一个问题，当onPathReceived触发时，很可能涉及音乐播放的组件还没有渲染（比如有的组件是动态加载的），即使发射了onPathReceived事件，也没有任何响应，这里可以设置一个缓存，比如这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">  <span class="attr">cache</span>: <span class="title class_">Map</span>&lt;string, <span class="title class_">Array</span>&lt;any&gt;&gt;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName: string, listener: (...args: any[]) =&gt; any</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查缓存中是否有提前 emit 的事件</span></span><br><span class="line">    <span class="keyword">let</span> cachedEvents = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(eventName)</span><br><span class="line">    <span class="keyword">if</span> (cachedEvents) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> args <span class="keyword">of</span> cachedEvents) &#123;</span><br><span class="line">        <span class="title function_">listener</span>(...args)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(eventName)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName: string, ...args: any[]</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有监听器，将事件保存到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">has</span>(eventName)) &#123;</span><br><span class="line">      <span class="keyword">let</span> cachedEvents = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(eventName)</span><br><span class="line">      <span class="keyword">if</span> (!cachedEvents) <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(eventName, cachedEvents = [])</span><br><span class="line">      cachedEvents.<span class="title function_">push</span>(args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就ok了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>手写promise</title>
      <link href="/2023/06/21/%E6%89%8B%E5%86%99promise/"/>
      <url>/2023/06/21/%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<p>Promise这个构造函数与别的不一样，尽管平时使用时比较爽，但是站在函数设计者的角度来看就比较怪异。首先构造函数的参数是个函数（executor），这个函数的两个参数resolve与reject又是两个函数，且是在Promise构造函数内部定义的，调用executor时需要作为executor的参数。</p><p>Promise的then方法的参数又是两个函数（onFulfilled与onRejected），这两函数会在该promise实例resolve或者reject时分别调用，且then方法还可以链式调用与值穿透。看起来很像一堆函数在互相作用，但Promise的用法却是面向对象的方式，所以容易让人困惑。</p><p>先不考虑then方法的链式调用与值穿透，实现一个简易版的promise。</p><h1 id="一个普通的不支持链式调用的promise"><a href="#一个普通的不支持链式调用的promise" class="headerlink" title="一个普通的不支持链式调用的promise"></a>一个普通的不支持链式调用的promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyPromise</span>(<span class="params">executor</span>)&#123; <span class="comment">// 这个executor便是我们new Promise时传的函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span> <span class="comment">// promise实例resolve时的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span> <span class="comment">// promise实例reject时的原因</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;pending&#x27;</span> <span class="comment">// promise实例的状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = [] <span class="comment">//用来存储then方法的onFulfilled方法，因为then方法可以被链式调用，所以这个参数是个数组。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = [] <span class="comment">//用来存储then方法的onRejected方法，因为then方法可以被链式调用，所以这个参数是个数组。</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.<span class="property">status</span> = <span class="string">&#x27;resolve&#x27;</span>;</span><br><span class="line">            self.<span class="property">value</span> = value;</span><br><span class="line">            self.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">fn</span>) &#123; <span class="keyword">return</span> <span class="title function_">fn</span>(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// resolve方法的作用是改变promise的status与value，并依次执行onResolvedCallbacks里面的onFulfilled</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">            self.<span class="property">status</span> = <span class="string">&#x27;reject&#x27;</span>;</span><br><span class="line">            self.<span class="property">reason</span> = reason;</span><br><span class="line">            self.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">fn</span>) &#123; <span class="keyword">return</span> <span class="title function_">fn</span>(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject方法与resolve相反</span></span><br><span class="line">    <span class="title function_">executor</span>(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onFulfilled,onRejected</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;resolve&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">//如果已经resolve直接执行onFulfilled</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;reject&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>) <span class="comment">// 如果已经reject，直接执行onRejected</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>) &#123; <span class="comment">// 如果正在pending，暂存onFulfilled与onRejected，在resolve与reject函数被调用时再执行</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>( <span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>( <span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个例子来试一下我们的MyPromise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val, <span class="string">&#x27;done1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一切运行良好，但是这种实现不支持链式调用与promise值穿透，比如这样写就不行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">val</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val, <span class="string">&#x27;done1&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="支持链式调用的promise"><a href="#支持链式调用的promise" class="headerlink" title="支持链式调用的promise"></a>支持链式调用的promise</h1><p>其实promise链式调用的实现很简单，给then方法默认返回一个promise即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onFulfilled,onRejected</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123; <span class="comment">//then方法默认返回一个promise，这样就能链式调用了</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;resolve&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>) </span><br><span class="line">                <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>)&#123; <span class="comment">//如果onFulfilled或onRejected返回一个promise，则需要等这个promise resolve或者reject了then方法返回的promise才会resolve或reject，这边是promise的值穿透功能。下同。</span></span><br><span class="line">                    x.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;reject&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">                <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>)&#123;</span><br><span class="line">                    x.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                <span class="title function_">reject</span>(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;pending&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">                    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>)&#123;</span><br><span class="line">                        x.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(x)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">const</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">                    <span class="keyword">if</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>)&#123;</span><br><span class="line">                        x.<span class="title function_">then</span>(resolve,reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(x)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                    <span class="title function_">reject</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack常见loader工作原理</title>
      <link href="/2023/05/08/webpack%E5%B8%B8%E8%A7%81loader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/08/webpack%E5%B8%B8%E8%A7%81loader%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="file-loader与url-loader"><a href="#file-loader与url-loader" class="headerlink" title="file-loader与url-loader"></a>file-loader与url-loader</h1><p>这俩loader就是纸老虎，曾经老有面试问这俩loader的区别，每次都去记😂，其实只要看看他俩的源码就明白了。先来一个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;@babel/register&#x27;</span>)(&#123;</span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">        <span class="attr">rules</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src/loaders/file-loader/cjs.js&#x27;</span>)</span><br><span class="line">                        <span class="comment">// 这里我为了方便调试，copy了file-loader的源码</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//./src/index.js</span></span><br><span class="line"><span class="keyword">const</span> imgUrl = <span class="built_in">require</span>(<span class="string">&#x27;./images/test.png&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;imgUrl&#x27;</span>,imgUrl);</span><br></pre></td></tr></table></figure><p>还需要配置一下debug环境，我用的是webstorm，其他ide同理，能调试node就能调试webpack-loader。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/62a133e5-68a4-4075-9139-6fa14982d7fb-image.png" alt="62a133e5-68a4-4075-9139-6fa14982d7fb-image.png"></p><p>最后进入正文，在<a href="https://github.com/webpack-contrib/file-loader/blob/master/src/index.js#L10">loader函数</a> 这里打个断点，就可以看file-loader的执行过程了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>); <span class="comment">//这里拿到的options就是webpack配置文件file-loader那里传过来的options，我们这里为空</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(schema, options, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;File Loader&#x27;</span>,</span><br><span class="line">    <span class="attr">baseDataPath</span>: <span class="string">&#x27;options&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 验证options合法性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> context = options.<span class="property">context</span> || <span class="variable language_">this</span>.<span class="property">rootContext</span>; <span class="comment">//这不重要</span></span><br><span class="line">  <span class="keyword">const</span> name = options.<span class="property">name</span> || <span class="string">&#x27;[contenthash].[ext]&#x27;</span>; <span class="comment">//这是个模板字符串，后续会根据实际替换中括号里的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">interpolateName</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">    context,</span><br><span class="line">    content,</span><br><span class="line">    <span class="attr">regExp</span>: options.<span class="property">regExp</span>,</span><br><span class="line">  &#125;); <span class="comment">//interpolateName这个函数会根据资源的原始信息替换掉name里的模板，最后生成一个处理过的资源名称，类似c04dc325df0375584b.png</span></span><br><span class="line">    <span class="comment">// 这里知道作用就可以了，先略过</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> outputPath = url;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">outputPath</span>) &#123; <span class="comment">// 我们的options里面啥都没有，这句不会执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">outputPath</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      outputPath = options.<span class="title function_">outputPath</span>(url, <span class="variable language_">this</span>.<span class="property">resourcePath</span>, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputPath = path.<span class="property">posix</span>.<span class="title function_">join</span>(options.<span class="property">outputPath</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> publicPath = <span class="string">`__webpack_public_path__ + <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(outputPath)&#125;</span>`</span>;</span><br><span class="line">  <span class="comment">// 这个publicPath最后会被return，之所以在前面拼个__webpack_public_path__是因为__webpack_public_path__是webpack暴露的全局变量，代表publicPath</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">publicPath</span>) &#123; <span class="comment">//这句也不执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">publicPath</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      publicPath = options.<span class="title function_">publicPath</span>(url, <span class="variable language_">this</span>.<span class="property">resourcePath</span>, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      publicPath = <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">        options.publicPath.endsWith(<span class="string">&#x27;/&#x27;</span>)</span></span></span><br><span class="line"><span class="subst"><span class="string">          ? options.publicPath</span></span></span><br><span class="line"><span class="subst"><span class="string">          : <span class="string">`<span class="subst">$&#123;options.publicPath&#125;</span>/`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">      &#125;</span><span class="subst">$&#123;url&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicPath = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(publicPath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">postTransformPublicPath</span>) &#123; <span class="comment">//这句也不会执行</span></span><br><span class="line">    publicPath = options.<span class="title function_">postTransformPublicPath</span>(publicPath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">emitFile</span> === <span class="string">&#x27;undefined&#x27;</span> || options.<span class="property">emitFile</span>) &#123;<span class="comment">//这句执行了</span></span><br><span class="line">    <span class="keyword">const</span> assetInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> normalizedName = name;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> idx = normalizedName.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        normalizedName = normalizedName.<span class="title function_">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> isImmutable = <span class="regexp">/\[([^:\]]+:)?(hash|contenthash)(:[^\]]+)?]/gi</span>.<span class="title function_">test</span>(</span><br><span class="line">        normalizedName</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isImmutable === <span class="literal">true</span>) &#123;</span><br><span class="line">        assetInfo.<span class="property">immutable</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assetInfo.<span class="property">sourceFilename</span> = <span class="title function_">normalizePath</span>(</span><br><span class="line">      path.<span class="title function_">relative</span>(<span class="variable language_">this</span>.<span class="property">rootContext</span>, <span class="variable language_">this</span>.<span class="property">resourcePath</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 上面那一坨先不用看，关键是这个emitFie方法，文档在这里https://webpack.docschina.org/api/loaders/#thisemitfile</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emitFile</span>(outputPath, content, <span class="literal">null</span>, assetInfo);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//最后return了一个这样的结果 module.exports = __webpack_public_path__ + &quot;c04dc325df0375584b1fcd56895e3c6f.png&quot;</span></span><br><span class="line">  <span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.<span class="property">esModule</span> !== <span class="string">&#x27;undefined&#x27;</span> ? options.<span class="property">esModule</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;esModule ? <span class="string">&#x27;export default&#x27;</span> : <span class="string">&#x27;module.exports =&#x27;</span>&#125;</span> <span class="subst">$&#123;publicPath&#125;</span>;`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个例子的options是空，所以省略了很多代码，这是省略后的file-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">validate</span>(schema, options, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;File Loader&#x27;</span>,</span><br><span class="line">    <span class="attr">baseDataPath</span>: <span class="string">&#x27;options&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> context = options.<span class="property">context</span> || <span class="variable language_">this</span>.<span class="property">rootContext</span>;</span><br><span class="line"><span class="keyword">const</span> name = options.<span class="property">name</span> || <span class="string">&#x27;[contenthash].[ext]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="title function_">interpolateName</span>(<span class="variable language_">this</span>, name, &#123;</span><br><span class="line">    context,</span><br><span class="line">    content,</span><br><span class="line">    <span class="attr">regExp</span>: options.<span class="property">regExp</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> outputPath = url;</span><br><span class="line"><span class="keyword">let</span> publicPath = <span class="string">`__webpack_public_path__ + <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(outputPath)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">emitFile</span>(outputPath, content, <span class="literal">null</span>, assetInfo);</span><br><span class="line"><span class="keyword">const</span> esModule =</span><br><span class="line">    <span class="keyword">typeof</span> options.<span class="property">esModule</span> !== <span class="string">&#x27;undefined&#x27;</span> ? options.<span class="property">esModule</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;esModule ? <span class="string">&#x27;export default&#x27;</span> : <span class="string">&#x27;module.exports =&#x27;</span>&#125;</span> <span class="subst">$&#123;publicPath&#125;</span>;`</span>;</span><br></pre></td></tr></table></figure><p>这几行代码体现除了file-loader都干了些什么，其实关键点就两步，首先通过interpolateName编译name，然后通过this.emitFile把原始资源copy到dist，顺便把名字改成编译后的name，完了。</p><p>接下来看<a href="https://github.com/webpack-contrib/url-loader/blob/master/src/index.js">url-loader</a> 这个代码更简。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="comment">// Loader Options</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="title function_">getOptions</span>(<span class="variable language_">this</span>) || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">validate</span>(schema, options, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;URL Loader&#x27;</span>,</span><br><span class="line">    <span class="attr">baseDataPath</span>: <span class="string">&#x27;options&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No limit or within the specified limit</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">shouldTransform</span>(options.<span class="property">limit</span>, content.<span class="property">length</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; resourcePath &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> mimetype = <span class="title function_">getMimetype</span>(options.<span class="property">mimetype</span>, resourcePath);</span><br><span class="line">    <span class="keyword">const</span> encoding = <span class="title function_">getEncoding</span>(options.<span class="property">encoding</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> content === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-param-reassign</span></span><br><span class="line">      content = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> encodedData = <span class="title function_">getEncodedData</span>(</span><br><span class="line">      options.<span class="property">generator</span>,</span><br><span class="line">      mimetype,</span><br><span class="line">      encoding,</span><br><span class="line">      content,</span><br><span class="line">      resourcePath</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> esModule =</span><br><span class="line">      <span class="keyword">typeof</span> options.<span class="property">esModule</span> !== <span class="string">&#x27;undefined&#x27;</span> ? options.<span class="property">esModule</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">      esModule ? <span class="string">&#x27;export default&#x27;</span> : <span class="string">&#x27;module.exports =&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">    &#125;</span> <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(encodedData)&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Normalize the fallback.</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">loader</span>: fallbackLoader,</span><br><span class="line">    <span class="attr">options</span>: fallbackOptions,</span><br><span class="line">  &#125; = <span class="title function_">normalizeFallback</span>(options.<span class="property">fallback</span>, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Require the fallback.</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line global-require, import/no-dynamic-require</span></span><br><span class="line">  <span class="keyword">const</span> fallback = <span class="built_in">require</span>(fallbackLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the fallback, passing a copy of the loader context. The copy has the query replaced. This way, the fallback</span></span><br><span class="line">  <span class="comment">// loader receives the query which was intended for it instead of the query which was intended for url-loader.</span></span><br><span class="line">  <span class="keyword">const</span> fallbackLoaderContext = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">query</span>: fallbackOptions,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fallback.<span class="title function_">call</span>(fallbackLoaderContext, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面那一大堆，关键步骤还是两点，一个是shouldTransform，一个是normalizeFallback。</p><p>shouldTransform，顾名思义，是否把文件转成base64。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shouldTransform</span>(<span class="params">limit, size</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> limit === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> limit === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> size &lt;= <span class="built_in">parseInt</span>(limit, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> limit === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> size &lt;= limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看，limit可以直接是true&#x2F;false，或者是字符串或者数字，如果是字符串会调parseInt转成数字，逻辑都一样 size &lt;&#x3D; limit。</p><p>如果满足shouldTransform，会调用getEncodedData把文件转成base64。</p><p>接下来是normalizeFallback</p><p><a href="https://github.com/webpack-contrib/url-loader/blob/master/src/utils/normalizeFallback.js#L3">normalizeFallback</a> 看到没有函数内第一行let loader &#x3D; ‘file-loader’;<br>再回到url-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> fallback = <span class="built_in">require</span>(fallbackLoader); <span class="comment">//这里的fallback就是file-loader</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the fallback, passing a copy of the loader context. The copy has the query replaced. This way, the fallback</span></span><br><span class="line"><span class="comment">// loader receives the query which was intended for it instead of the query which was intended for url-loader.</span></span><br><span class="line"><span class="keyword">const</span> fallbackLoaderContext = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>, &#123;</span><br><span class="line">    <span class="attr">query</span>: fallbackOptions,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fallback.<span class="title function_">call</span>(fallbackLoaderContext, content); <span class="comment">//最后执行file-loader</span></span><br></pre></td></tr></table></figure><p>完了，所以这俩的区别就是url-loader内部会根据limit的值决定直接把文件转成base64还是直接调用file-loader。</p><h1 id="sass-loader、css-loader、style-loader"><a href="#sass-loader、css-loader、style-loader" class="headerlink" title="sass-loader、css-loader、style-loader"></a>sass-loader、css-loader、style-loader</h1><h2 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h2><p><a href="https://github.com/webpack-contrib/sass-loader/blob/v13.2.2/src/index.js#L22">源码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loader</span>(<span class="params">content</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="title function_">getOptions</span>(schema); <span class="comment">//获取使用sass-loader时传入的options，这里为空</span></span><br><span class="line">    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="title function_">async</span>(); <span class="comment">//这个async函数会返回一个异步执行的函数callback，执行这个callback会把当前loader的结果传递给下一个loader。这里sass-loader不是最终的loader，所以需要这个。</span></span><br><span class="line">    <span class="keyword">const</span> implementation = <span class="title function_">getSassImplementation</span>(<span class="variable language_">this</span>, options.<span class="property">implementation</span>);</span><br><span class="line">    <span class="comment">// 获取sass解析器，可以是node-sass、dart-sass或者sass-embedded</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!implementation) &#123; <span class="comment">// 如果获取不到sass解析器，直接返回，并且给下一个loader callback一个空</span></span><br><span class="line">        <span class="title function_">callback</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> useSourceMap =</span><br><span class="line">        <span class="keyword">typeof</span> options.<span class="property">sourceMap</span> === <span class="string">&quot;boolean&quot;</span> ? options.<span class="property">sourceMap</span> : <span class="variable language_">this</span>.<span class="property">sourceMap</span>; <span class="comment">// 是否启用sourceMap，这里是true</span></span><br><span class="line">    <span class="keyword">const</span> sassOptions = <span class="keyword">await</span> <span class="title function_">getSassOptions</span>( </span><br><span class="line">        <span class="variable language_">this</span>,</span><br><span class="line">        options,</span><br><span class="line">        content,</span><br><span class="line">        implementation,</span><br><span class="line">        useSourceMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> shouldUseWebpackImporter =</span><br><span class="line">        <span class="keyword">typeof</span> options.<span class="property">webpackImporter</span> === <span class="string">&quot;boolean&quot;</span></span><br><span class="line">            ? options.<span class="property">webpackImporter</span></span><br><span class="line">            : <span class="literal">true</span>;  <span class="comment">//表示是否使用webpack解析源码里面的@import，这里的值是true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldUseWebpackImporter) &#123;</span><br><span class="line">        <span class="keyword">const</span> isModernAPI = options.<span class="property">api</span> === <span class="string">&quot;modern&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isModernAPI) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; includePaths &#125; = sassOptions;</span><br><span class="line"></span><br><span class="line">            sassOptions.<span class="property">importer</span>.<span class="title function_">push</span>(</span><br><span class="line">                <span class="title function_">getWebpackImporter</span>(<span class="variable language_">this</span>, implementation, includePaths)</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sassOptions.<span class="property">importers</span>.<span class="title function_">push</span>(</span><br><span class="line">                <span class="title function_">getModernWebpackImporter</span>(<span class="variable language_">this</span>, implementation)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 上面的代码细节不清楚，总的来说，通过options.api判断是否是新版webpack，新旧版本webpack处理@import方法不一样</span></span><br><span class="line">    <span class="keyword">const</span> compile = <span class="title function_">getCompileFn</span>(implementation, options); <span class="comment">//通过上面的implementation获取sass编译器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">compile</span>(sassOptions, options) <span class="comment">// 编译sass，这里假设编译没有错误，所以省略了处理错误的代码</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> map =</span><br><span class="line">        <span class="comment">// Modern API, then legacy API</span></span><br><span class="line">        result.<span class="property">sourceMap</span></span><br><span class="line">            ? result.<span class="property">sourceMap</span></span><br><span class="line">            : result.<span class="property">map</span></span><br><span class="line">                ? <span class="title class_">JSON</span>.<span class="title function_">parse</span>(result.<span class="property">map</span>)</span><br><span class="line">                : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify source paths only for webpack, otherwise we do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (map &amp;&amp; useSourceMap) &#123;</span><br><span class="line">        map = <span class="title function_">normalizeSourceMap</span>(map, <span class="variable language_">this</span>.<span class="property">rootContext</span>);</span><br><span class="line">    &#125; <span class="comment">// 这里生成的map，最后会通过callback传给下一个loader，这里不关心sourceMap，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modern API</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> result.<span class="property">loadedUrls</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">        result.<span class="property">loadedUrls</span></span><br><span class="line">            .<span class="title function_">filter</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> url.<span class="property">protocol</span> === <span class="string">&quot;file:&quot;</span>)</span><br><span class="line">            .<span class="title function_">forEach</span>(<span class="function">(<span class="params">includedFile</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> normalizedIncludedFile = url.<span class="title function_">fileURLToPath</span>(includedFile);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Custom `importer` can return only `contents` so includedFile will be relative</span></span><br><span class="line">                <span class="keyword">if</span> (path.<span class="title function_">isAbsolute</span>(normalizedIncludedFile)) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">addDependency</span>(normalizedIncludedFile);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Legacy API</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> result.<span class="property">stats</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> result.<span class="property">stats</span>.<span class="property">includedFiles</span> !== <span class="string">&quot;undefined&quot;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        result.<span class="property">stats</span>.<span class="property">includedFiles</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">includedFile</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> normalizedIncludedFile = path.<span class="title function_">normalize</span>(includedFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Custom `importer` can return only `contents` so includedFile will be relative</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="title function_">isAbsolute</span>(normalizedIncludedFile)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">addDependency</span>(normalizedIncludedFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面这一堆，细节不清楚，总的来说，是处理sass文件里的引入的本地文件，把它们加入webpack的依赖中，以便在它们变化时重新编译sass文件</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, result.<span class="property">css</span>.<span class="title function_">toString</span>(), map);</span><br><span class="line">    <span class="comment">// 最后把编译好的css传递给下一个loader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有，简单说，如果忽略处理@import与source-map的逻辑，sass-loader所做的事，就是先选择合适的sass解析器，然后编译sass文件把结果传给下一个loader。</p><h2 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h2><p><a href="https://github.com/webpack-contrib/css-loader/blob/v6.7.3/src/index.js#L33">源码</a></p><p>这个loader首先会有一堆处理plugin的逻辑，我们这里不关注plugin，直接从<a href="https://github.com/webpack-contrib/css-loader/blob/v6.7.3/src/index.js#L155">155</a> 行开始看。<br> 当然，155行这里的plugin非空,因为40行会调用normalizeOptions重新生成options，这里由于我们刚开始的rawOptions是空，这里重新生成的options长这样: </p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/2854f00e-4d2a-4e0d-b0b6-85f0d91cafad-%E5%9B%BE%E7%89%87.png" alt="2854f00e-4d2a-4e0d-b0b6-85f0d91cafad-图片.png"></p><p>由于options.url与options.import是true，所以155行的plugin是个长度为2的数组，这里会调用postcss处理这个plugin，主要处理css文件里的@import与url相关。</p><p>这里假设没有错误，也没有warning，剩下的那一堆代码细节先不管，直接跳到最后一行，最后一行callback了一个经过拼接的字符串，我们可以把这个字符串log出来:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imports</span></span><br><span class="line"><span class="keyword">import</span> ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ <span class="keyword">from</span> <span class="string">&quot;./loaders/css-loader/runtime/noSourceMaps.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ___CSS_LOADER_API_IMPORT___ <span class="keyword">from</span> <span class="string">&quot;./loaders/css-loader/runtime/api.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ___CSS_LOADER_EXPORT___ = <span class="title function_">___CSS_LOADER_API_IMPORT___</span>(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);</span><br><span class="line"><span class="comment">// Module</span></span><br><span class="line">___CSS_LOADER_EXPORT___.<span class="title function_">push</span>([<span class="variable language_">module</span>.<span class="property">id</span>, <span class="string">&quot;.container &#123;\n  max-width: 960px;\n  margin: 0 auto;\n  padding: 20px;\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); &#125;\n  .container h1 &#123;\n    color: #007bff;\n    font-size: 36px;\n    text-align: center; &#125;\n&quot;</span>, <span class="string">&quot;&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exports</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ___CSS_LOADER_EXPORT___;</span><br></pre></td></tr></table></figure><p>从这里可以看到，css-loader把css转换成了可运行的js，转换后的css则通过字符串的形式放在___CSS_LOADER_EXPORT___这个变量上，最后导出___CSS_LOADER_EXPORT___。</p><p>这个文件站在使用者的角度上来看没什么意义，css嘛，要么通过link标签引入，要么通过style插入到head里。如果是前者，loader是做不到了，因为loader的作用仅仅是把各种文件转换成可运行的js，这个功能可以用mini-css-extract-plugin，这个插件会在打包过程中拿到css文件的路径，然后在打包结束通过link标签把css插入html，需要配合htmlwebpackplugin使用。如果是后者，可以使用style-loader。</p><h2 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h2><p><a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/index.js#L28">源码</a></p><p>这个loader的入口是一个pitch函数，我们知道webpack loader是从右往左执行的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        <span class="attr">use</span>:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如你的webpack配置长这样，如果没有pitch函数，应该从右往左，即sass-loader css-loader style-loader，如果三个loader都有pitch函数，执行顺序变成这样，style-loader-pitch css-loader-pitch sass-loader-pitch sass-loader css-loader style-loader，如果在这条代码链的执行过程中，有某一个loader的pitch返回了一个值，后面loader的代码就不执行了。</p><p>回到真实情况，这里的style-loader-pitch返回了值，所以只会执行style-loader-pitch与style-loader。</p><p>这个pitch函数大多数逻辑我们并不需要关注，我仅仅想知道它是如何把css插入dom的（我很懒）。所以只需要关注这个loader最后返回了什么东西，下面是我通过debugger提取出来syle-loader最后生成的东西。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="variable constant_">API</span> <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/injectStylesIntoStyleTag.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> domAPI <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/styleDomAPI.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> insertFn <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/insertBySelector.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> setAttributes <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/setAttributesWithoutAttributes.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> insertStyleElement <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/insertStyleElement.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> styleTagTransformFn <span class="keyword">from</span> <span class="string">&quot;!./loaders/style-loader/runtime/styleTagTransform.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> content, * <span class="keyword">as</span> namedExport <span class="keyword">from</span> <span class="string">&quot;!!./loaders/css-loader/index.js!./loaders/sass-loader/index.js!./style.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">options.<span class="property">styleTagTransform</span> = styleTagTransformFn;</span><br><span class="line">options.<span class="property">setAttributes</span> = setAttributes;</span><br><span class="line"></span><br><span class="line">options.<span class="property">insert</span> = insertFn.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&quot;head&quot;</span>);</span><br><span class="line"></span><br><span class="line">options.<span class="property">domAPI</span> = domAPI;</span><br><span class="line">options.<span class="property">insertStyleElement</span> = insertStyleElement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> update = <span class="title function_">API</span>(content, options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!content.<span class="property">locals</span> || <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="property">invalidate</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> isEqualLocals = <span class="keyword">function</span> <span class="title function_">isEqualLocals</span>(<span class="params">a, b, isNamedExport</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!a &amp;&amp; b || a &amp;&amp; !b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> p;</span><br><span class="line">      <span class="keyword">for</span> (p <span class="keyword">in</span> a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNamedExport &amp;&amp; p === <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[p] !== b[p]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (p <span class="keyword">in</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNamedExport &amp;&amp; p === <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">          <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[p]) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> isNamedExport = !content.<span class="property">locals</span>;</span><br><span class="line">    <span class="keyword">var</span> oldLocals = isNamedExport ? namedExport : content.<span class="property">locals</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(</span><br><span class="line">      <span class="string">&quot;!!./loaders/css-loader/index.js!./loaders/sass-loader/index.js!./style.scss&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isEqualLocals</span>(oldLocals, isNamedExport ? namedExport : content.<span class="property">locals</span>, isNamedExport)) &#123;</span><br><span class="line">          <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">invalidate</span>();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldLocals = isNamedExport ? namedExport : content.<span class="property">locals</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">update</span>(content);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">dispose</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">update</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;!!./loaders/css-loader/index.js!./loaders/sass-loader/index.js!./style.scss&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> content &amp;&amp; content.<span class="property">locals</span> ? content.<span class="property">locals</span> : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>这一段代码会在浏览器里执行，主要是这一句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> update = <span class="title function_">API</span>(content, options);</span><br></pre></td></tr></table></figure><p>这里的API来自<a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/runtime/injectStylesIntoStyleTag.js#L84">这里</a> ,执行API的过程中，会调用<a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/runtime/injectStylesIntoStyleTag.js#L16">modulesToDom</a> ,接着是<a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/runtime/injectStylesIntoStyleTag.js#L41">addElementStyle</a> ,这个函数的前两句完成了把css通过style标签插入到dom中的任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addElementStyle</span>(<span class="params">obj, options</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">const</span> api = options.<span class="title function_">domAPI</span>(options);</span><br><span class="line">     api.<span class="title function_">update</span>(obj);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的domAPI来自<a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/runtime/styleDomAPI.js#L56">这儿</a> ,首先通过options.insertStyleElement生成styleElement（这里会生成一个空的style标签），然后在update函数内部调用了apply函数，apply函数首先通过一系列条件对传进来的css进行字符串拼接，这里不是重点，关键是最后: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.<span class="title function_">styleTagTransform</span>(css, styleElement, options.<span class="property">options</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack-contrib/style-loader/blob/v3.3.2/src/runtime/styleTagTransform.js">styleTagTransform</a></p><p>代码很简单，我们这里只会命中&#96;&#96;styleElement.appendChild(document.createTextNode(css));&#96;这一句。</p><p>但是有个问题，style-loader的pitch函数返回了值，后面的loader不执行了，那是怎么把sass代码转换成css的，注意看上面style-loader的返回值里面有这么一句: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> content, * <span class="keyword">as</span> namedExport <span class="keyword">from</span> <span class="string">&quot;!!./loaders/css-loader/index.js!./loaders/sass-loader/index.js!./style.scss&quot;</span>;</span><br></pre></td></tr></table></figure><p>webpack会解析这个import（带有感叹号的会忽略），然后在import的过程中会执行sass-loader、css-loader。</p><h1 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h1><h1 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>整理react里面那些容易让人混淆的概念 😂</title>
      <link href="/2023/04/19/%E6%95%B4%E7%90%86react%E9%87%8C%E9%9D%A2%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E8%AE%A9%E4%BA%BA%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5-u-1F602/"/>
      <url>/2023/04/19/%E6%95%B4%E7%90%86react%E9%87%8C%E9%9D%A2%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E8%AE%A9%E4%BA%BA%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5-u-1F602/</url>
      
        <content type="html"><![CDATA[<h1 id="react为什么要引入fiber"><a href="#react为什么要引入fiber" class="headerlink" title="react为什么要引入fiber"></a>react为什么要引入fiber</h1><p>在解释为什么之前，先来说一说react16之前组件的更新过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child componentWillMount&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child render&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child componentDidMount&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child componentWillReceiveProps&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child shouldComponentUpdate&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child componentWillUpdate&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child componentDidUpdate&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">                        this.setState(&#123;</span></span><br><span class="line"><span class="language-xml">                            count: this.state.count + 1</span></span><br><span class="line"><span class="language-xml">                        &#125;)</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                        add</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子用react15来运行，child组件没有state与props，但是随着App组件的更新（点击add按钮），child组件也跟着更新了（触发了componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render与componentDidUpdate），这显然不合理，万一child组件很大呢，针对这种情况，react16之前可以使用shouldComponentUpdate来阻止组件不必要的更新。</p><p>虽然shouldComponentUpdate可以解决这种情况，但是这种现象暴露了react的一个弊端，父组件更新，子组件也会无脑更新，除非调用shouldComponentUpdate，为什么vue没有这种弊端，原因就是vue有响应式系统，所以vue可以很明确的知道哪些依赖需要更新，而不需要重新render整棵树。有些情况可以用shouldComponentUpdate规避掉无用更新，但是react肯定有机会重新render一颗巨大的树。我们知道react组件的更新过程，先调用render，生成新的虚拟dom，然后执行diff算法，比对新旧虚拟dom不一样的地方，最后作用到真实dom上。在这些步骤中，假如组件树很大，diff算法则需要较长时间。javascript是单线程语言，长时间的diff会卡住主线程，这种现象在react16之前是没办法解决的。</p><p>为了解决上面的问题，react16引入了fiber，首先说说什么是fiber，fiber是一种新的数据结构，用来描述一个虚拟dom，假如有以下树形结构<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/0193a7ad-6941-4d1c-a999-b556be454daa-image.png" alt="0193a7ad-6941-4d1c-a999-b556be454daa-image.png"></p><p>react16之前这么描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnodes = &#123;</span><br><span class="line">    <span class="attr">key</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                &#123;<span class="attr">key</span>: <span class="string">&#x27;3&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">key</span>: <span class="string">&#x27;4&#x27;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">key</span>:<span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                &#123;<span class="attr">key</span>: <span class="string">&#x27;6&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">key</span>: <span class="string">&#x27;7&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">key</span>: <span class="string">&#x27;8&#x27;</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>react16之后这么描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnodes = &#123;</span><br><span class="line">    <span class="attr">key</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">child</span>:&#123;</span><br><span class="line">        <span class="attr">key</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="attr">parent</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="attr">child</span>:&#123;</span><br><span class="line">            <span class="attr">key</span>:<span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">            <span class="attr">parent</span>:<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">            <span class="attr">sibling</span>:&#123;</span><br><span class="line">                <span class="attr">key</span>:<span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">                <span class="attr">parent</span>:<span class="string">&#x27;2&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">sibling</span>:&#123;</span><br><span class="line">            <span class="attr">key</span>:<span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">            <span class="attr">parent</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="attr">child</span>:&#123;</span><br><span class="line">                <span class="attr">key</span>:<span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">                <span class="attr">parent</span>:<span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">                <span class="attr">sibling</span>:&#123;</span><br><span class="line">                    <span class="attr">key</span>:<span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">                    <span class="attr">parent</span>:<span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">                    <span class="attr">sibling</span>:&#123;</span><br><span class="line">                        <span class="attr">key</span>:<span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">                        <span class="attr">parent</span>:<span class="string">&#x27;5&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比同一张图的两种vnodes，很明显，第一个vnodes在diff的过程中是没法暂停的，因为它每个节点只有children，第二个vnodes每个节点的描述都包含自己与其他节点的关系，这样即使diff暂停，下次继续时也能找到未完成的节点。</p><p>react16以后引入了调度器的概念，它的作用是给任务分级，简而言之，就是由用户触发的更新优先级是大于组件更新的，假如react正在更新一个大组件，diff算法正在如火如荼的工作，这时用户点击了某个按钮要求显示一个提示，那这个更新的优先级最高，react会暂停大组件的更新（依赖于fiber节点的可暂停结构），先去响应按钮的提示，完了继续大组件的更新，react用这种机制来解决更新大组件主线程没有响应的问题。</p><h1 id="引入fiber后所带来的的变化"><a href="#引入fiber后所带来的的变化" class="headerlink" title="引入fiber后所带来的的变化"></a>引入fiber后所带来的的变化</h1><h2 id="render阶段的生命周期"><a href="#render阶段的生命周期" class="headerlink" title="render阶段的生命周期"></a>render阶段的生命周期</h2><p>上面说组件更新可以被暂停，那会不会出现界面更新一半的情况，这种情况是不会出现的，原因是，react16之后，组件更新被分为render阶段与commit阶段，render阶段包括render函数的执行，diff算法的执行，一旦diff算法执行完毕，组件开始更新真实dom，就进入了commit阶段，render阶段可以被反复执行（可中断，可继续），而commit阶段每次更新只能执行一次，所以不会出现dom渲染一半的情况。</p><p>那哪些生命周期属于render阶段，哪些属于commit阶段，首先render函数肯定是在render阶段执行的，因为render函数的作用就是生成虚拟dom，完了才是diff组件以及更新真实dom的过程，所以可以肯定render函数以及它之前的生命周期都属于render阶段。之前说过render阶段的代码是可以被反复执行的，这就带来了一个问题，假如在componentWillReceiveProps、componentWillUpdate这些函数内执行了某些副作用代码，这种生命周期被反复调用的机制就会导致副作用被反复执行，这显然不对，react为了解决这种问题，对render阶段的一些生命周期进行了改造，其实主要采取了两种改造手段：</p><ol><li>把实例方法改成静态方法，比如把componentWillReceiveProps改成static getDerivedStateFromProps，这样改的目的就是不让访问this，一个纯函数被反复执行其实没什么不好。</li><li>标记某些方法是不安全的，随着版本的升级，逐步废弃。</li></ol><p>庆幸的是，shouldComponentUpdate这个方法逃过一劫，原因可能是这个方法语义太明显了，大概没有什么人在这个方法里面执行副作用代码。</p><h2 id="commit阶段的生命周期"><a href="#commit阶段的生命周期" class="headerlink" title="commit阶段的生命周期"></a>commit阶段的生命周期</h2><p>上面说render函数以及之前的生命周期都属于render阶段，那commit阶段呢，有人会说componentWillUpdate？很遗憾，这个生命周期也属于render阶段，并且react16以后被打上了不安全的标记，那有什么方法可以知道更新进入了commit阶段，react16新加了getSnapshotBeforeUpdate，别看这个方法的命名也是getxxx之类的风格，它却是一个实例方法，为什么react这次让人大方的访问this，原因在于更新已经进入commit阶段，即使有副作用也只执行一次没什么不好。</p><p>getSnapshotBeforeUpdate这个方法会在diff结束（是结束不是中断），已经知道哪些dom需要更新，但是还没有被更新的时候调用，所以它可以稳定的获取更新前的dom状态。</p><h2 id="捕获error"><a href="#捕获error" class="headerlink" title="捕获error"></a>捕获error</h2><p>react16以后新增了一个叫getDerivedStateFromError的生命周期，从这个函数的名字来看很像getDerivedStateFromProps，没错它也是一个静态方法，就是不让你访问this。react16之前是怎么捕获错误呢，有一个叫componentDidCatch的方法，这个方法在react16以后也一直保留，为什么出现既生瑜何生亮的场面，原因在于这俩方法的职责不同，举个例子来说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count, onClick &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getDerivedStateFromError has error&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;componentDidCatch has error&quot;</span>, error, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>app<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Child</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">                        this.setState(&#123;</span></span><br><span class="line"><span class="language-xml">                            count: this.state.count + 1</span></span><br><span class="line"><span class="language-xml">                        &#125;);</span></span><br><span class="line"><span class="language-xml">                    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                /&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// react18.2.0</span></span><br></pre></td></tr></table></figure><p>我们在子组件的render函数里面抛一个错，结果发现只有getDerivedStateFromError响应了，我们换个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;componentDidCatch has error&quot;</span>, error);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getDerivedStateFromError has error&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span> === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 模拟一个错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;I crashed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span> + <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;this.state.value&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125; <span class="comment">// react18.2.0</span></span><br></pre></td></tr></table></figure><p>在子组件的componentDidUpdate（commit阶段）里面抛个错，结果getDerivedStateFromError与componentDidCatch都响应了。</p><p>对比这两个例子你会发现，react把捕获错误这个行为分为有副作用的捕获与无副作用的捕获，像在render函数里面发生的错误，render函数处于render阶段，react肯定不希望开发者访问this，所以理所当然的只有getDerivedStateFromError响应，而在componentDidUpdate里面抛的错，由于已经处于commit阶段，开发者想干什么react不会去干预，这时的捕获错误的行为可能是纯的也可能是不纯的，所以两个函数都会响应。</p><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>这里不一一介绍每个hook，只是说明为什么会推出hooks，以及render与commit阶段都有哪些hook。</p><h3 id="为什么推出hooks"><a href="#为什么推出hooks" class="headerlink" title="为什么推出hooks"></a>为什么推出hooks</h3><ol><li>首先react16以后由于引入了可中断更新，在render阶段访问this将变得不安全，除了上面的两种改造外，完全杜绝this也是一种方案，所以react更推崇使用函数式组件。</li><li>react hooks在逻辑复用方面是一把利器，它可能很容易的把逻辑与渲染分开，为什么要分开，简而言之，渲染（ui）是很难抽象与复用的，而逻辑恰恰相反。</li></ol><h3 id="render阶段的hooks"><a href="#render阶段的hooks" class="headerlink" title="render阶段的hooks"></a>render阶段的hooks</h3><p>useState、useMemo、useCallback、useRef、useContext、useReducer、useEffect、useLayoutEffect</p><p>其中useEffect、useLayoutEffect这俩允许执行副作用的hook也是在render阶段执行的。你可能会疑惑，render阶段不是不让执行副作用操作嘛，这俩虽然在render阶段执行，但是它们的回调函数不在render阶段执行。</p><h3 id="commit阶段的hooks"><a href="#commit阶段的hooks" class="headerlink" title="commit阶段的hooks"></a>commit阶段的hooks</h3><p>useEffect与useLayoutEffect的回调函数。</p><p>先说useLayoutEffect。这个hook会在dom更新完毕，但是浏览器还没有来得及绘制之前同步执行。这句话是什么意思呢，我们知道javascript只是用来操作dom，像setState之类操作或者我们手动操作dom只是改变了内存里一颗dom树上的某些节点，真正把dom树绘制成屏幕上形形色色的画面是浏览器完成的，假设我们浏览器一秒绘制60帧，那绘制一帧的时间就是16ms，而javascript是单线程语言，执行js代码与ui绘制是互斥的，所以如果我们在16ms内用10ms的时间来更新dom树，那么还剩6ms用来执行useLayoutEffect与浏览器绘制界面。</p><p>所以这个hook内部适合执行一些短小精悍的代码，假如执行时间过长，浏览器没有足够的时间在一帧内完成界面绘制，就会造成卡顿。</p><p>对比介绍类组件时也有个在commit阶段执行的函数，getSnapshotBeforeUpdate，useLayoutEffect与getSnapshotBeforeUpdate的执行时机却有细微的差别，前者是在真实dom更新完毕浏览器还未绘制之前触发，这时拿到的是更新后的dom，后者是在真实dom还未更新即将更新时触发，这时拿到的是更新前的dom。</p><p>最后说一下useEffect，这个hook的回调函数是在commit阶段执行完毕异步执行的。这时dom已经更新完毕并且浏览器也完成了绘制，因为是异步执行，所以不像useLayoutEffect那么小心翼翼的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习ahooks之useLongPress</title>
      <link href="/2023/03/17/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseLongPress/"/>
      <url>/2023/03/17/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseLongPress/</url>
      
        <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>可能是小程序api用多了，前几天写网页有个需求是监听长按，竟然有点生疏，幸好ahooks实现了useLongPress这个hook。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLongPress/index.ts">原版代码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touchSupported =</span><br><span class="line">  isBrowser &amp;&amp;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  (<span class="string">&#x27;ontouchstart&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> || (<span class="variable language_">window</span>.<span class="property">DocumentTouch</span> &amp;&amp; <span class="variable language_">document</span> <span class="keyword">instanceof</span> <span class="title class_">DocumentTouch</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useLongPress</span>(<span class="params"></span></span><br><span class="line"><span class="params">  onLongPress: (event: EventType) =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  target: BasicTarget,</span></span><br><span class="line"><span class="params">  &#123; delay = <span class="number">300</span>, moveThreshold, onClick, onLongPressEnd &#125;: Options = &#123;&#125;,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> onLongPressRef = <span class="title function_">useLatest</span>(onLongPress);</span><br><span class="line">  <span class="keyword">const</span> onClickRef = <span class="title function_">useLatest</span>(onClick);</span><br><span class="line">  <span class="keyword">const</span> onLongPressEndRef = <span class="title function_">useLatest</span>(onLongPressEnd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> timerRef = useRef&lt;<span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> <span class="built_in">setTimeout</span>&gt;&gt;();</span><br><span class="line">  <span class="keyword">const</span> isTriggeredRef = <span class="title function_">useRef</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> pervPositionRef = <span class="title function_">useRef</span>(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> hasMoveThreshold = !!(</span><br><span class="line">    (moveThreshold?.<span class="property">x</span> &amp;&amp; moveThreshold.<span class="property">x</span> &gt; <span class="number">0</span>) ||</span><br><span class="line">    (moveThreshold?.<span class="property">y</span> &amp;&amp; moveThreshold.<span class="property">y</span> &gt; <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffectWithTarget</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> targetElement = <span class="title function_">getTargetElement</span>(target);</span><br><span class="line">      <span class="keyword">if</span> (!targetElement?.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">overThreshold</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; clientX, clientY &#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">        <span class="keyword">const</span> offsetX = <span class="title class_">Math</span>.<span class="title function_">abs</span>(clientX - pervPositionRef.<span class="property">current</span>.<span class="property">x</span>);</span><br><span class="line">        <span class="keyword">const</span> offsetY = <span class="title class_">Math</span>.<span class="title function_">abs</span>(clientY - pervPositionRef.<span class="property">current</span>.<span class="property">y</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !!(</span><br><span class="line">          (moveThreshold?.<span class="property">x</span> &amp;&amp; offsetX &gt; moveThreshold.<span class="property">x</span>) ||</span><br><span class="line">          (moveThreshold?.<span class="property">y</span> &amp;&amp; offsetY &gt; moveThreshold.<span class="property">y</span>)</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">getClientPosition</span>(<span class="params">event: EventType</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> <span class="title class_">TouchEvent</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">clientX</span>: event.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">clientY</span>: event.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> <span class="title class_">MouseEvent</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">clientX</span>: event.<span class="property">clientX</span>,</span><br><span class="line">            <span class="attr">clientY</span>: event.<span class="property">clientY</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Unsupported event type&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">clientX</span>: <span class="number">0</span>, <span class="attr">clientY</span>: <span class="number">0</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onStart</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; clientX, clientY &#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">          pervPositionRef.<span class="property">current</span>.<span class="property">x</span> = clientX;</span><br><span class="line">          pervPositionRef.<span class="property">current</span>.<span class="property">y</span> = clientY;</span><br><span class="line">        &#125;</span><br><span class="line">        timerRef.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          onLongPressRef.<span class="title function_">current</span>(event);</span><br><span class="line">          isTriggeredRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onMove</span> = (<span class="params">event: TouchEvent</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span> &amp;&amp; <span class="title function_">overThreshold</span>(event)) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">          timerRef.<span class="property">current</span> = <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onEnd</span> = (<span class="params">event: EventType, shouldTriggerClick: boolean = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isTriggeredRef.<span class="property">current</span>) &#123;</span><br><span class="line">          onLongPressEndRef.<span class="property">current</span>?.(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldTriggerClick &amp;&amp; !isTriggeredRef.<span class="property">current</span> &amp;&amp; onClickRef.<span class="property">current</span>) &#123;</span><br><span class="line">          onClickRef.<span class="title function_">current</span>(event);</span><br><span class="line">        &#125;</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">onEndWithClick</span> = (<span class="params">event: EventType</span>) =&gt; <span class="title function_">onEnd</span>(event, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">          isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">          <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">          targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">          <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    [],</span><br><span class="line">    target,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略种种细节，useLongPress这个函数接收三个参数：</p><ol><li>onLongPress，顾名思义，触发长按事件的回调函数。</li><li>target：可以是dom元素，也可以是存储dom元素的ref。</li><li>第三个参数是个对象，有四个子参数：delay(长按多长时间以后触发长按事件，也就是触发长按事件的时间)、moveThreshold（在长按的过程中鼠标或者手指如果有移动，并且这个值存在，会根据这个参数的值决定是否响应长按事件）、onClick(如果有这个值，并且鼠标或者手指按压结束，并且按压时间小于delay，会调用onClick函数)、onLongPressEnd(如果按压结束已经触发过长按事件，在真正结束的时候如果有这个值会调用onLongPressEnd函数)。</li></ol><p>代码开头那个useEffectWithTarget先认为就是useEffect，先忽略useEffectWithTarget大多数代码，直接看这几句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">    targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!touchSupported) &#123;</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onEndWithClick);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseleave&#x27;</span>, onEnd);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMove);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, onStart);</span><br><span class="line">        targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, onEndWithClick);</span><br><span class="line">        <span class="keyword">if</span> (hasMoveThreshold) targetElement.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, onMove);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据是否支持触摸事件，分别监听鼠标或者touch事件，响应的事件很有规律，只不过鼠标事件多了个mouseleave，这里我觉得touch事件也应该加个对应的，比如touchcancel。</p><p>onStart</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onStart</span> = (<span class="params">event: EventType</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasMoveThreshold) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;clientX, clientY&#125; = <span class="title function_">getClientPosition</span>(event);</span><br><span class="line">        pervPositionRef.<span class="property">current</span>.<span class="property">x</span> = clientX;</span><br><span class="line">        pervPositionRef.<span class="property">current</span>.<span class="property">y</span> = clientY;</span><br><span class="line">    &#125; <span class="comment">// 假设没有moveThreshold，这一句先忽略</span></span><br><span class="line">    timerRef.<span class="property">current</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        onLongPressRef.<span class="title function_">current</span>(event);</span><br><span class="line">        isTriggeredRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay); <span class="comment">//delay秒后执行onLongPressRef.current，isTriggeredRef.current表示是否执行过onLongPress</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>onEndWithClick</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onEndWithClick</span> = (<span class="params">event: EventType</span>) =&gt; <span class="title function_">onEnd</span>(event, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">onEnd</span> = (<span class="params">event: EventType, shouldTriggerClick: boolean = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timerRef.<span class="property">current</span>); <span class="comment">//鼠标抬起或者触摸结束时，如果onLongPress还没有调用，清除定时器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTriggeredRef.<span class="property">current</span>) &#123; <span class="comment">//如果onLongPress已经被调用过了，调用onLongPressEnd（如果有）</span></span><br><span class="line">        onLongPressEndRef.<span class="property">current</span>?.(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTriggerClick &amp;&amp; !isTriggeredRef.<span class="property">current</span> &amp;&amp; onClickRef.<span class="property">current</span>) &#123; </span><br><span class="line">        onClickRef.<span class="title function_">current</span>(event);</span><br><span class="line">    &#125; <span class="comment">// 这里的shouldTriggerClick为true，如果onLongPress还没有被触发并且有onClick，调用onClick</span></span><br><span class="line">    isTriggeredRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>onStart与onEndWithClick其实就是onLongPress函数的核心。有时候按压的时候会移动，这时候是否触发longpress事件，这种情况就需要传moveThreshold。</p><p>这个值是个对象{x:0,y:0}，如果按压的过程中有移动，移动的距离(x&#x2F;y)大于moveThreshold.x或者moveThreshold.y，就会取消响应longPress。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onMove</span> = (<span class="params">event: TouchEvent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerRef.<span class="property">current</span> &amp;&amp; <span class="title function_">overThreshold</span>(event)) &#123; <span class="comment">//移动的时候还没有响应longPress，并且移动的距离超了，就会取消定时器</span></span><br><span class="line">        <span class="built_in">clearInterval</span>(timerRef.<span class="property">current</span>);</span><br><span class="line">        timerRef.<span class="property">current</span> = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上就是useLongPress的主要内容。</p><h2 id="useEffectWithTarget"><a href="#useEffectWithTarget" class="headerlink" title="useEffectWithTarget"></a>useEffectWithTarget</h2><p>这里顺便提一下这个hook，代码在<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/utils/createEffectWithTarget.ts">这里</a>，看起来功能和useEffect差不多，只不过多了对前后dom元素的对比，<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/utils/createEffectWithTarget.ts#L42">代码</a>，参数也由useEffect的两个变成了三个。我觉得这个hook的意义更多的在于代码的可读性，由于第三个参数的存在，可以明确表示这个hook是与哪个dom元素相关联。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>亮度、对比度、饱和度的区别</title>
      <link href="/2023/03/06/%E4%BA%AE%E5%BA%A6%E3%80%81%E5%AF%B9%E6%AF%94%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/06/%E4%BA%AE%E5%BA%A6%E3%80%81%E5%AF%B9%E6%AF%94%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始之前先看网上对这三者的解释。</p><p>亮度、对比度和饱和度是图像处理中的三个基本概念。亮度是指图像的明亮程度，对比度是指图像中最亮和最暗部分之间的差异，饱和度是指图像中颜色的鲜艳程度。一般来说，对比度越大，图像越清晰醒目，色彩也越鲜明艳丽；而对比度小，则会让整个画面都灰蒙蒙的。</p><p>看这些文字并不能完全理解这三者，反而容易混淆，看起来这三者都能调整画面的明暗，但又有所不同。</p><p>作为一个程序员，代码语言是比人言更加精确的。既然理解不了文字，就看代码如何实现。</p><h1 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustBrightness</span>(<span class="params">imageData, brightness</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    data[i] = data[i] * brightness;</span><br><span class="line">    data[i + <span class="number">1</span>] = data[i + <span class="number">1</span>] * brightness;</span><br><span class="line">    data[i + <span class="number">2</span>] = data[i + <span class="number">2</span>] * brightness;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给rgb每个值乘以一个大于0的系数brightness，brightness大于1就是增加亮度，brightness小于1（大于0）就是降低亮度。所以用一句话总结：调整亮度就是给图片上每个点像素的rgb值分别乘以一个相同的系数。</p><h1 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustContrast</span>(<span class="params">imageData, contrast</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> factor = (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    data[i] = factor * (data[i] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">    data[i + <span class="number">1</span>] = factor * (data[i + <span class="number">1</span>] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">    data[i + <span class="number">2</span>] = factor * (data[i + <span class="number">2</span>] - <span class="number">128</span>) + <span class="number">128</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体思路和调整亮度差不多，都是给rgb分别乘以某个系数，但没那么简单，主要是这两行让人很费解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> factor = (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast)); <span class="comment">// 代码1</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">data[i] = factor * (data[i] - <span class="number">128</span>) + <span class="number">128</span>; <span class="comment">// 代码2</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><p>公式中的255表示rgb颜色空间的最大取值，259是一个经过反复试验得出的数字，contrast取值-255到255，把contrast带入这个公式，259可以让这个公式的取值范围最接近0到128，至于整个公式的推导过程，我也搞不清楚。</p><p>我们写一些代码来看一下factor具体都有哪些值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFactor</span>(<span class="params">contrast</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">259</span> * (contrast + <span class="number">255</span>)) / (<span class="number">255</span> * (<span class="number">259</span> - contrast));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=-<span class="number">255</span>;i&lt;=<span class="number">255</span>;i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getFactor</span>(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行结果factor取值从0到129.5，129.5趋近128，你可以试一试，把259改成258或者260，结果都不趋近128。</p><p>其实用坐标系表示更为合适：y&#x3D;(259*(x+255))&#x2F;(255*(259-x))</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/817d9b1e-a8ef-4b65-916b-031c3e94169e-image.png" alt="817d9b1e-a8ef-4b65-916b-031c3e94169e-image.png"></p><p>把这条曲线分成两部分，如果-255&lt;x&lt;0,0&lt;y&lt;1;如果0&lt;x&lt;255,1&lt;y&lt;128。</p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><p>假设0&lt;x&lt;255，y从1到128，把y带入代码2。带入之前先解释一下代码2，rgb颜色空间的取值范围是0-255，128是中点，之所以先用色值减去128，是为了判断色值的强弱，位于128左边的色值弱，反之则强，由于factor取值1到128，正数乘以factor，结果是比原值还大的正数，负数乘以factor，结果是比原值还小的负数。</p><p>所以如果x(对比度)大于0，代码2就能保证强者更强，弱者更弱的效果。</p><p>反之如果x(对比度)小于0，代码2也能保证强者更弱，弱者更强的效果，因为正数乘以大于0小于1的数，会变小;负数乘以大于0小于1的数，会变大。</p><h1 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h1><p>这个和前两个不一样，前两个都是先计算出一个合适的factor，然后每个像素rgb分别乘以这个factor，而饱和度却没有合适的factor，通常都是先把rgb转换成hls调节饱和度，完了再转成rgb。就像下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjustSaturation</span>(<span class="params">imageData, saturation</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = data[i];</span><br><span class="line">    <span class="keyword">const</span> g = data[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> b = data[i + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 HSL 颜色空间</span></span><br><span class="line">    <span class="keyword">const</span> hsl = <span class="title function_">rgbToHsl</span>(r, g, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变饱和度</span></span><br><span class="line">    hsl.<span class="property">s</span> += saturation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 RGB 颜色空间</span></span><br><span class="line">    <span class="keyword">const</span> rgb = <span class="title function_">hslToRgb</span>(hsl.<span class="property">h</span>, hsl.<span class="property">s</span>, hsl.<span class="property">l</span>);</span><br><span class="line"></span><br><span class="line">    data[i] = rgb.<span class="property">r</span>;</span><br><span class="line">    data[i + <span class="number">1</span>] = rgb.<span class="property">g</span>;</span><br><span class="line">    data[i + <span class="number">2</span>] = rgb.<span class="property">b</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> imageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饱和度又叫纯度，颜色的纯度由某种颜色的主色占比决定的，所以调节饱和度就是调整某种颜色主色的占比，那如何调节这个比例，这和一些生活经验很相似，比如我们有一些浓墨，如何稀释，对没错，加水就能稀释。</p><p>那如何稀释主色，这就不能加水了，是加灰，在rgb颜色空间中，所有rgb三种一样的颜色都是灰色。</p><p>所以综上，调整某种颜色的饱和度首先要找到它的主色，然后往里面加&#x2F;减灰色。有的颜色主色很容易找到，比如rgb(255,10,10)，要增加这个颜色的饱和度，只需要减少g、b的值，比如饱和度最大的rgb(255,0,0)。有的颜色则没有这么简单，比如rgb(230,233,232)，可能就是大多数颜色都难以简单的计算出主色，所以调整饱和度不能简单的给rgb乘以一个factor。</p><h1 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h1><p>最后说一下hls颜色空间，通过上面对饱和度的解释你会发现使用rgb颜色空间可能有利于计算机存储颜色，但是不方便人类理解，hls便是解决这个问题的，hls由色相、饱和度、亮度组成，色相就是我上面说的主色，取值从0到360，所以可以理解有360种色相;饱和度指的是某种颜色色相的占比(色相与灰度的比例)。</p><p>亮度与饱和度也是容易混淆的，其实借用生活中的经验很容易区分。我们知道大多数物体本身是不发光的，光线照到物体上，物体反射光线到人眼，我们才会看到东西，这里的反射强度就是亮度的概念，而饱和度指的是某种颜色主色的占比，比如rgb(255,0,0)这种颜色，虽然红色的纯度很高，但是没有光源照射，也是看不到的，这种现象用hls描述就是hsl(0, 100%, 0%)。</p><p>明白了光源的存在，亮度与饱和度很容易区分，大多数颜色(除了灰色)都有饱和度，但是不一定有亮度，因为可能没有光源。有了以上理解，那色温就很好理解了，亮度反应的是光源与被照射物体反光的强度，而色温顾名思义则表示光的温度，关于色温的详细介绍可以参考<a href="https://zhuanlan.zhihu.com/p/56252445">这篇</a>。色温用生活中的经验也很好理解，同样的物体在日光的照耀下与在灯光的照耀下，效果肯定不一样，尤其是像自如配套的那种大黄灯。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百度云盘to阿里云盘</title>
      <link href="/2022/08/07/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98to%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/"/>
      <url>/2022/08/07/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98to%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2T百度云终究还是满了，常年的日积月累，删又不知道该该删啥。阿里云盘最近兴起，如果能把部分文件移到阿里云盘里就好了，由于众所周知的原因，百度与阿里的数据是不可能相通的，也不可能会出现官方的xxx迁移工具之类的。所以，这又是一个八仙过海各显神通的活，大家的思路普遍都是先把百度云盘里的资料下载下来，然后再上传到阿里云，这让我想起来宋丹丹的一句名言，把大象装冰箱分几步…</p><p>思路是这样没错，但是大神的做法跟普通人就是不一样，可以参考<a href="https://www.zhihu.com/question/451854774">这个</a> 帖子。本文介绍的是用webdav的那个。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/5e45b33c-8480-4dba-8cf1-8508e26acfa3-image.png" alt="5e45b33c-8480-4dba-8cf1-8508e26acfa3-image.png"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本文只适用于windows操作系统。</p><p>整体的流程就是帖子里说的1、2、3、4、5，不过作为一个务实的搬运工，实际操作过程中有跟帖子不一样的地方。</p><h2 id="第一处："><a href="#第一处：" class="headerlink" title="第一处："></a>第一处：</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d98d7fa0-8ced-43b5-9fd8-e09b8bd0e6ca-image.png" alt="d98d7fa0-8ced-43b5-9fd8-e09b8bd0e6ca-image.png"></p><p>作者一笔带过…。正常操作是这样的，找到你电脑的“启动或关闭windows功能”，然后找到Hyper-V选项，勾上。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/2ac146d3-b31d-45d0-a7d6-1afa9d862691-image.png" alt="2ac146d3-b31d-45d0-a7d6-1afa9d862691-image.png"></p><p>有些人可能找不到Hyper-V选项（比如我），这种情况需要单独安装Hyper-V，参考<a href="https://blog.csdn.net/weixin_37695006/article/details/91589895">这篇</a> .</p><p>在实际操作过程中发现Hyper-V.cmd下载资源很慢，所以最好加上这一句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh winhttp set proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>如果一切顺利，你的“启动或关闭windows功能“里面就能找到Hyper-V了。</p><h2 id="第二处："><a href="#第二处：" class="headerlink" title="第二处："></a>第二处：</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/c83d80c9-7029-442a-9909-7ae7104cfeaf-image.png" alt="c83d80c9-7029-442a-9909-7ae7104cfeaf-image.png"></p><p>又是一笔带过。实际情况是下载安装都没问题，但是运行不起来，类似于这张图：</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/ee5cccf5-a51c-4c0e-8d7d-cbf87c801fba-image.png" alt="ee5cccf5-a51c-4c0e-8d7d-cbf87c801fba-image.png"></p><p>这个问题搞得我都快放弃了，后来搞了个低版本的<a href="mailto:&#x64;&#111;&#x63;&#107;&#101;&#x72;&#64;&#52;&#46;&#53;&#46;&#x31;">&#x64;&#111;&#x63;&#107;&#101;&#x72;&#64;&#52;&#46;&#53;&#46;&#x31;</a>，装上后，还是一样的症状，不过弹了另一个提示，大概内容是我机器上的wsl版本太低，打开给定的链接更新wsl，然后再restart。</p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">链接</a></p><p>按照链接里面的步骤搞完后，docker果然跑起来了。</p><p>其实也可以升级windows版本，我原先是家庭版，升级到pro，docker也跑起来了。</p><h2 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/07339a99-030b-4140-b899-366904904ea7-image.png" alt="07339a99-030b-4140-b899-366904904ea7-image.png"></p><p>这个也很坑，老说我没权限什么的，为此，我还专门注册了个docker账号，最后的结果是zx5253&#x2F;webdav-aliyundriver的作者删库了。好吧，那就找替代品，最后用的是<a href="https://github.com/messense/aliyundrive-webdav">这个</a></p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/fad8809b-61e5-42bf-9f79-7d553a827bd1-image.png" alt="fad8809b-61e5-42bf-9f79-7d553a827bd1-image.png"></p><h2 id="第四处"><a href="#第四处" class="headerlink" title="第四处"></a>第四处</h2><p>这一步需要注意的是那个截图</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/72cef2ba-086b-4c61-b62e-0f532d30471d-image.png" alt="72cef2ba-086b-4c61-b62e-0f532d30471d-image.png"></p><p>红色框图里面的小盾牌表示是否启用https，不要勾选。</p><h2 id="第五处"><a href="#第五处" class="headerlink" title="第五处"></a>第五处</h2><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/38dd9679-108d-4ff1-a924-59787038a263-image.png" alt="38dd9679-108d-4ff1-a924-59787038a263-image.png"></p><p>简简单单三个字：连接后。问题是我根本就连接不上。也是弹了个错误提示：“由于目标计算机积极拒绝，无法连接”。</p><p>这一步也搞得我快要放弃了，网上找了各种办法都没用，最后还是重启大法好，不过重启的是docker的container，也就是这一步在重启的过程中出问题了，解决了这一问题，上一步奇迹般的连接上了。</p><p><a href="https://stackoverflow.com/questions/65272764/ports-are-not-available-listen-tcp-0-0-0-0-50070-bind-an-attempt-was-made-to">参考</a> </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winnat</span><br><span class="line">docker <span class="built_in">start</span> container_name</span><br><span class="line">net <span class="built_in">start</span> winnat</span><br></pre></td></tr></table></figure><p>经过后来的实践，我发现先启动raidriver，然后再启动docker，是直接可以连上的。第一次按教程上的步骤，顺序反而是反的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>写一个左划删除功能</title>
      <link href="/2022/02/13/%E5%86%99%E4%B8%80%E4%B8%AA%E5%B7%A6%E5%88%92%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/"/>
      <url>/2022/02/13/%E5%86%99%E4%B8%80%E4%B8%AA%E5%B7%A6%E5%88%92%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>需求是写一个小程序，用来实现一个app大部分功能。里面有个功能是列表的左划删除，可能app那边有现成的组件&#x2F;库可以用，小程序官方没有提供这样的组件，于是求助于google。</p><p>搜到了<a href="https://segmentfault.com/a/1190000014831500">这个</a> ,看起来挺好的，但是要求高度固定，我列表里面有图片，我无法确定图片的高度固定，跟相关人员沟通起来又是一堆废话，算是备选。</p><p>然后找到了<a href="https://nutui.jd.com/#/swipe">这个</a></p><p>nutui的swipe组件，<a href="https://github.com/jdf2e/nutui/blob/6e63e992565ce404fbbe3a63d459794f141cb4a9/src/packages/__VUE/swipe/index.taro.vue">源码</a> vue写的，我项目用的是react，不过没关系，vue3的Composition api与react hooks是师出同门。看懂它然后翻译一下(我又找到了一个适合自己的巨人)。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>html、css、js永远是一家人，不要看不起html、css，优秀的布局可以省好多代码。</p><iframe src="https://codesandbox.io/embed/distracted-haibt-9sp3o?fontsize=14&hidenavigation=1&theme=light" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:250px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>布局分为3部分，content、left、right，content为列表的主要内容，left&#x2F;right分别表示向右&#x2F;左滑所展示的额外内容，然后left、right分别绝对定位，并且配合translate移出content的可见范围。</p><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view</span><br><span class="line">    :class=&quot;classes&quot;</span><br><span class="line">    :style=&quot;touchStyle&quot;</span><br><span class="line">    @touchstart=&quot;onTouchStart&quot;</span><br><span class="line">    @touchmove=&quot;onTouchMove&quot;</span><br><span class="line">    @touchend=&quot;onTouchEnd&quot;</span><br><span class="line">    @touchcancel=&quot;onTouchEnd&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;view class=&quot;nut-swipe__left&quot; ref=&quot;leftRef&quot; :id=&quot;&#x27;leftRef-&#x27; + refRandomId&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;left&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view class=&quot;nut-swipe__content&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line"></span><br><span class="line">    &lt;view class=&quot;nut-swipe__right&quot; ref=&quot;rightRef&quot; :id=&quot;&#x27;rightRef-&#x27; + refRandomId&quot;&gt;</span><br><span class="line">      &lt;slot name=&quot;right&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touchStyle = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="string">`translate3d(<span class="subst">$&#123;state.offset&#125;</span>px, 0, 0)`</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一目了然。有三个slot，分别对应上述布局中的content、left、right。监听了最外层view的touch事件，目的是根据touch时的各种值来控制offset的值，从而生成touchStyle，使最外层的view移动。</p><p>那么如何得到touch事件的各种值呢，他们封装了个<a href="https://github.com/jdf2e/nutui/blob/6e63e992565ce404fbbe3a63d459794f141cb4a9/src/packages/utils/useTouch/index.ts">useTouch</a> </p><p>代码还是挺简的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startX = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">//滑动起始x值</span></span><br><span class="line"><span class="keyword">const</span> startY = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// 滑动起始y值</span></span><br><span class="line"><span class="keyword">const</span> deltaX = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// 滑动的x值</span></span><br><span class="line"><span class="keyword">const</span> deltaY = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// 滑动的y值</span></span><br><span class="line"><span class="keyword">const</span> offsetX = <span class="title function_">ref</span>(<span class="number">0</span>);<span class="comment">// deltaX的绝对值</span></span><br><span class="line"><span class="keyword">const</span> offsetY = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// deltaY的绝对值</span></span><br><span class="line"><span class="keyword">const</span> direction = ref&lt;<span class="title class_">Direction</span>&gt;(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 滑动的方向</span></span><br></pre></td></tr></table></figure><p>有三个函数，reset&#x2F;start&#x2F;move，start与move分别在touchStart与touchMove时调用，用来记录滑动的距离，调用start时会调用reset。</p><p>值得一提的是，这里计算滑动方向的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getDirection</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y &amp;&amp; x &gt; <span class="variable constant_">MIN_DISTANCE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;horizontal&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; x &amp;&amp; y &gt; <span class="variable constant_">MIN_DISTANCE</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;vertical&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是根据每次滑动offsetX与offsetY的大小以及滑动距离是否大于10决定的。</p><p>再来看swipe组件处理滑动的逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initWidth</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    leftRefWidth.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">getRefWidth</span>(leftRef);</span><br><span class="line">    rightRefWidth.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">getRefWidth</span>(rightRef);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">initWidth</span>();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先拿到left slot与right slot的宽度，如果没有，就是0。然后会监听touchstart、touchmove、touchend事件。</p><p>touchstart</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onTouchStart</span>(<span class="params">event: Event</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (props.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line">    touch.<span class="title function_">start</span>(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平淡无奇，核心是调用了touch.start方法。</p><p>onTouchMove</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">onTouchMove</span>(<span class="params">event: Event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">disabled</span>) <span class="keyword">return</span>;</span><br><span class="line">    touch.<span class="title function_">move</span>(event);</span><br><span class="line">    <span class="keyword">if</span> (touch.<span class="title function_">isHorizontal</span>()) &#123;</span><br><span class="line">      state.<span class="property">moving</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="title function_">setoffset</span>(touch.<span class="property">deltaX</span>.<span class="property">value</span>);</span><br><span class="line">      <span class="keyword">if</span> (props.<span class="property">touchMovePreventDefault</span>) &#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (props.<span class="property">touchMoveStopPropagation</span>) &#123;</span><br><span class="line">        event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是调用touch.move以及setoffset方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">setoffset</span> = (<span class="params">deltaX: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">      position = deltaX &gt; <span class="number">0</span> ? <span class="string">&#x27;right&#x27;</span> : <span class="string">&#x27;left&#x27;</span>;</span><br><span class="line">      <span class="keyword">let</span> offset = deltaX;</span><br><span class="line">      <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> (opened &amp;&amp; oldPosition === position) &#123;</span><br><span class="line">            offset = -rightRefWidth.<span class="property">value</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; rightRefWidth.<span class="property">value</span> ? -rightRefWidth.<span class="property">value</span> : deltaX;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">          <span class="keyword">if</span> (opened &amp;&amp; oldPosition === position) &#123;</span><br><span class="line">            offset = leftRefWidth.<span class="property">value</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; leftRefWidth.<span class="property">value</span> ? leftRefWidth.<span class="property">value</span> : deltaX;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      state.<span class="property">offset</span> = offset;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>这几行if else写的很精妙。swipe组件同时支持左&#x2F;右滑，先来看左划的逻辑。</p><p>opened表示是否已经打开，如果是true并且本次滑动方向与上一次一致，那么offset永远等于-rightRefWidth。</p><p>假设是第一次滑，并且right slot不为空，走的是这句代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = <span class="title class_">Math</span>.<span class="title function_">abs</span>(deltaX) &gt; rightRefWidth.<span class="property">value</span> ? -rightRefWidth.<span class="property">value</span> : deltaX;</span><br></pre></td></tr></table></figure><p>精妙的三元表达式，无形中处理了很多边界情况，先看最正常的：第一次滑，并且right slot不为空。</p><p>这时Math.abs(deltaX) &lt; rightRefWidth，所以offset为deltaX。</p><p>那什么时候Math.abs(deltaX) &gt;&#x3D; rightRefWidth呢，要么right slot完全被划出，要么right slot 为空。假设right slot为空，这时再左滑是滑不动的。</p><p>右滑同理。</p><p>onTouchEnd</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onTouchEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (state.<span class="property">moving</span>) &#123;</span><br><span class="line">  state.<span class="property">moving</span> = <span class="literal">false</span>;</span><br><span class="line">  oldPosition = position;</span><br><span class="line">  <span class="keyword">switch</span> (position) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(state.<span class="property">offset</span>) &lt;= rightRefWidth.<span class="property">value</span> / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.<span class="property">offset</span> = -rightRefWidth.<span class="property">value</span>;</span><br><span class="line">        <span class="title function_">open</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(state.<span class="property">offset</span>) &lt;= leftRefWidth.<span class="property">value</span> / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.<span class="property">offset</span> = leftRefWidth.<span class="property">value</span>;</span><br><span class="line">        <span class="title function_">open</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法隐藏着一个小小的交互体验。假设onTouchEnd触发时，左滑的距离小于rightRefWidth的一半，会自动close，反之open。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">open</span> = (<span class="params">p: SwipePosition = <span class="string">&#x27;&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">     opened = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span> (p) &#123;</span><br><span class="line">       state.<span class="property">offset</span> = p === <span class="string">&#x27;left&#x27;</span> ? -rightRefWidth.<span class="property">value</span> : leftRefWidth.<span class="property">value</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// emit(&#x27;open&#x27;, &#123;</span></span><br><span class="line">     <span class="comment">//   name: props.name,</span></span><br><span class="line">     <span class="comment">//   position: position || p</span></span><br><span class="line">     <span class="comment">// &#125;);</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">close</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">     state.<span class="property">offset</span> = <span class="number">0</span>;</span><br><span class="line">     opened = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// emit(&#x27;close&#x27;, &#123;</span></span><br><span class="line">     <span class="comment">//   name: props.name,</span></span><br><span class="line">     <span class="comment">//   position</span></span><br><span class="line">     <span class="comment">// &#125;);</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>open与close所做的事是分别让offset达到最大值或者最小值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何下载腾讯课堂视频</title>
      <link href="/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/"/>
      <url>/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>腾讯课堂“贴心”的给我们提供了回放功能，但是图心理安慰，老想着如何下载下来才安心。（自己看，不传播）</p><p>随便打开一个腾讯课堂视频，比如<a href="https://ke.qq.com/course/2994329?taid=12141623440683161">这个</a> 随便找一个。chrome浏览器右击检查，打开开发者控制台，NetWork面板，再次刷新网页，NetWork筛选m3u8关键词。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png" alt="f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png"></p><p>这便是该视频不同分辨率的资源，这些链接是不能直接下载的，需要解密，用<a href="https://github.com/nilaoda/N_m3u8DL-CLI/tree/master/N_m3u8DL-CLI">这个</a> 解，貌似c#写的。</p><p>对，没错，我就是搬用工，一点技术含量也没有。</p><p>如果有多个视频需要下载，上述过程略显麻烦。可以移步火狐浏览器，下载Video DownloadHelper 插件，这玩意能直接识别出资源，并且告诉你不同的分辨率，然后还是需要解密m3u8。</p><p>如果需要下载的视频巨多，连用插件copy链接都觉的麻烦，后续看能不能写个爬虫什么的，自动copy链接。然后研究下解密m3u8那工具支不支持批量下载，暂时就这样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习java内部类</title>
      <link href="/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个只擅长javascript的伪程序员，学习java还是挺费劲的，不过没关系，再庞然大物，也能分而治之。</p><p>google搜内部类，好多文章都说java有四种内部类。成员内部类，静态内部类、局部内部类、匿名内部类。记性好的可以直接记住，彷佛回到了读书时代。</p><h1 id="四大内部类"><a href="#四大内部类" class="headerlink" title="四大内部类"></a>四大内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>java是一门强大的面向对象编程语言。在java中，一个类的成员变量，可以是字符串、数字这样的基础数据类型，也可以是数组、Map这样的复杂数据类型，甚至可以是别的类的实例，那为什么不能是一个类呢？</p><p>所以把一个类放在java的成员变量位置上，这个类就是成员内部类，放到静态变量位置上，这个类就是静态内部类。</p><p>所以很容易写出这样的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a); <span class="comment">//标记1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxOuterClass</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>();</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> n.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">//标记2</span></span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java这门语言单从长相上还是挺像typescript的。但是typescript是没有内部类概念的。上面那段代码有几处奇怪的地方，首先是标记1那个孤零零的a变量，实际上java会先找Inner上有没有叫a的成员变量，如果没有，再去找xxxOuterClass。</p><p>再来看标记2，内部类是怎么被实例化的。成员内部类依附于它所对应的外部类，所以需要先实例化一个外部类。这不奇怪，想也能想通，奇怪的是new 操作符就然可以那样使用。按照正常的思维，难道不是xxxOuterClass.Inner m &#x3D; new n.Inner()吗？</p><p>既然一个类可以作为另一个类的成员，那么Inner是否能被访问修饰符修饰呢？实际上分别用public、protected、private修饰Inner，并不报错，只不过用private修饰Inner，在TY中不能实例化Inner。那继承呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TY2</span> <span class="keyword">extends</span> <span class="title class_">xxxOuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TY2</span> <span class="variable">ty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TY2</span>();</span><br><span class="line">        TY2.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> ty.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来也是可以的。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cwwd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>.Inner();</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和静态变量差不多。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>所谓局部内部类就是说一个类可以写到某个方法内部。 你用学js的思维去学java就感觉特别烦，什么花花草草都要起个名字。这不是理所当然的吗？</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类不是说某个类没有名字，而是说你可以直接继承&#x2F;实现某个类，然后直接new，不用写那么多繁文缛节。通常配合接口与抽象类来使用。看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo2 log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，在java中，抽象类只能被继承，不能直接实例化，接口只能被实现，不能直接实例化。现在有了特例，除非被用于匿名内部类。</p><p>上面的代码按正常思路应该这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo3</span> <span class="keyword">extends</span> <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">xxxFoo3</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo3</span>();</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo4</span> <span class="keyword">implements</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此，在这个例子中，所谓匿名，确实省了两个名字。但是转念一想，这不是概念冲突嘛，明明抽象类和接口都不能直接实例化，为啥用于匿名内部类就可以。其实匿名内部类是一种语法糖，java编译器会帮忙补齐缺失的语法。稍微改一下上面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        foo.log();</span><br><span class="line">        foo2.log2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，还是会有类，只不过不用开发者操心。</p><h1 id="直接继承内部类"><a href="#直接继承内部类" class="headerlink" title="直接继承内部类"></a>直接继承内部类</h1><p>我们可以先实例化出外部类，然后再实例化出内部类。我们也可以直接继承一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxxxOuter</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">xxxInner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxxInner2</span> <span class="keyword">extends</span> <span class="title class_">xxxxOuter</span>.xxxInner&#123;</span><br><span class="line">    xxxInner2(xxxxOuter wi)&#123;</span><br><span class="line">        wi.<span class="built_in">super</span>(); <span class="comment">//标记1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxInner2</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxInner2</span>(<span class="keyword">new</span> <span class="title class_">xxxxOuter</span>());</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于成员内部类依赖与外部类，所以xxxInner2的构造函数必须接收一个xxxxOuter的实例，然后调用其super方法。</p><p>但是奇怪的是，在我的idea上wi.super标红了，idea认为wi上没有super这个方法？但却可以运行！为啥这里需要调用wi上的super方法，super不是表示父类&#x2F;父类构造器嘛，xxxxOuter并没有父类，为啥这里不写成wi.constructor()之类的更语义化的api？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习vue-clamp</title>
      <link href="/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/"/>
      <url>/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/Justineo/vue-clamp">项目地址</a></p><p>无意间看到这个库，利用getClientRects与二分法实现多行文字的超出截断，虽说flex更简洁，但是想起我n年前兼容IE时的痛楚，虽说现在不用兼容IE了，但是原理什么的还是忍不住瞅一眼。</p><p>关键是知不知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects">getClientRects</a> 。这玩意兼容性好强大。假如是行内元素调用getClientRects，会返回一个rects集合，这个集合的length就是文本的行数，好简洁，完全不用关心行高什么的。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><ol><li>tag: 由于内部是由render函数生成的vnode，比起template，tag是可以变的，默认是div。</li><li>autoresize: 内部使用resize-detector这个库监听组件的resize事件，size变化时，更新截断状态。</li><li>max-lines: 最大行数</li><li>max-height: 最大高度。max-height与max-lines指定一个即可。</li><li>ellipsis: 省略符号，默认…</li><li>location: ellipsis的位置，默认end。</li><li>expanded: 初始状态是否展开，默认false。</li></ol><p>slot</p><ol><li>default：默认插槽为文本的实际内容（非展示内容）。</li><li>after&#x2F;before：这俩插槽取其一，关于它们的slot scope后面会说。</li></ol><h1 id="用代码简述原理"><a href="#用代码简述原理" class="headerlink" title="用代码简述原理"></a>用代码简述原理</h1><p>vue组件不好解释，语法灵活&#x2F;随意，各种数据自动响应，计算属性什么的互相依赖，读起来挺爽的，给别人解释可太难了。所以我先写个小而美的clamp，方便理解核心原理。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">      <span class="attr">lines</span>:&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">          <span class="attr">default</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">text</span>:<span class="variable language_">this</span>.<span class="title function_">getText</span>(),</span><br><span class="line">            <span class="attr">offsetSet</span>: <span class="variable language_">this</span>.<span class="title function_">getText</span>().<span class="property">length</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> [content] = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;content&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">search</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">search</span>(<span class="params"><span class="keyword">from</span>=<span class="number">0</span>,to=<span class="variable language_">this</span>.text.length</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(to-<span class="keyword">from</span>&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">offset</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="keyword">from</span> + to) / <span class="number">2</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">text</span>.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="keyword">from</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="variable language_">this</span>.<span class="property">offset</span>,to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getText</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> [content] = (<span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> || []).<span class="title function_">filter</span>(</span><br><span class="line">                <span class="function">(<span class="params">node</span>) =&gt;</span> !node.<span class="property">tag</span> &amp;&amp; !node.<span class="property">isComment</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> content ? content.<span class="property">text</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getLines</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="title function_">getClientRects</span>().<span class="property">length</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">isOverflow</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLines</span>() &gt; <span class="variable language_">this</span>.<span class="property">lines</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个props（lines：表示文本的行数），data里面有两个属性text与offset，text表示原始的文本，offset是个信标，表示发生截断的位置，只要offset不等于text的长度，就认为文本发生了截断。</p><p>render函数里面拿到了默认插槽的vnode，并用span渲染出来，为什么是span，因为只有行内元素调用getClientRects才会返回文本长度。从这里还可以看出，插槽与渲染竟然可以分开！！<br>第一次渲染会渲染出全部文本，在mounted里面通过isOverflow判断是否溢出，即文本的实际行数是否大于props.lines，如果发生了溢出，调用search方法，search方法使用了二分法不停的改变offset的位置，直到from与to的差值小于等于3，为什么是3呢，我猜是省略号(…)的长度，这样就算出了最佳的offset以及最佳的截断文本。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>源码与我那个有什么不同：</p><ol><li>支持更多的props</li><li>检测元素的尺寸是否发生变化</li><li>支持更多的插槽</li></ol><p>可以自定义tag，设置是否检测元素的尺寸变化，是否以maxHeight代替maxLines，设置省略号的文本（默认是…），以及省略号的位置。expanded设置初次渲染是否展开文本.</p><p>先从render函数看起。<br><a href="https://github.com/Justineo/vue-clamp/blob/master/src/components/Clamp.js#L227">render</a><br>整体来看，多了before与after插槽的逻辑，before与after取其一。值得注意的是this.$scopedSlots这个api，作用域插槽在render函数里面竟然是这样用的，scope就是传递给插槽的作用域，this.$scopedSlots.before&#x2F;afer(scope)的结果是vnode。然后竟然可以把组件的方法传给scope，又学到了。</p><p>mounted调用init，init内部有一些是否检测元素尺寸变化的逻辑，用了resize-detector，这个库也是作者写的，init最终调用update。update开篇有个localExpanded，这个就是props.expanded，内部写了几个watch来同步两者的状态。然后调用search，和上面的精简版不一样的是多了个stepToFit方法，这个方法的作用是微调offset，即在用二分法得到最终的文本后，最后一行文本的长度可能不满一行，先调用fill方法使文本充满一行（可能发生换行），然后调用clamp方法使文本刚好充满一行。</p><p>原理就是这样。看一下github上的demo。</p><p>before&#x2F;after插槽是个button，点击button调用了toggle方法。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toggle () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">localExpanded</span> = !<span class="variable language_">this</span>.<span class="property">localExpanded</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句话会触发localExpanded的watch</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clampAt</span>(<span class="variable language_">this</span>.<span class="property">text</span>.<span class="property">length</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果localExpanded为true，还原文本，否则，重新截断文本。</p><p>最后，值得注意的是mounted里面的watch写法</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$watch(</span><br><span class="line">  <span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">maxLines</span>, vm.<span class="property">maxHeight</span>, vm.<span class="property">ellipsis</span>, vm.<span class="property">isClamped</span>].<span class="title function_">join</span>(),</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">update</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">tag</span>, vm.<span class="property">text</span>, vm.<span class="property">autoresize</span>].<span class="title function_">join</span>(), <span class="variable language_">this</span>.<span class="property">init</span>)</span><br></pre></td></tr></table></figure><p>又学到了，这种做法可以同时watch多个参数，执行相同的逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习ahooks之useRequest</title>
      <link href="/2021/12/03/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseRequest/"/>
      <url>/2021/12/03/%E5%AD%A6%E4%B9%A0ahooks%E4%B9%8BuseRequest/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ahooks算是react hooks生态库重要的一环，其中useRequest算是使用比较多的hooks。（试问哪个前端页面没有http请求）</p><h1 id="useRequest的自我介绍"><a href="#useRequest的自我介绍" class="headerlink" title="useRequest的自我介绍"></a>useRequest的自我介绍</h1><p>useRequest 是一个强大的异步数据管理的 Hooks，React 项目中的网络请求场景使用 useRequest 就够了。</p><p>useRequest 通过插件式组织代码，核心代码极其简单，并且可以很方便的扩展出更高级的功能。目前已有能力包括….</p><p>主要是第二句：useRequest的核心代码很简单，其他什么防抖、节流都是通过插件实现的。</p><h1 id="代码分层"><a href="#代码分层" class="headerlink" title="代码分层"></a>代码分层</h1><p>带着上一节的官方介绍来看useRequest的代码分层<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequest.ts">入口文件</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useRequest&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(</span><br><span class="line">  <span class="attr">service</span>: <span class="title class_">Service</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  options?: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  plugins?: <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[],</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">return</span> useRequestImplement&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;(service, options, [</span><br><span class="line">    ...(plugins || []),</span><br><span class="line">    useDebouncePlugin,</span><br><span class="line">    useLoadingDelayPlugin,</span><br><span class="line">    usePollingPlugin,</span><br><span class="line">    useRefreshOnWindowFocusPlugin,</span><br><span class="line">    useThrottlePlugin,</span><br><span class="line">    useRefreshDeps,</span><br><span class="line">    useCachePlugin,</span><br><span class="line">    useRetryPlugin,</span><br><span class="line">    useReadyPlugin,</span><br><span class="line">  ] <span class="keyword">as</span> <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useRequest接收service、options、plugin三个参数，随后又调用了useRequestImplement函数，参数为service、options，plugins变成自定义plugins与内置plugins的集合。</p><p>其中service是一个返回promise的函数，也就是封装http request的函数。options则是一个参数大集合，除了 <a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-request/basic#options">base option</a> 以外，还包括内置插件的options。</p><p>从这里其实印证了官方的说法：useRequest的核心功能简单，其他的功能都是插件实现的（包括内置插件与自定义插件）。扒一扒useRequestImplement的源码，看看大佬所说的简单到底有多简单。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequestImplement.ts#L12">useRequestImplement</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useRequestImplement&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(</span><br><span class="line">  <span class="attr">service</span>: <span class="title class_">Service</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;,</span><br><span class="line">  <span class="attr">options</span>: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt; = &#123;&#125;,</span><br><span class="line">  <span class="attr">plugins</span>: <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;[] = [],</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; manual = <span class="literal">false</span>, ...rest &#125; = options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchOptions = &#123;</span><br><span class="line">    manual,</span><br><span class="line">    ...rest,</span><br><span class="line">  &#125;;  <span class="comment">//这两句挺费解的，其实可以更简 const fetchOptions = &#123;manual:false,...options&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> serviceRef = <span class="title function_">useLatest</span>(service); <span class="comment">//第一个旁支useLatest。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">useUpdate</span>(); <span class="comment">// 第二个旁支</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchInstance = <span class="title function_">useCreation</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> initState = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p?.<span class="property">onInit</span>?.(fetchOptions)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">    <span class="comment">// 第六个旁支</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fetch</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;(</span><br><span class="line">      serviceRef,</span><br><span class="line">      fetchOptions,</span><br><span class="line">      update,</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...initState),</span><br><span class="line">    );</span><br><span class="line">  &#125;, []); <span class="comment">// useCreation第三个旁支</span></span><br><span class="line">  fetchInstance.<span class="property">options</span> = fetchOptions;</span><br><span class="line">  <span class="comment">// run all plugins hook</span></span><br><span class="line">  fetchInstance.<span class="property">pluginImpls</span> = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> <span class="title function_">p</span>(fetchInstance, fetchOptions)); <span class="comment">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class="line">    <span class="comment">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useMount</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 第四个旁支</span></span><br><span class="line">    <span class="keyword">if</span> (!manual) &#123;</span><br><span class="line">      <span class="comment">// useCachePlugin can set fetchInstance.state.params from cache when init</span></span><br><span class="line">      <span class="keyword">const</span> params = fetchInstance.<span class="property">state</span>.<span class="property">params</span> || options.<span class="property">defaultParams</span> || [];</span><br><span class="line">      <span class="comment">// @ts-ignore</span></span><br><span class="line">      fetchInstance.<span class="title function_">run</span>(...params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useUnmount</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// 第五个旁支</span></span><br><span class="line">    fetchInstance.<span class="title function_">cancel</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">loading</span>: fetchInstance.<span class="property">state</span>.<span class="property">loading</span>,</span><br><span class="line">    <span class="attr">data</span>: fetchInstance.<span class="property">state</span>.<span class="property">data</span>,</span><br><span class="line">    <span class="attr">error</span>: fetchInstance.<span class="property">state</span>.<span class="property">error</span>,</span><br><span class="line">    <span class="attr">params</span>: fetchInstance.<span class="property">state</span>.<span class="property">params</span> || [],</span><br><span class="line">    <span class="attr">cancel</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">cancel</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">refresh</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">refresh</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">refreshAsync</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">refreshAsync</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">run</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">run</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">runAsync</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">runAsync</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">    <span class="attr">mutate</span>: <span class="title function_">useMemoizedFn</span>(fetchInstance.<span class="property">mutate</span>.<span class="title function_">bind</span>(fetchInstance)),</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">Result</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;;</span><br><span class="line">&#125;<span class="comment">// 第七个旁支useMemoizedFn</span></span><br></pre></td></tr></table></figure><p>上面一波粗略的阅读虽然遇到了6个旁支，但是根据变量的命名以及官方文档我们可以猜一猜useRequestImplement都干了什么事。</p><p><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-latest">useLatest</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-update">useUpdate</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-creation">useCreation</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-mount">useMount</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-unmount">useUnmount</a><br><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn">useMemoizedFn</a></p><p>通过文档可以看出useLatest的作用是返回某个参数的最新值，useCreation的作用是使某个值保持绝对不变（除非依赖发生变化）,useMemoizedFn的作用是使函数的地址永远不变。这三个都属于性能优化hook，对于我们理解useRequest可以暂时忽略。</p><p>而useUpdate，顾名思义，返回一个强制刷新的函数，用于整个组件树重新渲染。</p><p>useMount与useUnmount属于生命周期hook，分别在组件挂载与卸载时触发。</p><p>综上，useRequestImplement做的事其实就是，通过new Fetch生成一个fetchInstance实例，参数除了serviceRef、fetchOptions、update外，还有initState。瞅一眼initState。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> p?.<span class="property">onInit</span>?.(fetchOptions)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Plugin</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  (<span class="attr">fetchInstance</span>: <span class="title class_">Fetch</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;, <span class="attr">options</span>: <span class="title class_">Options</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;): <span class="title class_">PluginReturn</span>&lt;</span><br><span class="line">    <span class="title class_">TData</span>,</span><br><span class="line">    <span class="title class_">TParams</span></span><br><span class="line">  &gt;;</span><br><span class="line">  onInit?: <span class="function">(<span class="params">options: Options&lt;TData, TParams&gt;</span>) =&gt;</span> <span class="title class_">Partial</span>&lt;<span class="title class_">FetchState</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TParams</span>&gt;&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这两处可以看出每个plugin都可以有个onInit函数，返回值是部分FetchState对象，这个对象的集合就是initState。 瞅一眼Fetch的构造函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> options: Options&lt;TData, TParams&gt;,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> subscribe: Subscribe,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      ...<span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">      <span class="attr">loading</span>: !options.<span class="property">manual</span>,</span><br><span class="line">      ...initState,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看出，onInit的作用其实就是在初始化fetchInstance时，通过插件的形式生成initState，initState会在new Fetch时作为state的默认值。</p><p>回到主线，生成fetchInstance实例后，会在fetchInstance上放一些东西。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetchInstance.<span class="property">options</span> = fetchOptions;</span><br><span class="line">  <span class="comment">// run all plugins hooks</span></span><br><span class="line">fetchInstance.<span class="property">pluginImpls</span> = plugins.<span class="title function_">map</span>(<span class="function">(<span class="params">p</span>) =&gt;</span> <span class="title function_">p</span>(fetchInstance, fetchOptions)); <span class="comment">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class="line"><span class="comment">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16">PluginReturn</a></p><p>pluginImpls其实就是一个含有onBefore、onRequest…等生命周期函数的对象集合。而这些生命周期就是插件系统的灵魂。Fetch内部通过一个叫runPluginHandler的函数调用各个插件（pluginImpls）。</p><p>大概瞅一眼<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L37">runPluginHandler</a> 的实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">runPluginHandler</span>(<span class="params">event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="variable language_">this</span>.<span class="property">pluginImpls</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i[event]?.(...rest)).<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看Fetch内部都在什么时机调用runPluginHandler。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L43">runAsync</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L136">cancel</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155">mutate</a></p><p>runAsync方法会在请求的各个阶段调用runPluginHandler（请求前&#x2F;中&#x2F;后…），onBefore&#x2F;onRequest&#x2F;onSuccess…，而这些钩子函数或者直接干预runAsync的执行，或者通过返回<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16">约定的值</a> 来干预runAsync的执行。</p><p>总的来说，所谓的插件就是一个返回PluginReturn的函数，而PluginReturn中的各个生命周期函数会在Fetch的关键方法执行时调用。</p><p>这就是插件的工作原理，我们也可以写插件来执行上述过程。</p><p>回到主线。在组件挂载时执行fetchInstance.run()（假设manual为false），组件卸载时执行fetchInstance.cancel()，然后返回一大堆fetchInstance的属性&#x2F;方法。</p><h1 id="旁支"><a href="#旁支" class="headerlink" title="旁支"></a>旁支</h1><h2 id="Fetch类"><a href="#Fetch类" class="headerlink" title="Fetch类"></a>Fetch类</h2><p>用面向对象的思维封装了useRequest关于网络请求的几个api，在这里插一句话，我以前不重视面向对象那一套东西，其实在某些场景下，面向对象的可封装性与代码的可读性是优于函数式编程的，配合typescript的类型系统写起来不要太爽。</p><p>Fetch洋洋洒洒150+代码，从run函数开刀。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">run</span>(<span class="params">...params: TParams</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">runAsync</span>(...params).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">onError</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run函数调用了runAsync函数。那run与runAsync有啥区别呢，文档是这样写的。<br><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/65b965bf-b6f8-4928-a641-0b986ccc5274-image.png" alt="65b965bf-b6f8-4928-a641-0b986ccc5274-image.png"><br>这句话具有误导作用，runAsync本质上是个async函数.<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L94">onSuccess</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L103">resolve</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L115">onError</a><br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L124">reject</a><br>代码很清晰，run调用了runAsync,后者在执行过程中不管是options里面的success&#x2F;error，还是promise形式的resolve&#x2F;reject都会执行。</p><p>而整个runAsync的执行过程分为三部分，请求前&#x2F;中&#x2F;后。</p><p>请求前：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">count</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> currentCount = <span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  stopNow = <span class="literal">false</span>,</span><br><span class="line">  returnNow = <span class="literal">false</span>,</span><br><span class="line">  ...state</span><br><span class="line">&#125; = <span class="variable language_">this</span>.<span class="title function_">runPluginHandler</span>(<span class="string">&#x27;onBefore&#x27;</span>, params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop request</span></span><br><span class="line"><span class="keyword">if</span> (stopNow) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">  params,</span><br><span class="line">  ...state,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return now</span></span><br><span class="line"><span class="keyword">if</span> (returnNow) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(state.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">onBefore</span>?.(params);</span><br></pre></td></tr></table></figure><p>可以先忽略那个奇怪的count，还是挺简单的，先是调用了所有插件的onBefore钩子。如果stopNow &#x3D;&#x3D;&#x3D; true，返回一个空的promise，否则调用setState设置params和loading，这里的setState和react的setState是雷锋和雷峰塔的关系。<br><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L29">setState</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(<span class="params">s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        ...<span class="variable language_">this</span>.<span class="property">state</span>,</span><br><span class="line">        ...s,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了一个奇怪的subscribe函数，这个subscribe就是Fetch实例化时传入的update函数（useUpdate），目的是使组件rerender，让react组件拿到最新的Fetch成员变量。</p><p>回到runAsync主线。如果returnNow &#x3D;&#x3D;&#x3D; true，返回空的promise，与前一步骤不同的是，这时的loading是true。然后调用options的onBefore函数，说明插件的onBefore是先于options.onBefore执行的，并且可以干预是否执行options.onBefore。</p><p>请求中与请求后分别对应try&#x2F;catch代码块，暂且忽略count，先调用插件的onRequest钩子，请求可以在插件中发起，假如插件没有返回servicePromise或者没有请求，runAsync会自己执行server，请求完成以后设置state，调用options.onSuccess，插件的onSuccess钩子，options.onFinally。</p><p>请求后与请求中思路类似，就不重复了。回过头来看那个count发现除了runAsync，cancel也访问了count，从这里大概能猜到，runAsync中之所以有那么多currentCount与count的比对，目的就是检测请求有没有被取消（并不会真正的取消那条请求）</p><p>剩下的refresh、refreshAsync与mutate，前两个就不说了，来看<a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155">mutate</a> 的实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">targetData</span>: <span class="title class_">TData</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  targetData = <span class="title function_">data</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  targetData = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">runPluginHandler</span>(<span class="string">&#x27;onMutate&#x27;</span>, targetData);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: targetData,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码很清晰，所做的事就是不调用server直接setState(data)，顺便调用插件的onMutate钩子，从代码来看，data还可以是个函数。</p><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h3 id="useLatest"><a href="#useLatest" class="headerlink" title="useLatest"></a>useLatest</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts">useLatest</a><br>简简单单几行代码，道不出这个hooks的真谛，我们来看官方<a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-latest">例子</a> 。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> latestCountRef = <span class="title function_">useLatest</span>(count);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(latestCountRef.<span class="property">current</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把useLatest去掉</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以自己用codesanbox运行运行一下这段代码，会发现jsx中count的值永远都是1。为什么会这样呢？这是因为每次setInterval在触发回调时，这个回调函数的地址都是一样的，也就是说每次调用的回调函数都是同一个，一旦函数唯一，该函数在创建时拥有的闭包就唯一，而count在每次rerender时都会重新生成，所以储存在setInterval函数闭包里的count永远都是第一次的count。</p><p>稍微改一点代码，验证一下这个过程。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">  <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>每次输出的func.time都是同一个值，count也是同一个值。这就验证了上述函数唯一，闭包唯一的结论。</p><p>那怎么才能让代码正常运行呢？有两种解决方案：</p><ol><li>函数不唯一。</li><li>函数唯一，但是闭包里的count是不可变的。</li></ol><p>第一种方案：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">      <span class="title function_">setCount</span>(count+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">      <span class="title function_">func</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unbind&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [count]);</span><br></pre></td></tr></table></figure><p>看起来挺好的，只需要改变一些useEffect的依赖，但是从log可以看出，会不停的输出unbind，所以这种方式是通过不停的unbind&#x2F;bind的方式来实现函数的不唯一，这就不好了。</p><p>第二种方案：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> latesCount = <span class="title function_">useRef</span>(count)</span><br><span class="line">  latesCount.<span class="property">current</span> = count</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count&#x27;</span>,count)</span><br><span class="line">      <span class="title function_">setCount</span>(latesCount.<span class="property">current</span>+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func.<span class="property">time</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(func.<span class="property">time</span>)</span><br><span class="line">      <span class="title function_">func</span>()</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unbind&#x27;</span>)</span><br><span class="line">      <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从log可以看出func唯一，func中的count也唯一，但是jsx中的count会持续的增加。这是因为setCount的第一个参数不再是func闭包中不变的count，而是latesCount.current。</p><h3 id="useMemoizedFn"><a href="#useMemoizedFn" class="headerlink" title="useMemoizedFn"></a>useMemoizedFn</h3><p><a href="https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn">官方例子</a></p><p>为什么存在这个hook，useCallback又有什么缺点。为什么要保证函数的地址永远不变，举个例子来看一看这个问题。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次点击add count button，Child组件都会rerender，万一Child组件很大，或者嵌套层次很深呢，这无疑带来了巨大的性能问题。</p><p>用React.memo包一下会好一点。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样点击add count button，Child组件就不渲染了。但是React.momo在props变化时还是会rerender，代码改成这样。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// const latestCountRef = useLatest(count);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">func</span>=<span class="string">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以发现点击add count button，Child组件竟然重新渲染了，由此可见，每次setCount，onClickHandler都会指向一个新的函数地址。怎么规避呢，来看一看useMemoizedFn的实现。</p><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts">useMemoizedFn</a></p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> useMemoizedFn&lt;T <span class="keyword">extends</span> noop&gt;(<span class="attr">fn</span>: T) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`useMemoizedFn expected parameter is a function, got <span class="subst">$&#123;<span class="keyword">typeof</span> fn&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fnRef = useRef&lt;T&gt;(fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// why not write `fnRef.current = fn`?</span></span><br><span class="line">  <span class="comment">// https://github.com/alibaba/hooks/issues/728</span></span><br><span class="line">  fnRef.<span class="property">current</span> = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> fn, [fn]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> memoizedFn = useRef&lt;T&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!memoizedFn.<span class="property">current</span>) &#123;</span><br><span class="line">    memoizedFn.<span class="property">current</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line @typescript-eslint/no-invalid-this</span></span><br><span class="line">      <span class="keyword">return</span> fnRef.<span class="property">current</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">as</span> T;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> memoizedFn.<span class="property">current</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>useMemoizedFn本质上是个高阶函数。有两个useRef，一个存储变化的fn，一个存储永远不变的memoizedFn，调用useMemoizedFn时真正调用的是memoizedFn，然后在memoizedFn内部调用最新的fn。高阶函数的思路。</p><p>PS: 这里有个想法，useCallback为啥会有这么多的问题，是不是我们用错了呢？react hooks的设计初衷是使函数式组件拥有状态，那我们要是能保证被useCallback缓存的函数都是纯函数，是不是就不存在闭包问题。假如上面的例子写成这样：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> onClickHandler = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">count</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;,[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">          onClickHandler(count)</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;&gt;add count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">func</span>=<span class="string">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child render&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样写是不是也不存在闭包问题。</p><p>2022.08.02更新，上面的写法还是有问题，虽然解决了函数的引用问题，但却大大增加了心智负担，假如某个方法有好几个依赖，并且有好几处调用，每次调用都要传大一堆“看似无用“的参数，这样就不如在定义函数时“标明”依赖方便。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">a,b,c,d,e</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,[])</span><br><span class="line"><span class="title function_">foo</span>(a,b,c,d,e)</span><br><span class="line"><span class="comment">//这样每次调用foo，都必须传a、b、c、d、e。这样倒不如定义foo时只写一遍依赖方便，但这样又会带来函数地址问题，所以还是需要useMemoizedFn，或者关注一下react新的hooks，useEvent</span></span><br></pre></td></tr></table></figure><h3 id="useCreation"><a href="#useCreation" class="headerlink" title="useCreation"></a>useCreation</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts">useCreation</a><br><a href="https://ahooks.js.org/zh-CN/hooks/use-creation">文档</a></p><p>正如官方文档说的那样，useRef并不能保证参数绝对不变，所以需要useCreation，我们来看是怎么实现的。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> useCreation&lt;T&gt;(<span class="attr">factory</span>: <span class="function">() =&gt;</span> T, <span class="attr">deps</span>: <span class="title class_">DependencyList</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; current &#125; = <span class="title function_">useRef</span>(&#123;</span><br><span class="line">    deps,</span><br><span class="line">    <span class="attr">obj</span>: <span class="literal">undefined</span> <span class="keyword">as</span> <span class="literal">undefined</span> | T,</span><br><span class="line">    <span class="attr">initialized</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (current.<span class="property">initialized</span> === <span class="literal">false</span> || !<span class="title function_">depsAreSame</span>(current.<span class="property">deps</span>, deps)) &#123;</span><br><span class="line">    current.<span class="property">deps</span> = deps;</span><br><span class="line">    current.<span class="property">obj</span> = <span class="title function_">factory</span>();</span><br><span class="line">    current.<span class="property">initialized</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.<span class="property">obj</span> <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数不再是实例本身，而是返回实例的工厂函数，第二个参数是依赖，类型和内置hook类型一样。用一个useRef来保存实例相关的一些参数，只有当initialized为false或者deps发生变化时，才重新执行工厂函数，最后返回实例，如果该实例没有依赖，那么该实例就会唯一。</p><h3 id="useUpdate"><a href="#useUpdate" class="headerlink" title="useUpdate"></a>useUpdate</h3><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useUpdate</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [, setState] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setState</span>(&#123;&#125;), []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUpdate;</span><br></pre></td></tr></table></figure><p>我们都知道，调用useState的setState会使组件树重新渲染，利用这一点可以达到强制刷新的目的。</p><h3 id="useMount"><a href="#useMount" class="headerlink" title="useMount"></a>useMount</h3><h3 id="useUnmount"><a href="#useUnmount" class="headerlink" title="useUnmount"></a>useUnmount</h3><p>useMount与useUnmount。这俩算是最没存在感的hook，内部实现原理都是useEffect。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="内置插件"><a href="#内置插件" class="headerlink" title="内置插件"></a>内置插件</h2><h3 id="useDebouncePlugin"><a href="#useDebouncePlugin" class="headerlink" title="useDebouncePlugin"></a>useDebouncePlugin</h3><p><a href="https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/plugins/useDebouncePlugin.ts">useDebouncePlugin</a><br>大致看一下代码，发现核心实现是调了lodash的debounce方法，那为什么不直接用lodash，究其原因，还要从debounce的原理说起。</p><p><a href="https://github.com/lodash/lodash/blob/master/debounce.js">debounce</a><br>这东西真反直觉，debounce本质上是个高阶函数，你传一个func函数，它给你返回一个debounced函数，至于剩下的那些lastArgs、lastThis…变量，全存在debounced函数的闭包中，所以保持debounced的唯一（闭包唯一）是重中之重。看一个非react的例子。</p><p><a href="https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8">vue debounce</a><br>created时在this上放了一个debouncedGetAnswer函数，就是为了保持debounced的闭包唯一。</p><p>所以不论是这里的useDebouncePlugin还是单独的useDebounceFn，所做的事都是让debounced函数在组件多次渲染中保持唯一。</p><h2 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h2><p>PS: 最近业务比较忙，再加上ahooks代码不停在变动。先合到master，等过段时间再看。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习react-whether</title>
      <link href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/"/>
      <url>/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在用react写业务时，常常要处理一些条件逻辑，由于jsx里面只有写表达式，不能写语句，所以有时不得不写一大坨这样的代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么像这样把大片逻辑封装成组件，要么写个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &#123;<span class="variable language_">this</span>.<span class="title function_">renderComponent</span>()&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">renderComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不完美，有时候并不想凭空写一个方法或者封装组件，并且代码可读性也不好。</p><p>那么有没有更优雅的方法，当然有，所谓前人栽树，后人乘凉，我们只要虚心学习就可以了。</p><p><a href="https://github.com/otakustay/react-whether">react-whether</a> ,看文档可以去这里，本文介绍的是其源码。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>首先打开src&#x2F;index.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Whether</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Whether&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Match</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Match&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Else</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Else&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从文档可以看出<a href="https://github.com/otakustay/react-whether/blob/master/src/Whether.tsx">Whether</a> 是其root component。</p><p>从代码可以看出Whether本质上是一个函数式组件，除了children，接收matches和context两个prop。</p><p>代码开篇判断matches是不是一个boolean，本质上是在判断有没有传matches，如果matches是个boolean，走的是IfElseMode或者IfMode，否则走的是SwitchMode。</p><p>通过计算Whether的children的数量count，来判断是IfElseMode或者IfMode，如果count &lt;&#x3D; 1,走的是IfMode，如果count &gt; 1 并且chidren的最后一项是else，走的是IfElseMode，否则走的是IfMode。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/IfMode.tsx">IfMode</a><br><a href="https://github.com/otakustay/react-whether/blob/master/src/IfElseMode.tsx">IfElseMode</a></p><p>这俩货代码很相似，内部都调用了Render组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Render</span>&gt;&#123;matches ? children : <span class="literal">null</span>&#125;&lt;<span class="regexp">/Render&gt; /</span>/<span class="title class_">IfMode</span></span><br><span class="line">&lt;<span class="title class_">Render</span>&gt;&#123;matches ? ifChildren : elseChildren&#125;&lt;<span class="regexp">/Render&gt; /</span>/<span class="title class_">IfElseMode</span></span><br></pre></td></tr></table></figure><p>这是只传matches的情况，接下来看只传context的情况，也就是switchMode</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> matches !== <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> elements = <span class="title class_">Children</span>.<span class="title function_">toArray</span>(children) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt;;</span><br><span class="line">        <span class="keyword">const</span> branches = elements.<span class="title function_">map</span>(elementToBranch);</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SwitchMode</span> <span class="attr">context</span>=<span class="string">&#123;context&#125;</span> <span class="attr">branches</span>=<span class="string">&#123;branches&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementToBranch = (&#123;<span class="keyword">type</span>, props&#125;: <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;): <span class="title class_">MatchProp</span> | <span class="function"><span class="params">BranchPropWithSelector</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Match</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">selector</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">children</span>: props.<span class="property">children</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>elementToBranch 的作用是整合props与children，生成统一的branches，因为children可能是Match，也可能不是。最后调用SwitchMode组件。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/SwitchMode.tsx">SwitchMode</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SwitchMode</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">SwitchModeProp</span>&gt; = <span class="function">(<span class="params">&#123;context, branches&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> branch = branches.<span class="title function_">find</span>(<span class="function">(<span class="params">&#123;selector&#125;</span>) =&gt;</span> <span class="title function_">selector</span>(context));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Render</span>&gt;</span>&#123;branch ? branch.children : null&#125;<span class="tag">&lt;/<span class="name">Render</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码与ifMode很相似，唯一的区别是多了个branch，这里用find方法很巧妙。假如我代码这么写。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [user,changeUser] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Whether</span> <span class="attr">context</span>=<span class="string">&#123;user&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;foo&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;bar&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                else</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Whether</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照elementToBranch的逻辑，假如children的某一项不是Match，会生成返回true的selector函数，但是数组的find方法永远只返回第一个符合条件的值。所以最后一项是不是Else组件根本不重要，写成div也可以，关键是顺序。</p><p>最后看一下三个mode都用到的Render组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Render</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">RenderProp</span>&gt; = (&#123;children&#125;): <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;isRenderFunc(children) ? children() : children&#125;<span class="tag">&lt;/&gt;</span></span>; <span class="comment">//懒加载的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习recycler-view</title>
      <link href="/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/"/>
      <url>/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p><p><a href="https://github.com/hdcoo/recycler-view">https://github.com/hdcoo/recycler-view</a></p><h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>先去<a href="https://github.com/hdcoo/recycler-view-demo">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a href="http://localhost:5211/recycler-view-demo/%EF%BC%8C">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p><p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p><iframe src="https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>可是这个库的布局是这样的</p><iframe src="https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p><p>回到官方的两列瀑布流例子</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy"></p><p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png" alt="d8fd84a1-1504-4020-93f7-a550314c1459-image.png"></p><p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p><h1 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p><p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p><h2 id="单行代码分析"><a href="#单行代码分析" class="headerlink" title="单行代码分析"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">getWaterfallRecycler</span>(<span class="params">scroller, container</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Recycler</span>(scroller, <span class="keyword">new</span> <span class="title class_">WaterfallSource</span>(), &#123;</span><br><span class="line">    container,</span><br><span class="line">    <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">NumberRenderer</span>()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p><p>接下来看Recycler的具体实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p><p>我基于作者的注释给与补充</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class="built_in">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化统一 scroller 操作接口</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span> = <span class="keyword">new</span> <span class="title class_">ScrollerOperations</span>(scroller);</span><br><span class="line">        <span class="comment">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">isScrollerValid</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Exceptions</span>.<span class="title class_">TypeError</span>(<span class="string">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroller</span> = scroller;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">        <span class="comment">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认渲染器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">renderer</span> = options.<span class="property">renderer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容纳元素的容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">container</span> = options.<span class="property">container</span> || <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getElement</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶部和底部预留空间</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">topPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">topPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bottomPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">bottomPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动正反方向预渲染元素个数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItems</span> = options.<span class="property">runwayItems</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItemsOpposite</span> = options.<span class="property">runwayItemsOpposite</span> || <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离底部多少个元素时触发加载更多</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">threshold</span> = options.<span class="property">threshold</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br><span class="line">        <span class="comment">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class="line">        <span class="comment">// 稍后会介绍runway</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 Dom 事件监听器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span> = <span class="keyword">new</span> <span class="title class_">ScrollListener</span>(<span class="variable language_">this</span>.<span class="property">scroller</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resizeListener</span> = <span class="keyword">new</span> <span class="title class_">ResizeListener</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撑开滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">sentinel</span>);</span><br><span class="line">        <span class="comment">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据是否启用硬件加速选择模板</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">enableAcceleration</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 container position style</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">container</span>).<span class="property">position</span> === <span class="string">&#x27;static&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哨兵位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">        <span class="comment">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onScroll</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">handleWindowResize</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">resizeListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onResize</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class="line">        <span class="title function_">mapObject</span>(<span class="variable language_">this</span>.<span class="property">runways</span>, <span class="function">(<span class="params">runway</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">execute</span>(<span class="function">() =&gt;</span> runway.<span class="property">source</span>.<span class="title function_">mount</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 可以跳过这一句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 onInitialized</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Initialized</span>, <span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说明constructor中几个重要的步骤。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br></pre></td></tr></table></figure><p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> getInitialRunway&lt;U&gt;(<span class="attr">source</span>: <span class="title class_">ISource</span>&lt;U&gt;): <span class="title class_">IRunway</span>&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstAttachedItem</span>: <span class="number">0</span>, </span><br><span class="line">      <span class="attr">lastAttachedItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">lastScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">requestInProgress</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">runwayMaxScrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">nodes</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">screenNodes</span>: <span class="title function_">newSet</span>(),</span><br><span class="line">      source,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p><p>scrollTop：scroller的scrollTop</p><p>requestInProgress：是否正在请求数据，</p><p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p><p>screenNodes：nodes的缓存</p><p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p><p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p><p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">update</span>(<span class="params">disableRender?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">runwayMaxScrollTop</span> = <span class="variable language_">this</span>.<span class="title function_">getRunwayMaxScrollTop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Update</span>, <span class="variable language_">this</span>, disableRender);</span><br><span class="line">    !disableRender &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">onScroll</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285">onScroll</a></p><p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332">fill</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fixedStart = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, start);</span><br><span class="line"><span class="keyword">const</span> fixedEnd = <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>, end);</span><br></pre></td></tr></table></figure><p>这两句很疑惑，为什么要重新计算start和end呢</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png" alt="d23cee97-7080-4a8f-89b0-24e87b67e522-image.png"></p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh"></p><p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p><p>算出正确的start、end后调用了attachContent。</p><p>attachContent分两步：</p><ol><li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">release</span>(<span class="attr">el</span>: <span class="title class_">HTMLElement</span>, <span class="attr">recycler</span>: <span class="title class_">IRecycler</span>&lt;T&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">using</span>.<span class="title function_">delete</span>(el);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">unused</span>.<span class="title function_">push</span>(el);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用release方法时缓存了废弃的元素。</p><ol start="2"><li>渲染当前滚动屏幕内的元素。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">attachContent</span>(<span class="params">start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> benchNodes = []; <span class="comment">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">changedNodes</span>: <span class="title class_">IChangedNodes</span> = []; <span class="comment">// 有变化的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点是释放在屏幕外的元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeUnusedNodes</span>(start, end, <span class="variable language_">this</span>.<span class="property">isForceUpdate</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isForceUpdate</span> &amp;&amp; runway.<span class="property">nodes</span>[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> renderer = <span class="variable language_">this</span>.<span class="title function_">getRenderer</span>(i);</span><br><span class="line">      <span class="keyword">const</span> data = runway.<span class="property">source</span>.<span class="title function_">getData</span>(i, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用渲染函数，获得一个节点</span></span><br><span class="line">      <span class="comment">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class="line">      <span class="comment">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class="line">      <span class="keyword">const</span> node = runway.<span class="property">nodes</span>[i] = renderer.<span class="title function_">render</span>(data, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向缓存中存入一个节点，用于移除</span></span><br><span class="line">      runway.<span class="property">screenNodes</span>.<span class="title function_">add</span>(node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class="line">      changedNodes.<span class="title function_">push</span>(&#123;node, <span class="attr">index</span>: i&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">parentNode</span> !== <span class="variable language_">this</span>.<span class="property">container</span>) &#123;</span><br><span class="line">        benchNodes.<span class="title function_">push</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量修改节点样式</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setNodesStyles</span>(changedNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量加入元素到容器中</span></span><br><span class="line">    <span class="keyword">while</span> (benchNodes.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">appendChild</span>(benchNodes.<span class="title function_">pop</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许可以加载更多</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">maybeLoadMore</span>(end);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p><p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p><p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p><h1 id="简短的流程"><a href="#简短的流程" class="headerlink" title="简短的流程"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p><p>把attachContent单拎出来。</p><p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p><p>再过滤一遍，核心实现就三步：</p><ol><li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li><li>依据start、end释放屏幕外的元素</li><li>依据start、end更新屏幕内的元素</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getFirstScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt;= scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚动相反</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class="line">        <span class="comment">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class="line">        <span class="comment">// 故加 1</span></span><br><span class="line">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getLastScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果是往上滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) &gt;= scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚相反</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 故减 1</span></span><br><span class="line">      i &gt; <span class="number">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">freeUnusedNodes</span>(<span class="params">start: <span class="built_in">number</span>, end?: <span class="built_in">number</span>, force?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">if</span> (force || start &gt; runway.<span class="property">lastAttachedItem</span> || end &lt; runway.<span class="property">firstAttachedItem</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>), runway.<span class="property">lastAttachedItem</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能处理某种边界情况</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, start);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromEnd</span>(end, runway.<span class="property">lastAttachedItem</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p><p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p><p>所以就库本身来说，性能还是挺高的。</p><p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
