<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何下载腾讯课堂视频</title>
      <link href="/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/"/>
      <url>/2022/02/05/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E8%A7%86%E9%A2%91/</url>
      
        <content type="html"><![CDATA[<p>腾讯课堂“贴心”的给我们提供了回放功能，但是图心理安慰，老想着如何下载下来才安心。（自己看，不传播）</p><p>随便打开一个腾讯课堂视频，比如<a href="https://ke.qq.com/course/2994329?taid=12141623440683161">这个</a> 随便找一个。chrome浏览器右击检查，打开开发者控制台，NetWork面板，再次刷新网页，NetWork筛选m3u8关键词。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png" alt="f4ec5ba9-396e-4fe7-be62-b0c7f54b82f4-image.png"></p><p>这便是该视频不同分辨率的资源，这些链接是不能直接下载的，需要解密，用<a href="https://github.com/nilaoda/N_m3u8DL-CLI/tree/master/N_m3u8DL-CLI">这个</a> 解，貌似c#写的。</p><p>对，没错，我就是搬用工，一点技术含量也没有。</p><p>如果有多个视频需要下载，上述过程略显麻烦。可以移步火狐浏览器，下载Video DownloadHelper 插件，这玩意能直接识别出资源，并且告诉你不同的分辨率，然后还是需要解密m3u8。</p><p>如果需要下载的视频巨多，连用插件copy链接都觉的麻烦，后续看能不能写个爬虫什么的，自动copy链接。然后研究下解密m3u8那工具支不支持批量下载，暂时就这样。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习java内部类</title>
      <link href="/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一个只擅长javascript的伪程序员，学习java还是挺费劲的，不过没关系，再庞然大物，也能分而治之。</p><p>google搜内部类，好多文章都说java有四种内部类。成员内部类，静态内部类、局部内部类、匿名内部类。记性好的可以直接记住，彷佛回到了读书时代。</p><h1 id="四大内部类"><a href="#四大内部类" class="headerlink" title="四大内部类"></a>四大内部类</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>java是一门强大的面向对象编程语言。在java中，一个类的成员变量，可以是字符串、数字这样的基础数据类型，也可以是数组、Map这样的复杂数据类型，甚至可以是别的类的实例，那为什么不能是一个类呢？</p><p>所以把一个类放在java的成员变量位置上，这个类就是成员内部类，放到静态变量位置上，这个类就是静态内部类。</p><p>所以很容易写出这样的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(a); <span class="comment">//标记1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxOuterClass</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>();</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> n.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">//标记2</span></span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java这门语言单从长相上还是挺像typescript的。但是typescript是没有内部类概念的。上面那段代码有几处奇怪的地方，首先是标记1那个孤零零的a变量，实际上java会先找Inner上有没有叫a的成员变量，如果没有，再去找xxxOuterClass。</p><p>再来看标记2，内部类是怎么被实例化的。成员内部类依附于它所对应的外部类，所以需要先实例化一个外部类。这不奇怪，想也能想通，奇怪的是new 操作符就然可以那样使用。按照正常的思维，难道不是xxxOuterClass.Inner m &#x3D; new n.Inner()吗？</p><p>既然一个类可以作为另一个类的成员，那么Inner是否能被访问修饰符修饰呢？实际上分别用public、protected、private修饰Inner，并不报错，只不过用private修饰Inner，在TY中不能实例化Inner。那继承呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TY2</span> <span class="keyword">extends</span> <span class="title class_">xxxOuterClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TY2</span> <span class="variable">ty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TY2</span>();</span><br><span class="line">        TY2.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> ty.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来也是可以的。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxOuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;1212&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cwwd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        xxxOuterClass.<span class="type">Inner</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxOuterClass</span>.Inner();</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和静态变量差不多。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>所谓局部内部类就是说一个类可以写到某个方法内部。 你用学js的思维去学java就感觉特别烦，什么花花草草都要起个名字。这不是理所当然的吗？</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类不是说某个类没有名字，而是说你可以直接继承&#x2F;实现某个类，然后直接new，不用写那么多繁文缛节。通常配合接口与抽象类来使用。看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;xxxFoo2 log&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，在java中，抽象类只能被继承，不能直接实例化，接口只能被实现，不能直接实例化。现在有了特例，除非被用于匿名内部类。</p><p>上面的代码按正常思路应该这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo3</span> <span class="keyword">extends</span> <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">xxxFoo3</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo3</span>();</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">xxxFoo4</span> <span class="keyword">implements</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此，在这个例子中，所谓匿名，确实省了两个名字。但是转念一想，这不是概念冲突嘛，明明抽象类和接口都不能直接实例化，为啥用于匿名内部类就可以。其实匿名内部类是一种语法糖，java编译器会帮忙补齐缺失的语法。稍微改一下上面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">xxxFoo</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">xxxFoo2</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TY</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxFoo</span> <span class="variable">foo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log1&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">xxxFoo2</span> <span class="variable">foo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxFoo2</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log2</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;log2&quot;</span>);</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getClass()); <span class="comment">// class TY$2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        foo.log();</span><br><span class="line">        foo2.log2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，还是会有类，只不过不用开发者操心。</p><h1 id="直接继承内部类"><a href="#直接继承内部类" class="headerlink" title="直接继承内部类"></a>直接继承内部类</h1><p>我们可以先实例化出外部类，然后再实例化出内部类。我们也可以直接继承一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxxxOuter</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">xxxInner</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxxInner2</span> <span class="keyword">extends</span> <span class="title class_">xxxxOuter</span>.xxxInner&#123;</span><br><span class="line">    xxxInner2(xxxxOuter wi)&#123;</span><br><span class="line">        wi.<span class="built_in">super</span>(); <span class="comment">//标记1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">xxxInner2</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">xxxInner2</span>(<span class="keyword">new</span> <span class="title class_">xxxxOuter</span>());</span><br><span class="line">        m.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于成员内部类依赖与外部类，所以xxxInner2的构造函数必须接收一个xxxxOuter的实例，然后调用其super方法。</p><p>但是奇怪的是，在我的idea上wi.super标红了，idea认为wi上没有super这个方法？但却可以运行！为啥这里需要调用wi上的super方法，super不是表示父类&#x2F;父类构造器嘛，xxxxOuter并没有父类，为啥这里不写成wi.constructor()之类的更语义化的api？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习vue-clamp</title>
      <link href="/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/"/>
      <url>/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/Justineo/vue-clamp">项目地址</a></p><p>无意间看到这个库，利用getClientRects与二分法实现多行文字的超出截断，虽说flex更简洁，但是想起我n年前兼容IE时的痛楚，虽说现在不用兼容IE了，但是原理什么的还是忍不住瞅一眼。</p><p>关键是知不知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects">getClientRects</a> 。这玩意兼容性好强大。假如是行内元素调用getClientRects，会返回一个rects集合，这个集合的length就是文本的行数，好简洁，完全不用关心行高什么的。</p><h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><ol><li>tag: 由于内部是由render函数生成的vnode，比起template，tag是可以变的，默认是div。</li><li>autoresize: 内部使用resize-detector这个库监听组件的resize事件，size变化时，更新截断状态。</li><li>max-lines: 最大行数</li><li>max-height: 最大高度。max-height与max-lines指定一个即可。</li><li>ellipsis: 省略符号，默认…</li><li>location: ellipsis的位置，默认end。</li><li>expanded: 初始状态是否展开，默认false。</li></ol><p>slot</p><ol><li>default：默认插槽为文本的实际内容（非展示内容）。</li><li>after&#x2F;before：这俩插槽取其一，关于它们的slot scope后面会说。</li></ol><h1 id="用代码简述原理"><a href="#用代码简述原理" class="headerlink" title="用代码简述原理"></a>用代码简述原理</h1><p>vue组件不好解释，语法灵活&#x2F;随意，各种数据自动响应，计算属性什么的互相依赖，读起来挺爽的，给别人解释可太难了。所以我先写个小而美的clamp，方便理解核心原理。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">      <span class="attr">lines</span>:&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">          <span class="attr">default</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">text</span>:<span class="variable language_">this</span>.<span class="title function_">getText</span>(),</span><br><span class="line">            <span class="attr">offsetSet</span>: <span class="variable language_">this</span>.<span class="title function_">getText</span>().<span class="property">length</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> [content] = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">ref</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;content&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">search</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">search</span>(<span class="params"><span class="keyword">from</span>=<span class="number">0</span>,to=<span class="variable language_">this</span>.text.length</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(to-<span class="keyword">from</span>&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">offset</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="keyword">from</span> + to) / <span class="number">2</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">text</span>.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isOverflow</span>())&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="keyword">from</span>,<span class="variable language_">this</span>.<span class="property">offset</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">search</span>(<span class="variable language_">this</span>.<span class="property">offset</span>,to)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getText</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> [content] = (<span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> || []).<span class="title function_">filter</span>(</span><br><span class="line">                <span class="function">(<span class="params">node</span>) =&gt;</span> !node.<span class="property">tag</span> &amp;&amp; !node.<span class="property">isComment</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> content ? content.<span class="property">text</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">getLines</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">text</span>.<span class="title function_">getClientRects</span>().<span class="property">length</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">isOverflow</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getLines</span>() &gt; <span class="variable language_">this</span>.<span class="property">lines</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个props（lines：表示文本的行数），data里面有两个属性text与offset，text表示原始的文本，offset是个信标，表示发生截断的位置，只要offset不等于text的长度，就认为文本发生了截断。</p><p>render函数里面拿到了默认插槽的vnode，并用span渲染出来，为什么是span，因为只有行内元素调用getClientRects才会返回文本长度。从这里还可以看出，插槽与渲染竟然可以分开！！<br>第一次渲染会渲染出全部文本，在mounted里面通过isOverflow判断是否溢出，即文本的实际行数是否大于props.lines，如果发生了溢出，调用search方法，search方法使用了二分法不停的改变offset的位置，直到from与to的差值小于等于3，为什么是3呢，我猜是省略号(…)的长度，这样就算出了最佳的offset以及最佳的截断文本。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>源码与我那个有什么不同：</p><ol><li>支持更多的props</li><li>检测元素的尺寸是否发生变化</li><li>支持更多的插槽</li></ol><p>可以自定义tag，设置是否检测元素的尺寸变化，是否以maxHeight代替maxLines，设置省略号的文本（默认是…），以及省略号的位置。expanded设置初次渲染是否展开文本.</p><p>先从render函数看起。<br><a href="https://github.com/Justineo/vue-clamp/blob/master/src/components/Clamp.js#L227">render</a><br>整体来看，多了before与after插槽的逻辑，before与after取其一。值得注意的是this.$scopedSlots这个api，作用域插槽在render函数里面竟然是这样用的，scope就是传递给插槽的作用域，this.$scopedSlots.before&#x2F;afer(scope)的结果是vnode。然后竟然可以把组件的方法传给scope，又学到了。</p><p>mounted调用init，init内部有一些是否检测元素尺寸变化的逻辑，用了resize-detector，这个库也是作者写的，init最终调用update。update开篇有个localExpanded，这个就是props.expanded，内部写了几个watch来同步两者的状态。然后调用search，和上面的精简版不一样的是多了个stepToFit方法，这个方法的作用是微调offset，即在用二分法得到最终的文本后，最后一行文本的长度可能不满一行，先调用fill方法使文本充满一行（可能发生换行），然后调用clamp方法使文本刚好充满一行。</p><p>原理就是这样。看一下github上的demo。</p><p>before&#x2F;after插槽是个button，点击button调用了toggle方法。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toggle () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">localExpanded</span> = !<span class="variable language_">this</span>.<span class="property">localExpanded</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这句话会触发localExpanded的watch</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (val) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clampAt</span>(<span class="variable language_">this</span>.<span class="property">text</span>.<span class="property">length</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果localExpanded为true，还原文本，否则，重新截断文本。</p><p>最后，值得注意的是mounted里面的watch写法</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$watch(</span><br><span class="line">  <span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">maxLines</span>, vm.<span class="property">maxHeight</span>, vm.<span class="property">ellipsis</span>, vm.<span class="property">isClamped</span>].<span class="title function_">join</span>(),</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">update</span></span><br><span class="line">)</span><br><span class="line"><span class="variable language_">this</span>.$watch(<span class="function">(<span class="params">vm</span>) =&gt;</span> [vm.<span class="property">tag</span>, vm.<span class="property">text</span>, vm.<span class="property">autoresize</span>].<span class="title function_">join</span>(), <span class="variable language_">this</span>.<span class="property">init</span>)</span><br></pre></td></tr></table></figure><p>又学到了，这种做法可以同时watch多个参数，执行相同的逻辑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习react-whether</title>
      <link href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/"/>
      <url>/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在用react写业务时，常常要处理一些条件逻辑，由于jsx里面只有写表达式，不能写语句，所以有时不得不写一大坨这样的代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么像这样把大片逻辑封装成组件，要么写个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &#123;<span class="variable language_">this</span>.<span class="title function_">renderComponent</span>()&#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">renderComponent</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> isMatch ? <span class="language-xml"><span class="tag">&lt;<span class="name">CommentA</span>/&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">CommentB</span>/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不完美，有时候并不想凭空写一个方法或者封装组件，并且代码可读性也不好。</p><p>那么有没有更优雅的方法，当然有，所谓前人栽树，后人乘凉，我们只要虚心学习就可以了。</p><p><a href="https://github.com/otakustay/react-whether">react-whether</a> ,看文档可以去这里，本文介绍的是其源码。</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>首先打开src&#x2F;index.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Whether</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Whether&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Match</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Match&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Else</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./Else&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从文档可以看出<a href="https://github.com/otakustay/react-whether/blob/master/src/Whether.tsx">Whether</a> 是其root component。</p><p>从代码可以看出Whether本质上是一个函数式组件，除了children，接收matches和context两个prop。</p><p>代码开篇判断matches是不是一个boolean，本质上是在判断有没有传matches，如果matches是个boolean，走的是IfElseMode或者IfMode，否则走的是SwitchMode。</p><p>通过计算Whether的children的数量count，来判断是IfElseMode或者IfMode，如果count &lt;&#x3D; 1,走的是IfMode，如果count &gt; 1 并且chidren的最后一项是else，走的是IfElseMode，否则走的是IfMode。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/IfMode.tsx">IfMode</a><br><a href="https://github.com/otakustay/react-whether/blob/master/src/IfElseMode.tsx">IfElseMode</a></p><p>这俩货代码很相似，内部都调用了Render组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Render</span>&gt;&#123;matches ? children : <span class="literal">null</span>&#125;&lt;<span class="regexp">/Render&gt; /</span><span class="regexp">/IfMode</span></span><br><span class="line"><span class="regexp">&lt;Render&gt;&#123;matches ? ifChildren : elseChildren&#125;&lt;/</span><span class="title class_">Render</span>&gt; <span class="comment">//IfElseMode</span></span><br></pre></td></tr></table></figure><p>这是只传matches的情况，接下来看只传context的情况，也就是switchMode</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> matches !== <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> elements = <span class="title class_">Children</span>.<span class="title function_">toArray</span>(children) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;&gt;;</span><br><span class="line">        <span class="keyword">const</span> branches = elements.<span class="title function_">map</span>(elementToBranch);</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SwitchMode</span> <span class="attr">context</span>=<span class="string">&#123;context&#125;</span> <span class="attr">branches</span>=<span class="string">&#123;branches&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elementToBranch = (&#123;<span class="keyword">type</span>, props&#125;: <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt;): <span class="title class_">MatchProp</span> | <span class="function"><span class="params">BranchPropWithSelector</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">Match</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> props;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">selector</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">children</span>: props.<span class="property">children</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>elementToBranch 的作用是整合props与children，生成统一的branches，因为children可能是Match，也可能不是。最后调用SwitchMode组件。</p><p><a href="https://github.com/otakustay/react-whether/blob/master/src/SwitchMode.tsx">SwitchMode</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SwitchMode</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">SwitchModeProp</span>&gt; = <span class="function">(<span class="params">&#123;context, branches&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> branch = branches.<span class="title function_">find</span>(<span class="function">(<span class="params">&#123;selector&#125;</span>) =&gt;</span> <span class="title function_">selector</span>(context));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Render</span>&gt;</span>&#123;branch ? branch.children : null&#125;<span class="tag">&lt;/<span class="name">Render</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码与ifMode很相似，唯一的区别是多了个branch，这里用find方法很巧妙。假如我代码这么写。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [user,changeUser] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Whether</span> <span class="attr">context</span>=<span class="string">&#123;user&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;foo&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Match</span> <span class="attr">selector</span>=<span class="string">&#123;user</span>=&gt;</span>user.type === &#x27;bar&#x27;&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                111</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Match</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                else</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Else</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Whether</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照elementToBranch的逻辑，假如children的某一项不是Match，会生成返回true的selector函数，但是数组的find方法永远只返回第一个符合条件的值。所以最后一项是不是Else组件根本不重要，写成div也可以，关键是顺序。</p><p>最后看一下三个mode都用到的Render组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Render</span>: <span class="title class_">React</span>.<span class="property">SFC</span>&lt;<span class="title class_">RenderProp</span>&gt; = (&#123;children&#125;): <span class="title class_">React</span>.<span class="property">ReactElement</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;isRenderFunc(children) ? children() : children&#125;<span class="tag">&lt;/&gt;</span></span>; <span class="comment">//懒加载的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习recycler-view</title>
      <link href="/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/"/>
      <url>/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p><p><a href="https://github.com/hdcoo/recycler-view">https://github.com/hdcoo/recycler-view</a></p><h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>先去<a href="https://github.com/hdcoo/recycler-view-demo">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a href="http://localhost:5211/recycler-view-demo/%EF%BC%8C">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p><p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p><iframe src="https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>可是这个库的布局是这样的</p><iframe src="https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p><p>回到官方的两列瀑布流例子</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy"></p><p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png" alt="d8fd84a1-1504-4020-93f7-a550314c1459-image.png"></p><p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p><h1 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p><p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p><h2 id="单行代码分析"><a href="#单行代码分析" class="headerlink" title="单行代码分析"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">getWaterfallRecycler</span>(<span class="params">scroller, container</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Recycler</span>(scroller, <span class="keyword">new</span> <span class="title class_">WaterfallSource</span>(), &#123;</span><br><span class="line">    container,</span><br><span class="line">    <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">NumberRenderer</span>()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p><p>接下来看Recycler的具体实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p><p>我基于作者的注释给与补充</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Recycler</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">EventEmitter</span> <span class="keyword">implements</span> <span class="title class_">IRecycler</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class="built_in">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化统一 scroller 操作接口</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span> = <span class="keyword">new</span> <span class="title class_">ScrollerOperations</span>(scroller);</span><br><span class="line">        <span class="comment">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">isScrollerValid</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="title class_">Exceptions</span>.<span class="title class_">TypeError</span>(<span class="string">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scroller</span> = scroller;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">        <span class="comment">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认渲染器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">renderer</span> = options.<span class="property">renderer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容纳元素的容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">container</span> = options.<span class="property">container</span> || <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getElement</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶部和底部预留空间</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">topPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">topPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bottomPreserved</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(options.<span class="property">bottomPreserved</span> || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动正反方向预渲染元素个数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItems</span> = options.<span class="property">runwayItems</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">runwayItemsOpposite</span> = options.<span class="property">runwayItemsOpposite</span> || <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离底部多少个元素时触发加载更多</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">threshold</span> = options.<span class="property">threshold</span> || <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br><span class="line">        <span class="comment">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class="line">        <span class="comment">// 稍后会介绍runway</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 Dom 事件监听器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span> = <span class="keyword">new</span> <span class="title class_">ScrollListener</span>(<span class="variable language_">this</span>.<span class="property">scroller</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resizeListener</span> = <span class="keyword">new</span> <span class="title class_">ResizeListener</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撑开滚动容器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sentinel</span>.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">sentinel</span>);</span><br><span class="line">        <span class="comment">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据是否启用硬件加速选择模板</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">enableAcceleration</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">transformTemplate</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 container position style</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">this</span>.<span class="property">container</span>).<span class="property">position</span> === <span class="string">&#x27;static&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哨兵位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">        <span class="comment">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onScroll</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">handleWindowResize</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">resizeListener</span>.<span class="title function_">on</span>(<span class="variable language_">this</span>.<span class="property">onResize</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class="line">        <span class="title function_">mapObject</span>(<span class="variable language_">this</span>.<span class="property">runways</span>, <span class="function">(<span class="params">runway</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">execute</span>(<span class="function">() =&gt;</span> runway.<span class="property">source</span>.<span class="title function_">mount</span>(<span class="variable language_">this</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 可以跳过这一句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 onInitialized</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Initialized</span>, <span class="variable language_">this</span>));</span><br><span class="line">        <span class="comment">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说明constructor中几个重要的步骤。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">initRunways</span>(sources);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">activatedRunway</span> = <span class="title class_">Recycler</span>.<span class="title function_">getDefaultRunwayKey</span>(sources);</span><br></pre></td></tr></table></figure><p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> getInitialRunway&lt;U&gt;(<span class="attr">source</span>: <span class="title class_">ISource</span>&lt;U&gt;): <span class="title class_">IRunway</span>&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstAttachedItem</span>: <span class="number">0</span>, </span><br><span class="line">      <span class="attr">lastAttachedItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">lastScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">requestInProgress</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">runwayMaxScrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">nodes</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">screenNodes</span>: <span class="title function_">newSet</span>(),</span><br><span class="line">      source,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p><p>scrollTop：scroller的scrollTop</p><p>requestInProgress：是否正在请求数据，</p><p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p><p>screenNodes：nodes的缓存</p><p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p><p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p><p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">update</span>(<span class="params">disableRender?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scrollerHeight</span> = <span class="variable language_">this</span>.<span class="property">scrollerOperations</span>.<span class="title function_">getOffsetHeight</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getRunway</span>().<span class="property">runwayMaxScrollTop</span> = <span class="variable language_">this</span>.<span class="title function_">getRunwayMaxScrollTop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setSentinelPosition</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="title class_">Recycler</span>.<span class="property">Events</span>.<span class="property">Update</span>, <span class="variable language_">this</span>, disableRender);</span><br><span class="line">    !disableRender &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">onScroll</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285">onScroll</a></p><p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p><p><a href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332">fill</a></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fixedStart = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, start);</span><br><span class="line"><span class="keyword">const</span> fixedEnd = <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>, end);</span><br></pre></td></tr></table></figure><p>这两句很疑惑，为什么要重新计算start和end呢</p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png" alt="d23cee97-7080-4a8f-89b0-24e87b67e522-image.png"></p><p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh"></p><p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p><p>算出正确的start、end后调用了attachContent。</p><p>attachContent分两步：</p><ol><li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">release</span>(<span class="attr">el</span>: <span class="title class_">HTMLElement</span>, <span class="attr">recycler</span>: <span class="title class_">IRecycler</span>&lt;T&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">using</span>.<span class="title function_">delete</span>(el);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">unused</span>.<span class="title function_">push</span>(el);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用release方法时缓存了废弃的元素。</p><ol start="2"><li>渲染当前滚动屏幕内的元素。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">attachContent</span>(<span class="params">start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> benchNodes = []; <span class="comment">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">changedNodes</span>: <span class="title class_">IChangedNodes</span> = []; <span class="comment">// 有变化的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点是释放在屏幕外的元素</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeUnusedNodes</span>(start, end, <span class="variable language_">this</span>.<span class="property">isForceUpdate</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isForceUpdate</span> &amp;&amp; runway.<span class="property">nodes</span>[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> renderer = <span class="variable language_">this</span>.<span class="title function_">getRenderer</span>(i);</span><br><span class="line">      <span class="keyword">const</span> data = runway.<span class="property">source</span>.<span class="title function_">getData</span>(i, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用渲染函数，获得一个节点</span></span><br><span class="line">      <span class="comment">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class="line">      <span class="comment">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class="line">      <span class="keyword">const</span> node = runway.<span class="property">nodes</span>[i] = renderer.<span class="title function_">render</span>(data, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向缓存中存入一个节点，用于移除</span></span><br><span class="line">      runway.<span class="property">screenNodes</span>.<span class="title function_">add</span>(node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class="line">      changedNodes.<span class="title function_">push</span>(&#123;node, <span class="attr">index</span>: i&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">parentNode</span> !== <span class="variable language_">this</span>.<span class="property">container</span>) &#123;</span><br><span class="line">        benchNodes.<span class="title function_">push</span>(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量修改节点样式</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setNodesStyles</span>(changedNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量加入元素到容器中</span></span><br><span class="line">    <span class="keyword">while</span> (benchNodes.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">container</span>.<span class="title function_">appendChild</span>(benchNodes.<span class="title function_">pop</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许可以加载更多</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">maybeLoadMore</span>(end);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p><p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p><p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p><h1 id="简短的流程"><a href="#简短的流程" class="headerlink" title="简短的流程"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p><p>把attachContent单拎出来。</p><p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p><p>再过滤一遍，核心实现就三步：</p><ol><li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li><li>依据start、end释放屏幕外的元素</li><li>依据start、end更新屏幕内的元素</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getFirstScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &lt;= scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚动相反</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) + runway.<span class="property">source</span>.<span class="title function_">getHeight</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class="line">        <span class="comment">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class="line">        <span class="comment">// 故加 1</span></span><br><span class="line">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">getLastScreenItem</span>(<span class="attr">initialAnchorItem</span>: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果是往上滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(i, <span class="variable language_">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(--i, <span class="variable language_">this</span>) &gt;= scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚相反</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class="property">source</span>.<span class="title function_">getScrollTop</span>(++i, <span class="variable language_">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 故减 1</span></span><br><span class="line">      i &gt; <span class="number">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">freeUnusedNodes</span>(<span class="params">start: <span class="built_in">number</span>, end?: <span class="built_in">number</span>, force?: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="variable language_">this</span>.<span class="title function_">getRunway</span>();</span><br><span class="line">    <span class="keyword">if</span> (force || start &gt; runway.<span class="property">lastAttachedItem</span> || end &lt; runway.<span class="property">firstAttachedItem</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(runway.<span class="property">source</span>.<span class="title function_">getLength</span>(<span class="variable language_">this</span>), runway.<span class="property">lastAttachedItem</span> + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能处理某种边界情况</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromStart</span>(runway.<span class="property">firstAttachedItem</span>, start);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">freeNodesFromEnd</span>(end, runway.<span class="property">lastAttachedItem</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p><p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p><p>所以就库本身来说，性能还是挺高的。</p><p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
