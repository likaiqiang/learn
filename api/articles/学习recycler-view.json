{"title":"学习recycler-view","slug":"学习recycler-view","date":"2021-11-20T23:36:13.000Z","updated":"2022-04-17T14:09:18.769Z","comments":true,"path":"api/articles/学习recycler-view.json","excerpt":null,"covers":["https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy","https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png","https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png","https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh"],"content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view\">https://github.com/hdcoo/recycler-view</a></p>\n<h1 id=\"大概原理\"><a href=\"#大概原理\" class=\"headerlink\" title=\"大概原理\"></a>大概原理</h1><p>先去<a href=\"https://github.com/hdcoo/recycler-view-demo\">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a href=\"http://localhost:5211/recycler-view-demo/%EF%BC%8C\">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p>\n<p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p>\n<iframe src=\"https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark\" title=\"awesome-mestorf-nb8r2\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>可是这个库的布局是这样的</p>\n<iframe src=\"https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark\" title=\"awesome-mestorf-nb8r2\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p>\n<p>回到官方的两列瀑布流例子</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy\"></p>\n<p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png\" alt=\"d8fd84a1-1504-4020-93f7-a550314c1459-image.png\"></p>\n<p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p>\n<h1 id=\"具体的代码实现\"><a href=\"#具体的代码实现\" class=\"headerlink\" title=\"具体的代码实现\"></a>具体的代码实现</h1><h2 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p>\n<p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p>\n<h2 id=\"单行代码分析\"><a href=\"#单行代码分析\" class=\"headerlink\" title=\"单行代码分析\"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getWaterfallRecycler</span>(<span class=\"params\">scroller, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>(scroller, <span class=\"keyword\">new</span> <span class=\"title class_\">WaterfallSource</span>(), &#123;</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"attr\">renderer</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">NumberRenderer</span>()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p>\n<p>接下来看Recycler的具体实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">EventEmitter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRecycler</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p>\n<p>我基于作者的注释给与补充</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">EventEmitter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRecycler</span>&lt;T&gt;&#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class=\"built_in\">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化统一 scroller 操作接口</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ScrollerOperations</span>(scroller);</span><br><span class=\"line\">        <span class=\"comment\">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">isScrollerValid</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"title class_\">Exceptions</span>.<span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 滚动容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scroller</span> = scroller;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerHeight</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getOffsetHeight</span>();</span><br><span class=\"line\">        <span class=\"comment\">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 默认渲染器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">renderer</span> = options.<span class=\"property\">renderer</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 容纳元素的容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">container</span> = options.<span class=\"property\">container</span> || <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getElement</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顶部和底部预留空间</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">topPreserved</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(options.<span class=\"property\">topPreserved</span> || <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">bottomPreserved</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(options.<span class=\"property\">bottomPreserved</span> || <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 滚动正反方向预渲染元素个数</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">runwayItems</span> = options.<span class=\"property\">runwayItems</span> || <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">runwayItemsOpposite</span> = options.<span class=\"property\">runwayItemsOpposite</span> || <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 距离底部多少个元素时触发加载更多</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">threshold</span> = options.<span class=\"property\">threshold</span> || <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">initRunways</span>(sources);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">activatedRunway</span> = <span class=\"title class_\">Recycler</span>.<span class=\"title function_\">getDefaultRunwayKey</span>(sources);</span><br><span class=\"line\">        <span class=\"comment\">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class=\"line\">        <span class=\"comment\">// 稍后会介绍runway</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始化 Dom 事件监听器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollListener</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ScrollListener</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">scroller</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resizeListener</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ResizeListener</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 撑开滚动容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">position</span> = <span class=\"string\">&#x27;absolute&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">width</span> = <span class=\"string\">&#x27;1px&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">height</span> = <span class=\"string\">&#x27;1px&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>);</span><br><span class=\"line\">        <span class=\"comment\">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据是否启用硬件加速选择模板</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">enableAcceleration</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">transformTemplate</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"string\">`translate3d(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">transformTemplate</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"string\">`translate(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>px)`</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化 container position style</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">window</span>.<span class=\"title function_\">getComputedStyle</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">container</span>).<span class=\"property\">position</span> === <span class=\"string\">&#x27;static&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"property\">style</span>.<span class=\"property\">position</span> = <span class=\"string\">&#x27;relative&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化哨兵位置</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">setSentinelPosition</span>();</span><br><span class=\"line\">        <span class=\"comment\">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollListener</span>.<span class=\"title function_\">on</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">onScroll</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">handleWindowResize</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">resizeListener</span>.<span class=\"title function_\">on</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">onResize</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class=\"line\">        <span class=\"title function_\">mapObject</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">runways</span>, <span class=\"function\">(<span class=\"params\">runway</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">execute</span>(<span class=\"function\">() =&gt;</span> runway.<span class=\"property\">source</span>.<span class=\"title function_\">mount</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 可以跳过这一句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>().<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">update</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 onInitialized</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">emit</span>(<span class=\"title class_\">Recycler</span>.<span class=\"property\">Events</span>.<span class=\"property\">Initialized</span>, <span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        <span class=\"comment\">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来说明constructor中几个重要的步骤。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">initRunways</span>(sources);</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">activatedRunway</span> = <span class=\"title class_\">Recycler</span>.<span class=\"title function_\">getDefaultRunwayKey</span>(sources);</span><br></pre></td></tr></table></figure>\n<p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> getInitialRunway&lt;U&gt;(<span class=\"attr\">source</span>: <span class=\"title class_\">ISource</span>&lt;U&gt;): <span class=\"title class_\">IRunway</span>&lt;U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">scrollTop</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">firstAttachedItem</span>: <span class=\"number\">0</span>, </span><br><span class=\"line\">      <span class=\"attr\">lastAttachedItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">firstScreenItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">lastScreenItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">requestInProgress</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">runwayMaxScrollTop</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">nodes</span>: &#123;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">screenNodes</span>: <span class=\"title function_\">newSet</span>(),</span><br><span class=\"line\">      source,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p>\n<p>scrollTop：scroller的scrollTop</p>\n<p>requestInProgress：是否正在请求数据，</p>\n<p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p>\n<p>screenNodes：nodes的缓存</p>\n<p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p>\n<p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p>\n<p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">update</span>()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">update</span>(<span class=\"params\">disableRender?: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerHeight</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getOffsetHeight</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>().<span class=\"property\">runwayMaxScrollTop</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunwayMaxScrollTop</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setSentinelPosition</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">emit</span>(<span class=\"title class_\">Recycler</span>.<span class=\"property\">Events</span>.<span class=\"property\">Update</span>, <span class=\"variable language_\">this</span>, disableRender);</span><br><span class=\"line\">    !disableRender &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">onScroll</span>();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285\">onScroll</a></p>\n<p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332\">fill</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fixedStart = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"number\">0</span>, start);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fixedEnd = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>, end);</span><br></pre></td></tr></table></figure>\n<p>这两句很疑惑，为什么要重新计算start和end呢</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png\" alt=\"d23cee97-7080-4a8f-89b0-24e87b67e522-image.png\"></p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh\"></p>\n<p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p>\n<p>算出正确的start、end后调用了attachContent。</p>\n<p>attachContent分两步：</p>\n<ol>\n<li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">release</span>(<span class=\"attr\">el</span>: <span class=\"title class_\">HTMLElement</span>, <span class=\"attr\">recycler</span>: <span class=\"title class_\">IRecycler</span>&lt;T&gt;): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">queue</span>.<span class=\"property\">using</span>.<span class=\"title function_\">delete</span>(el);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">queue</span>.<span class=\"property\">unused</span>.<span class=\"title function_\">push</span>(el);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>调用release方法时缓存了废弃的元素。</p>\n<ol start=\"2\">\n<li>渲染当前滚动屏幕内的元素。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">attachContent</span>(<span class=\"params\">start: <span class=\"built_in\">number</span>, end: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> benchNodes = []; <span class=\"comment\">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">changedNodes</span>: <span class=\"title class_\">IChangedNodes</span> = []; <span class=\"comment\">// 有变化的节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重点是释放在屏幕外的元素</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeUnusedNodes</span>(start, end, <span class=\"variable language_\">this</span>.<span class=\"property\">isForceUpdate</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">isForceUpdate</span> &amp;&amp; runway.<span class=\"property\">nodes</span>[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> renderer = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRenderer</span>(i);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> data = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getData</span>(i, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 调用渲染函数，获得一个节点</span></span><br><span class=\"line\">      <span class=\"comment\">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = runway.<span class=\"property\">nodes</span>[i] = renderer.<span class=\"title function_\">render</span>(data, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 向缓存中存入一个节点，用于移除</span></span><br><span class=\"line\">      runway.<span class=\"property\">screenNodes</span>.<span class=\"title function_\">add</span>(node);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class=\"line\">      changedNodes.<span class=\"title function_\">push</span>(&#123;node, <span class=\"attr\">index</span>: i&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">parentNode</span> !== <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>) &#123;</span><br><span class=\"line\">        benchNodes.<span class=\"title function_\">push</span>(node);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 批量修改节点样式</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNodesStyles</span>(changedNodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 批量加入元素到容器中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (benchNodes.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">appendChild</span>(benchNodes.<span class=\"title function_\">pop</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 也许可以加载更多</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">maybeLoadMore</span>(end);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p>\n<p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p>\n<p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p>\n<h1 id=\"简短的流程\"><a href=\"#简短的流程\" class=\"headerlink\" title=\"简短的流程\"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p>\n<p>把attachContent单拎出来。</p>\n<p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p>\n<p>再过滤一遍，核心实现就三步：</p>\n<ol>\n<li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li>\n<li>依据start、end释放屏幕外的元素</li>\n<li>依据start、end更新屏幕内的元素</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">getFirstScreenItem</span>(<span class=\"attr\">initialAnchorItem</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">scrollTop</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = initialAnchorItem;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sourceLastIndex = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &lt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(++i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &lt;= scrollTop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与往上滚动相反</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(--i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &gt; scrollTop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 故加 1</span></span><br><span class=\"line\">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class=\"number\">0</span> &amp;&amp; ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">getLastScreenItem</span>(<span class=\"attr\">initialAnchorItem</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">scrollTop</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = initialAnchorItem;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sourceLastIndex = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是往上滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(i, <span class=\"variable language_\">this</span>) &gt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(--i, <span class=\"variable language_\">this</span>) &gt;= scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与往上滚相反</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(++i, <span class=\"variable language_\">this</span>) &lt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class=\"line\">      <span class=\"comment\">// 故减 1</span></span><br><span class=\"line\">      i &gt; <span class=\"number\">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">freeUnusedNodes</span>(<span class=\"params\">start: <span class=\"built_in\">number</span>, end?: <span class=\"built_in\">number</span>, force?: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (force || start &gt; runway.<span class=\"property\">lastAttachedItem</span> || end &lt; runway.<span class=\"property\">firstAttachedItem</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromStart</span>(runway.<span class=\"property\">firstAttachedItem</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>), runway.<span class=\"property\">lastAttachedItem</span> + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可能处理某种边界情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromStart</span>(runway.<span class=\"property\">firstAttachedItem</span>, start);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromEnd</span>(end, runway.<span class=\"property\">lastAttachedItem</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p>\n<p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p>\n<p>所以就库本身来说，性能还是挺高的。</p>\n<p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>\n","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view\">https://github.com/hdcoo/recycler-view</a></p>\n<h1 id=\"大概原理\"><a href=\"#大概原理\" class=\"headerlink\" title=\"大概原理\"></a>大概原理</h1><p>先去<a href=\"https://github.com/hdcoo/recycler-view-demo\">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a href=\"http://localhost:5211/recycler-view-demo/%EF%BC%8C\">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p>\n<p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p>\n<iframe src=\"https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark\" title=\"awesome-mestorf-nb8r2\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>可是这个库的布局是这样的</p>\n<iframe src=\"https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark\" title=\"awesome-mestorf-nb8r2\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p>\n<p>回到官方的两列瀑布流例子</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy\"></p>\n<p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png\" alt=\"d8fd84a1-1504-4020-93f7-a550314c1459-image.png\"></p>\n<p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p>\n<h1 id=\"具体的代码实现\"><a href=\"#具体的代码实现\" class=\"headerlink\" title=\"具体的代码实现\"></a>具体的代码实现</h1><h2 id=\"整体设计\"><a href=\"#整体设计\" class=\"headerlink\" title=\"整体设计\"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p>\n<p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p>\n<h2 id=\"单行代码分析\"><a href=\"#单行代码分析\" class=\"headerlink\" title=\"单行代码分析\"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getWaterfallRecycler</span>(<span class=\"params\">scroller, container</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>(scroller, <span class=\"keyword\">new</span> <span class=\"title class_\">WaterfallSource</span>(), &#123;</span><br><span class=\"line\">    container,</span><br><span class=\"line\">    <span class=\"attr\">renderer</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">NumberRenderer</span>()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p>\n<p>接下来看Recycler的具体实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">EventEmitter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRecycler</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p>\n<p>我基于作者的注释给与补充</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">EventEmitter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">IRecycler</span>&lt;T&gt;&#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class=\"built_in\">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化统一 scroller 操作接口</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ScrollerOperations</span>(scroller);</span><br><span class=\"line\">        <span class=\"comment\">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">isScrollerValid</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"title class_\">Exceptions</span>.<span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 滚动容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scroller</span> = scroller;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerHeight</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getOffsetHeight</span>();</span><br><span class=\"line\">        <span class=\"comment\">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 默认渲染器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">renderer</span> = options.<span class=\"property\">renderer</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 容纳元素的容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">container</span> = options.<span class=\"property\">container</span> || <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getElement</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 顶部和底部预留空间</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">topPreserved</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(options.<span class=\"property\">topPreserved</span> || <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">bottomPreserved</span> = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(options.<span class=\"property\">bottomPreserved</span> || <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 滚动正反方向预渲染元素个数</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">runwayItems</span> = options.<span class=\"property\">runwayItems</span> || <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">runwayItemsOpposite</span> = options.<span class=\"property\">runwayItemsOpposite</span> || <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 距离底部多少个元素时触发加载更多</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">threshold</span> = options.<span class=\"property\">threshold</span> || <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">initRunways</span>(sources);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">activatedRunway</span> = <span class=\"title class_\">Recycler</span>.<span class=\"title function_\">getDefaultRunwayKey</span>(sources);</span><br><span class=\"line\">        <span class=\"comment\">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class=\"line\">        <span class=\"comment\">// 稍后会介绍runway</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 初始化 Dom 事件监听器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollListener</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ScrollListener</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">scroller</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resizeListener</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">ResizeListener</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 撑开滚动容器</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">position</span> = <span class=\"string\">&#x27;absolute&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">width</span> = <span class=\"string\">&#x27;1px&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>.<span class=\"property\">style</span>.<span class=\"property\">height</span> = <span class=\"string\">&#x27;1px&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">sentinel</span>);</span><br><span class=\"line\">        <span class=\"comment\">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 根据是否启用硬件加速选择模板</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">enableAcceleration</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">transformTemplate</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"string\">`translate3d(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">transformTemplate</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"string\">`translate(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>px)`</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化 container position style</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">window</span>.<span class=\"title function_\">getComputedStyle</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">container</span>).<span class=\"property\">position</span> === <span class=\"string\">&#x27;static&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"property\">style</span>.<span class=\"property\">position</span> = <span class=\"string\">&#x27;relative&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化哨兵位置</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">setSentinelPosition</span>();</span><br><span class=\"line\">        <span class=\"comment\">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">scrollListener</span>.<span class=\"title function_\">on</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">onScroll</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.<span class=\"property\">handleWindowResize</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">resizeListener</span>.<span class=\"title function_\">on</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">onResize</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class=\"line\">        <span class=\"title function_\">mapObject</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">runways</span>, <span class=\"function\">(<span class=\"params\">runway</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_\">execute</span>(<span class=\"function\">() =&gt;</span> runway.<span class=\"property\">source</span>.<span class=\"title function_\">mount</span>(<span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 可以跳过这一句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>().<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">update</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 onInitialized</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">emit</span>(<span class=\"title class_\">Recycler</span>.<span class=\"property\">Events</span>.<span class=\"property\">Initialized</span>, <span class=\"variable language_\">this</span>));</span><br><span class=\"line\">        <span class=\"comment\">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来说明constructor中几个重要的步骤。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">initRunways</span>(sources);</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">activatedRunway</span> = <span class=\"title class_\">Recycler</span>.<span class=\"title function_\">getDefaultRunwayKey</span>(sources);</span><br></pre></td></tr></table></figure>\n<p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> getInitialRunway&lt;U&gt;(<span class=\"attr\">source</span>: <span class=\"title class_\">ISource</span>&lt;U&gt;): <span class=\"title class_\">IRunway</span>&lt;U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">scrollTop</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">firstAttachedItem</span>: <span class=\"number\">0</span>, </span><br><span class=\"line\">      <span class=\"attr\">lastAttachedItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">firstScreenItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">lastScreenItem</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">requestInProgress</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">runwayMaxScrollTop</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">      <span class=\"attr\">nodes</span>: &#123;&#125;,</span><br><span class=\"line\">      <span class=\"attr\">screenNodes</span>: <span class=\"title function_\">newSet</span>(),</span><br><span class=\"line\">      source,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p>\n<p>scrollTop：scroller的scrollTop</p>\n<p>requestInProgress：是否正在请求数据，</p>\n<p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p>\n<p>screenNodes：nodes的缓存</p>\n<p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p>\n<p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p>\n<p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">update</span>()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">update</span>(<span class=\"params\">disableRender?: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerHeight</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">scrollerOperations</span>.<span class=\"title function_\">getOffsetHeight</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>().<span class=\"property\">runwayMaxScrollTop</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunwayMaxScrollTop</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setSentinelPosition</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">emit</span>(<span class=\"title class_\">Recycler</span>.<span class=\"property\">Events</span>.<span class=\"property\">Update</span>, <span class=\"variable language_\">this</span>, disableRender);</span><br><span class=\"line\">    !disableRender &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"title function_\">onScroll</span>();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285\">onScroll</a></p>\n<p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p>\n<p><a href=\"https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332\">fill</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fixedStart = <span class=\"title class_\">Math</span>.<span class=\"title function_\">max</span>(<span class=\"number\">0</span>, start);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fixedEnd = <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>, end);</span><br></pre></td></tr></table></figure>\n<p>这两句很疑惑，为什么要重新计算start和end呢</p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png\" alt=\"d23cee97-7080-4a8f-89b0-24e87b67e522-image.png\"></p>\n<p><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh\"></p>\n<p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p>\n<p>算出正确的start、end后调用了attachContent。</p>\n<p>attachContent分两步：</p>\n<ol>\n<li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">release</span>(<span class=\"attr\">el</span>: <span class=\"title class_\">HTMLElement</span>, <span class=\"attr\">recycler</span>: <span class=\"title class_\">IRecycler</span>&lt;T&gt;): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">queue</span>.<span class=\"property\">using</span>.<span class=\"title function_\">delete</span>(el);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">queue</span>.<span class=\"property\">unused</span>.<span class=\"title function_\">push</span>(el);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>调用release方法时缓存了废弃的元素。</p>\n<ol start=\"2\">\n<li>渲染当前滚动屏幕内的元素。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">attachContent</span>(<span class=\"params\">start: <span class=\"built_in\">number</span>, end: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> benchNodes = []; <span class=\"comment\">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">changedNodes</span>: <span class=\"title class_\">IChangedNodes</span> = []; <span class=\"comment\">// 有变化的节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重点是释放在屏幕外的元素</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeUnusedNodes</span>(start, end, <span class=\"variable language_\">this</span>.<span class=\"property\">isForceUpdate</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">isForceUpdate</span> &amp;&amp; runway.<span class=\"property\">nodes</span>[i]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> renderer = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRenderer</span>(i);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> data = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getData</span>(i, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 调用渲染函数，获得一个节点</span></span><br><span class=\"line\">      <span class=\"comment\">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = runway.<span class=\"property\">nodes</span>[i] = renderer.<span class=\"title function_\">render</span>(data, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 向缓存中存入一个节点，用于移除</span></span><br><span class=\"line\">      runway.<span class=\"property\">screenNodes</span>.<span class=\"title function_\">add</span>(node);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class=\"line\">      changedNodes.<span class=\"title function_\">push</span>(&#123;node, <span class=\"attr\">index</span>: i&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node.<span class=\"property\">parentNode</span> !== <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>) &#123;</span><br><span class=\"line\">        benchNodes.<span class=\"title function_\">push</span>(node);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 批量修改节点样式</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setNodesStyles</span>(changedNodes);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 批量加入元素到容器中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (benchNodes.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">container</span>.<span class=\"title function_\">appendChild</span>(benchNodes.<span class=\"title function_\">pop</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 也许可以加载更多</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">maybeLoadMore</span>(end);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p>\n<p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p>\n<p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p>\n<h1 id=\"简短的流程\"><a href=\"#简短的流程\" class=\"headerlink\" title=\"简短的流程\"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p>\n<p>把attachContent单拎出来。</p>\n<p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p>\n<p>再过滤一遍，核心实现就三步：</p>\n<ol>\n<li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li>\n<li>依据start、end释放屏幕外的元素</li>\n<li>依据start、end更新屏幕内的元素</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">getFirstScreenItem</span>(<span class=\"attr\">initialAnchorItem</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">scrollTop</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = initialAnchorItem;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sourceLastIndex = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &lt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(++i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &lt;= scrollTop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与往上滚动相反</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(--i, <span class=\"variable language_\">this</span>) + runway.<span class=\"property\">source</span>.<span class=\"title function_\">getHeight</span>(i, <span class=\"variable language_\">this</span>) &gt; scrollTop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 故加 1</span></span><br><span class=\"line\">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class=\"number\">0</span> &amp;&amp; ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">getLastScreenItem</span>(<span class=\"attr\">initialAnchorItem</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">scrollTop</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = initialAnchorItem;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sourceLastIndex = runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是往上滚</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(i, <span class=\"variable language_\">this</span>) &gt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(--i, <span class=\"variable language_\">this</span>) &gt;= scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与往上滚相反</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.<span class=\"property\">source</span>.<span class=\"title function_\">getScrollTop</span>(++i, <span class=\"variable language_\">this</span>) &lt; scrollTop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class=\"line\">      <span class=\"comment\">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class=\"line\">      <span class=\"comment\">// 故减 1</span></span><br><span class=\"line\">      i &gt; <span class=\"number\">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"title function_\">freeUnusedNodes</span>(<span class=\"params\">start: <span class=\"built_in\">number</span>, end?: <span class=\"built_in\">number</span>, force?: <span class=\"built_in\">boolean</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> runway = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getRunway</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (force || start &gt; runway.<span class=\"property\">lastAttachedItem</span> || end &lt; runway.<span class=\"property\">firstAttachedItem</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromStart</span>(runway.<span class=\"property\">firstAttachedItem</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">min</span>(runway.<span class=\"property\">source</span>.<span class=\"title function_\">getLength</span>(<span class=\"variable language_\">this</span>), runway.<span class=\"property\">lastAttachedItem</span> + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可能处理某种边界情况</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromStart</span>(runway.<span class=\"property\">firstAttachedItem</span>, start);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">freeNodesFromEnd</span>(end, runway.<span class=\"property\">lastAttachedItem</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p>\n<p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p>\n<p>所以就库本身来说，性能还是挺高的。</p>\n<p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>\n","categories":[],"tags":[]}