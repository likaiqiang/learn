{"title":"学习ahooks之useRequest","slug":"学习ahooks之useRequest","date":"2021-12-03T22:07:27.000Z","updated":"2023-06-26T23:31:50.485Z","comments":true,"path":"api/articles/学习ahooks之useRequest.json","excerpt":null,"covers":["https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/65b965bf-b6f8-4928-a641-0b986ccc5274-image.png"],"content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>ahooks算是react hooks生态库重要的一环，其中useRequest算是使用比较多的hooks。（试问哪个前端页面没有http请求）</p>\n<h1 id=\"useRequest的自我介绍\"><a href=\"#useRequest的自我介绍\" class=\"headerlink\" title=\"useRequest的自我介绍\"></a>useRequest的自我介绍</h1><p>useRequest 是一个强大的异步数据管理的 Hooks，React 项目中的网络请求场景使用 useRequest 就够了。</p>\n<p>useRequest 通过插件式组织代码，核心代码极其简单，并且可以很方便的扩展出更高级的功能。目前已有能力包括….</p>\n<p>主要是第二句：useRequest的核心代码很简单，其他什么防抖、节流都是通过插件实现的。</p>\n<h1 id=\"代码分层\"><a href=\"#代码分层\" class=\"headerlink\" title=\"代码分层\"></a>代码分层</h1><p>带着上一节的官方介绍来看useRequest的代码分层<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequest.ts\">入口文件</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useRequest&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(</span><br><span class=\"line\">  <span class=\"attr\">service</span>: <span class=\"title class_\">Service</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  options?: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  plugins?: <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[],</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> useRequestImplement&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;(service, options, [</span><br><span class=\"line\">    ...(plugins || []),</span><br><span class=\"line\">    useDebouncePlugin,</span><br><span class=\"line\">    useLoadingDelayPlugin,</span><br><span class=\"line\">    usePollingPlugin,</span><br><span class=\"line\">    useRefreshOnWindowFocusPlugin,</span><br><span class=\"line\">    useThrottlePlugin,</span><br><span class=\"line\">    useRefreshDeps,</span><br><span class=\"line\">    useCachePlugin,</span><br><span class=\"line\">    useRetryPlugin,</span><br><span class=\"line\">    useReadyPlugin,</span><br><span class=\"line\">  ] <span class=\"keyword\">as</span> <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>useRequest接收service、options、plugin三个参数，随后又调用了useRequestImplement函数，参数为service、options，plugins变成自定义plugins与内置plugins的集合。</p>\n<p>其中service是一个返回promise的函数，也就是封装http request的函数。options则是一个参数大集合，除了 <a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-request/basic#options\">base option</a> 以外，还包括内置插件的options。</p>\n<p>从这里其实印证了官方的说法：useRequest的核心功能简单，其他的功能都是插件实现的（包括内置插件与自定义插件）。扒一扒useRequestImplement的源码，看看大佬所说的简单到底有多简单。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequestImplement.ts#L12\">useRequestImplement</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useRequestImplement&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(</span><br><span class=\"line\">  <span class=\"attr\">service</span>: <span class=\"title class_\">Service</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  <span class=\"attr\">options</span>: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt; = &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[] = [],</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; manual = <span class=\"literal\">false</span>, ...rest &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchOptions = &#123;</span><br><span class=\"line\">    manual,</span><br><span class=\"line\">    ...rest,</span><br><span class=\"line\">  &#125;;  <span class=\"comment\">//这两句挺费解的，其实可以更简 const fetchOptions = &#123;manual:false,...options&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> serviceRef = <span class=\"title function_\">useLatest</span>(service); <span class=\"comment\">//第一个旁支useLatest。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"title function_\">useUpdate</span>(); <span class=\"comment\">// 第二个旁支</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchInstance = <span class=\"title function_\">useCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initState = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> p?.<span class=\"property\">onInit</span>?.(fetchOptions)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第六个旁支</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Fetch</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;(</span><br><span class=\"line\">      serviceRef,</span><br><span class=\"line\">      fetchOptions,</span><br><span class=\"line\">      update,</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, ...initState),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// useCreation第三个旁支</span></span><br><span class=\"line\">  fetchInstance.<span class=\"property\">options</span> = fetchOptions;</span><br><span class=\"line\">  <span class=\"comment\">// run all plugins hook</span></span><br><span class=\"line\">  fetchInstance.<span class=\"property\">pluginImpls</span> = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> <span class=\"title function_\">p</span>(fetchInstance, fetchOptions)); <span class=\"comment\">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useMount</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 第四个旁支</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!manual) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// useCachePlugin can set fetchInstance.state.params from cache when init</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> params = fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">params</span> || options.<span class=\"property\">defaultParams</span> || [];</span><br><span class=\"line\">      <span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\">      fetchInstance.<span class=\"title function_\">run</span>(...params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useUnmount</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 第五个旁支</span></span><br><span class=\"line\">    fetchInstance.<span class=\"title function_\">cancel</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">loading</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">loading</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">data</span>,</span><br><span class=\"line\">    <span class=\"attr\">error</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">error</span>,</span><br><span class=\"line\">    <span class=\"attr\">params</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">params</span> || [],</span><br><span class=\"line\">    <span class=\"attr\">cancel</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">cancel</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">refresh</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">refresh</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">refreshAsync</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">refreshAsync</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">run</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">runAsync</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">runAsync</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">mutate</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">mutate</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">  &#125; <span class=\"keyword\">as</span> <span class=\"title class_\">Result</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 第七个旁支useMemoizedFn</span></span><br></pre></td></tr></table></figure>\n<p>上面一波粗略的阅读虽然遇到了6个旁支，但是根据变量的命名以及官方文档我们可以猜一猜useRequestImplement都干了什么事。</p>\n<p><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-latest\">useLatest</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-update\">useUpdate</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-creation\">useCreation</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-mount\">useMount</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-unmount\">useUnmount</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn\">useMemoizedFn</a></p>\n<p>通过文档可以看出useLatest的作用是返回某个参数的最新值，useCreation的作用是使某个值保持绝对不变（除非依赖发生变化）,useMemoizedFn的作用是使函数的地址永远不变。这三个都属于性能优化hook，对于我们理解useRequest可以暂时忽略。</p>\n<p>而useUpdate，顾名思义，返回一个强制刷新的函数，用于整个组件树重新渲染。</p>\n<p>useMount与useUnmount属于生命周期hook，分别在组件挂载与卸载时触发。</p>\n<p>综上，useRequestImplement做的事其实就是，通过new Fetch生成一个fetchInstance实例，参数除了serviceRef、fetchOptions、update外，还有initState。瞅一眼initState。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> p?.<span class=\"property\">onInit</span>?.(fetchOptions)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt; = &#123;</span><br><span class=\"line\">  (<span class=\"attr\">fetchInstance</span>: <span class=\"title class_\">Fetch</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;, <span class=\"attr\">options</span>: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;): <span class=\"title class_\">PluginReturn</span>&lt;</span><br><span class=\"line\">    <span class=\"title class_\">TData</span>,</span><br><span class=\"line\">    <span class=\"title class_\">TParams</span></span><br><span class=\"line\">  &gt;;</span><br><span class=\"line\">  onInit?: <span class=\"function\">(<span class=\"params\">options: Options&lt;TData, TParams&gt;</span>) =&gt;</span> <span class=\"title class_\">Partial</span>&lt;<span class=\"title class_\">FetchState</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从这两处可以看出每个plugin都可以有个onInit函数，返回值是部分FetchState对象，这个对象的集合就是initState。 瞅一眼Fetch的构造函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> options: Options&lt;TData, TParams&gt;,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> subscribe: Subscribe,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      ...<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>,</span><br><span class=\"line\">      <span class=\"attr\">loading</span>: !options.<span class=\"property\">manual</span>,</span><br><span class=\"line\">      ...initState,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，onInit的作用其实就是在初始化fetchInstance时，通过插件的形式生成initState，initState会在new Fetch时作为state的默认值。</p>\n<p>回到主线，生成fetchInstance实例后，会在fetchInstance上放一些东西。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchInstance.<span class=\"property\">options</span> = fetchOptions;</span><br><span class=\"line\">  <span class=\"comment\">// run all plugins hooks</span></span><br><span class=\"line\">fetchInstance.<span class=\"property\">pluginImpls</span> = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> <span class=\"title function_\">p</span>(fetchInstance, fetchOptions)); <span class=\"comment\">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16\">PluginReturn</a></p>\n<p>pluginImpls其实就是一个含有onBefore、onRequest…等生命周期函数的对象集合。而这些生命周期就是插件系统的灵魂。Fetch内部通过一个叫runPluginHandler的函数调用各个插件（pluginImpls）。</p>\n<p>大概瞅一眼<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L37\">runPluginHandler</a> 的实现</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">runPluginHandler</span>(<span class=\"params\">event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"variable language_\">this</span>.<span class=\"property\">pluginImpls</span>.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> i[event]?.(...rest)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, ...r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看Fetch内部都在什么时机调用runPluginHandler。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L43\">runAsync</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L136\">cancel</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155\">mutate</a></p>\n<p>runAsync方法会在请求的各个阶段调用runPluginHandler（请求前&#x2F;中&#x2F;后…），onBefore&#x2F;onRequest&#x2F;onSuccess…，而这些钩子函数或者直接干预runAsync的执行，或者通过返回<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16\">约定的值</a> 来干预runAsync的执行。</p>\n<p>总的来说，所谓的插件就是一个返回PluginReturn的函数，而PluginReturn中的各个生命周期函数会在Fetch的关键方法执行时调用。</p>\n<p>这就是插件的工作原理，我们也可以写插件来执行上述过程。</p>\n<p>回到主线。在组件挂载时执行fetchInstance.run()（假设manual为false），组件卸载时执行fetchInstance.cancel()，然后返回一大堆fetchInstance的属性&#x2F;方法。</p>\n<h1 id=\"旁支\"><a href=\"#旁支\" class=\"headerlink\" title=\"旁支\"></a>旁支</h1><h2 id=\"Fetch类\"><a href=\"#Fetch类\" class=\"headerlink\" title=\"Fetch类\"></a>Fetch类</h2><p>用面向对象的思维封装了useRequest关于网络请求的几个api，在这里插一句话，我以前不重视面向对象那一套东西，其实在某些场景下，面向对象的可封装性与代码的可读性是优于函数式编程的，配合typescript的类型系统写起来不要太爽。</p>\n<p>Fetch洋洋洒洒150+代码，从run函数开刀。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"title function_\">run</span>(<span class=\"params\">...params: TParams</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">runAsync</span>(...params).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">options</span>.<span class=\"property\">onError</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run函数调用了runAsync函数。那run与runAsync有啥区别呢，文档是这样写的。<br><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/65b965bf-b6f8-4928-a641-0b986ccc5274-image.png\" alt=\"65b965bf-b6f8-4928-a641-0b986ccc5274-image.png\"><br>这句话具有误导作用，runAsync本质上是个async函数.<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L94\">onSuccess</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L103\">resolve</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L115\">onError</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L124\">reject</a><br>代码很清晰，run调用了runAsync,后者在执行过程中不管是options里面的success&#x2F;error，还是promise形式的resolve&#x2F;reject都会执行。</p>\n<p>而整个runAsync的执行过程分为三部分，请求前&#x2F;中&#x2F;后。</p>\n<p>请求前：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">count</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> currentCount = <span class=\"variable language_\">this</span>.<span class=\"property\">count</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  stopNow = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  returnNow = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  ...state</span><br><span class=\"line\">&#125; = <span class=\"variable language_\">this</span>.<span class=\"title function_\">runPluginHandler</span>(<span class=\"string\">&#x27;onBefore&#x27;</span>, params);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stop request</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stopNow) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">loading</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  params,</span><br><span class=\"line\">  ...state,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// return now</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (returnNow) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(state.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">options</span>.<span class=\"property\">onBefore</span>?.(params);</span><br></pre></td></tr></table></figure>\n<p>可以先忽略那个奇怪的count，还是挺简单的，先是调用了所有插件的onBefore钩子。如果stopNow &#x3D;&#x3D;&#x3D; true，返回一个空的promise，否则调用setState设置params和loading，这里的setState和react的setState是雷锋和雷峰塔的关系。<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L29\">setState</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">setState</span>(<span class=\"params\">s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">        ...<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>,</span><br><span class=\"line\">        ...s,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用了一个奇怪的subscribe函数，这个subscribe就是Fetch实例化时传入的update函数（useUpdate），目的是使组件rerender，让react组件拿到最新的Fetch成员变量。</p>\n<p>回到runAsync主线。如果returnNow &#x3D;&#x3D;&#x3D; true，返回空的promise，与前一步骤不同的是，这时的loading是true。然后调用options的onBefore函数，说明插件的onBefore是先于options.onBefore执行的，并且可以干预是否执行options.onBefore。</p>\n<p>请求中与请求后分别对应try&#x2F;catch代码块，暂且忽略count，先调用插件的onRequest钩子，请求可以在插件中发起，假如插件没有返回servicePromise或者没有请求，runAsync会自己执行server，请求完成以后设置state，调用options.onSuccess，插件的onSuccess钩子，options.onFinally。</p>\n<p>请求后与请求中思路类似，就不重复了。回过头来看那个count发现除了runAsync，cancel也访问了count，从这里大概能猜到，runAsync中之所以有那么多currentCount与count的比对，目的就是检测请求有没有被取消（并不会真正的取消那条请求）</p>\n<p>剩下的refresh、refreshAsync与mutate，前两个就不说了，来看<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155\">mutate</a> 的实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">targetData</span>: <span class=\"title class_\">TData</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\">  targetData = <span class=\"title function_\">data</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  targetData = data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">runPluginHandler</span>(<span class=\"string\">&#x27;onMutate&#x27;</span>, targetData);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: targetData,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码很清晰，所做的事就是不调用server直接setState(data)，顺便调用插件的onMutate钩子，从代码来看，data还可以是个函数。</p>\n<h2 id=\"hooks\"><a href=\"#hooks\" class=\"headerlink\" title=\"hooks\"></a>hooks</h2><h3 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts\">useLatest</a><br>简简单单几行代码，道不出这个hooks的真谛，我们来看官方<a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-latest\">例子</a> 。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> latestCountRef = <span class=\"title function_\">useLatest</span>(count);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(latestCountRef.<span class=\"property\">current</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>把useLatest去掉</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以自己用codesanbox运行运行一下这段代码，会发现jsx中count的值永远都是1。为什么会这样呢？这是因为每次setInterval在触发回调时，这个回调函数的地址都是一样的，也就是说每次调用的回调函数都是同一个，一旦函数唯一，该函数在创建时拥有的闭包就唯一，而count在每次rerender时都会重新生成，所以储存在setInterval函数闭包里的count永远都是第一次的count。</p>\n<p>稍微改一点代码，验证一下这个过程。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">  <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">  <span class=\"title function_\">func</span>()</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>每次输出的func.time都是同一个值，count也是同一个值。这就验证了上述函数唯一，闭包唯一的结论。</p>\n<p>那怎么才能让代码正常运行呢？有两种解决方案：</p>\n<ol>\n<li>函数不唯一。</li>\n<li>函数唯一，但是闭包里的count是不可变的。</li>\n</ol>\n<p>第一种方案：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"title function_\">func</span>()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;unbind&#x27;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [count]);</span><br></pre></td></tr></table></figure>\n<p>看起来挺好的，只需要改变一些useEffect的依赖，但是从log可以看出，会不停的输出unbind，所以这种方式是通过不停的unbind&#x2F;bind的方式来实现函数的不唯一，这就不好了。</p>\n<p>第二种方案：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> latesCount = <span class=\"title function_\">useRef</span>(count)</span><br><span class=\"line\">  latesCount.<span class=\"property\">current</span> = count</span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(latesCount.<span class=\"property\">current</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"title function_\">func</span>()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;unbind&#x27;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从log可以看出func唯一，func中的count也唯一，但是jsx中的count会持续的增加。这是因为setCount的第一个参数不再是func闭包中不变的count，而是latesCount.current。</p>\n<h3 id=\"useMemoizedFn\"><a href=\"#useMemoizedFn\" class=\"headerlink\" title=\"useMemoizedFn\"></a>useMemoizedFn</h3><p><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn\">官方例子</a></p>\n<p>为什么存在这个hook，useCallback又有什么缺点。为什么要保证函数的地址永远不变，举个例子来看一看这个问题。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Child</span> = (<span class=\"params\">props</span>)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次点击add count button，Child组件都会rerender，万一Child组件很大，或者嵌套层次很深呢，这无疑带来了巨大的性能问题。</p>\n<p>用React.memo包一下会好一点。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样点击add count button，Child组件就不渲染了。但是React.momo在props变化时还是会rerender，代码改成这样。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">func</span>=<span class=\"string\">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以发现点击add count button，Child组件竟然重新渲染了，由此可见，每次setCount，onClickHandler都会指向一个新的函数地址。怎么规避呢，来看一看useMemoizedFn的实现。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts\">useMemoizedFn</a></p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useMemoizedFn&lt;T <span class=\"keyword\">extends</span> noop&gt;(<span class=\"attr\">fn</span>: T) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> === <span class=\"string\">&#x27;development&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">`useMemoizedFn expected parameter is a function, got <span class=\"subst\">$&#123;<span class=\"keyword\">typeof</span> fn&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fnRef = useRef&lt;T&gt;(fn);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// why not write `fnRef.current = fn`?</span></span><br><span class=\"line\">  <span class=\"comment\">// https://github.com/alibaba/hooks/issues/728</span></span><br><span class=\"line\">  fnRef.<span class=\"property\">current</span> = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> fn, [fn]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> memoizedFn = useRef&lt;T&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!memoizedFn.<span class=\"property\">current</span>) &#123;</span><br><span class=\"line\">    memoizedFn.<span class=\"property\">current</span> = <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// eslint-disable-next-line @typescript-eslint/no-invalid-this</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fnRef.<span class=\"property\">current</span>.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> memoizedFn.<span class=\"property\">current</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>useMemoizedFn本质上是个高阶函数。有两个useRef，一个存储变化的fn，一个存储永远不变的memoizedFn，调用useMemoizedFn时真正调用的是memoizedFn，然后在memoizedFn内部调用最新的fn。高阶函数的思路。</p>\n<p>PS: 这里有个想法，useCallback为啥会有这么多的问题，是不是我们用错了呢？react hooks的设计初衷是使函数式组件拥有状态，那我们要是能保证被useCallback缓存的函数都是纯函数，是不是就不存在闭包问题。假如上面的例子写成这样：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\">count</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onClickHandler(count)</span></span><br><span class=\"line\"><span class=\"language-xml\">      &#125;&#125;&gt;add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">func</span>=<span class=\"string\">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样写是不是也不存在闭包问题。</p>\n<p>2022.08.02更新，上面的写法还是有问题，虽然解决了函数的引用问题，但却大大增加了心智负担，假如某个方法有好几个依赖，并且有好几处调用，每次调用都要传大一堆“看似无用“的参数，这样就不如在定义函数时“标明”依赖方便。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\">a,b,c,d,e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;,[])</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a,b,c,d,e)</span><br><span class=\"line\"><span class=\"comment\">//这样每次调用foo，都必须传a、b、c、d、e。这样倒不如定义foo时只写一遍依赖方便，但这样又会带来函数地址问题，所以还是需要useMemoizedFn，或者关注一下react新的hooks，useEvent</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"useCreation\"><a href=\"#useCreation\" class=\"headerlink\" title=\"useCreation\"></a>useCreation</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts\">useCreation</a><br><a href=\"https://ahooks.js.org/zh-CN/hooks/use-creation\">文档</a></p>\n<p>正如官方文档说的那样，useRef并不能保证参数绝对不变，所以需要useCreation，我们来看是怎么实现的。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> useCreation&lt;T&gt;(<span class=\"attr\">factory</span>: <span class=\"function\">() =&gt;</span> T, <span class=\"attr\">deps</span>: <span class=\"title class_\">DependencyList</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; current &#125; = <span class=\"title function_\">useRef</span>(&#123;</span><br><span class=\"line\">    deps,</span><br><span class=\"line\">    <span class=\"attr\">obj</span>: <span class=\"literal\">undefined</span> <span class=\"keyword\">as</span> <span class=\"literal\">undefined</span> | T,</span><br><span class=\"line\">    <span class=\"attr\">initialized</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current.<span class=\"property\">initialized</span> === <span class=\"literal\">false</span> || !<span class=\"title function_\">depsAreSame</span>(current.<span class=\"property\">deps</span>, deps)) &#123;</span><br><span class=\"line\">    current.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\">    current.<span class=\"property\">obj</span> = <span class=\"title function_\">factory</span>();</span><br><span class=\"line\">    current.<span class=\"property\">initialized</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> current.<span class=\"property\">obj</span> <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个参数不再是实例本身，而是返回实例的工厂函数，第二个参数是依赖，类型和内置hook类型一样。用一个useRef来保存实例相关的一些参数，只有当initialized为false或者deps发生变化时，才重新执行工厂函数，最后返回实例，如果该实例没有依赖，那么该实例就会唯一。</p>\n<h3 id=\"useUpdate\"><a href=\"#useUpdate\" class=\"headerlink\" title=\"useUpdate\"></a>useUpdate</h3><figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">useUpdate</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [, setState] = <span class=\"title function_\">useState</span>(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">useCallback</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">setState</span>(&#123;&#125;), []);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> useUpdate;</span><br></pre></td></tr></table></figure>\n<p>我们都知道，调用useState的setState会使组件树重新渲染，利用这一点可以达到强制刷新的目的。</p>\n<h3 id=\"useMount\"><a href=\"#useMount\" class=\"headerlink\" title=\"useMount\"></a>useMount</h3><h3 id=\"useUnmount\"><a href=\"#useUnmount\" class=\"headerlink\" title=\"useUnmount\"></a>useUnmount</h3><p>useMount与useUnmount。这俩算是最没存在感的hook，内部实现原理都是useEffect。</p>\n<h1 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h1><h2 id=\"内置插件\"><a href=\"#内置插件\" class=\"headerlink\" title=\"内置插件\"></a>内置插件</h2><h3 id=\"useDebouncePlugin\"><a href=\"#useDebouncePlugin\" class=\"headerlink\" title=\"useDebouncePlugin\"></a>useDebouncePlugin</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/plugins/useDebouncePlugin.ts\">useDebouncePlugin</a><br>大致看一下代码，发现核心实现是调了lodash的debounce方法，那为什么不直接用lodash，究其原因，还要从debounce的原理说起。</p>\n<p><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">debounce</a><br>这东西真反直觉，debounce本质上是个高阶函数，你传一个func函数，它给你返回一个debounced函数，至于剩下的那些lastArgs、lastThis…变量，全存在debounced函数的闭包中，所以保持debounced的唯一（闭包唯一）是重中之重。看一个非react的例子。</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8\">vue debounce</a><br>created时在this上放了一个debouncedGetAnswer函数，就是为了保持debounced的闭包唯一。</p>\n<p>所以不论是这里的useDebouncePlugin还是单独的useDebounceFn，所做的事都是让debounced函数在组件多次渲染中保持唯一。</p>\n<h2 id=\"自定义插件\"><a href=\"#自定义插件\" class=\"headerlink\" title=\"自定义插件\"></a>自定义插件</h2><p>PS: 最近业务比较忙，再加上ahooks代码不停在变动。先合到master，等过段时间再看。</p>\n","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>ahooks算是react hooks生态库重要的一环，其中useRequest算是使用比较多的hooks。（试问哪个前端页面没有http请求）</p>\n<h1 id=\"useRequest的自我介绍\"><a href=\"#useRequest的自我介绍\" class=\"headerlink\" title=\"useRequest的自我介绍\"></a>useRequest的自我介绍</h1><p>useRequest 是一个强大的异步数据管理的 Hooks，React 项目中的网络请求场景使用 useRequest 就够了。</p>\n<p>useRequest 通过插件式组织代码，核心代码极其简单，并且可以很方便的扩展出更高级的功能。目前已有能力包括….</p>\n<p>主要是第二句：useRequest的核心代码很简单，其他什么防抖、节流都是通过插件实现的。</p>\n<h1 id=\"代码分层\"><a href=\"#代码分层\" class=\"headerlink\" title=\"代码分层\"></a>代码分层</h1><p>带着上一节的官方介绍来看useRequest的代码分层<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequest.ts\">入口文件</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useRequest&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(</span><br><span class=\"line\">  <span class=\"attr\">service</span>: <span class=\"title class_\">Service</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  options?: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  plugins?: <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[],</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> useRequestImplement&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;(service, options, [</span><br><span class=\"line\">    ...(plugins || []),</span><br><span class=\"line\">    useDebouncePlugin,</span><br><span class=\"line\">    useLoadingDelayPlugin,</span><br><span class=\"line\">    usePollingPlugin,</span><br><span class=\"line\">    useRefreshOnWindowFocusPlugin,</span><br><span class=\"line\">    useThrottlePlugin,</span><br><span class=\"line\">    useRefreshDeps,</span><br><span class=\"line\">    useCachePlugin,</span><br><span class=\"line\">    useRetryPlugin,</span><br><span class=\"line\">    useReadyPlugin,</span><br><span class=\"line\">  ] <span class=\"keyword\">as</span> <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>useRequest接收service、options、plugin三个参数，随后又调用了useRequestImplement函数，参数为service、options，plugins变成自定义plugins与内置plugins的集合。</p>\n<p>其中service是一个返回promise的函数，也就是封装http request的函数。options则是一个参数大集合，除了 <a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-request/basic#options\">base option</a> 以外，还包括内置插件的options。</p>\n<p>从这里其实印证了官方的说法：useRequest的核心功能简单，其他的功能都是插件实现的（包括内置插件与自定义插件）。扒一扒useRequestImplement的源码，看看大佬所说的简单到底有多简单。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/useRequestImplement.ts#L12\">useRequestImplement</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useRequestImplement&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt;(</span><br><span class=\"line\">  <span class=\"attr\">service</span>: <span class=\"title class_\">Service</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;,</span><br><span class=\"line\">  <span class=\"attr\">options</span>: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt; = &#123;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;[] = [],</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; manual = <span class=\"literal\">false</span>, ...rest &#125; = options;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchOptions = &#123;</span><br><span class=\"line\">    manual,</span><br><span class=\"line\">    ...rest,</span><br><span class=\"line\">  &#125;;  <span class=\"comment\">//这两句挺费解的，其实可以更简 const fetchOptions = &#123;manual:false,...options&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> serviceRef = <span class=\"title function_\">useLatest</span>(service); <span class=\"comment\">//第一个旁支useLatest。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> update = <span class=\"title function_\">useUpdate</span>(); <span class=\"comment\">// 第二个旁支</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchInstance = <span class=\"title function_\">useCreation</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> initState = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> p?.<span class=\"property\">onInit</span>?.(fetchOptions)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第六个旁支</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Fetch</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;(</span><br><span class=\"line\">      serviceRef,</span><br><span class=\"line\">      fetchOptions,</span><br><span class=\"line\">      update,</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, ...initState),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// useCreation第三个旁支</span></span><br><span class=\"line\">  fetchInstance.<span class=\"property\">options</span> = fetchOptions;</span><br><span class=\"line\">  <span class=\"comment\">// run all plugins hook</span></span><br><span class=\"line\">  fetchInstance.<span class=\"property\">pluginImpls</span> = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> <span class=\"title function_\">p</span>(fetchInstance, fetchOptions)); <span class=\"comment\">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useMount</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 第四个旁支</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!manual) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// useCachePlugin can set fetchInstance.state.params from cache when init</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> params = fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">params</span> || options.<span class=\"property\">defaultParams</span> || [];</span><br><span class=\"line\">      <span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\">      fetchInstance.<span class=\"title function_\">run</span>(...params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useUnmount</span>(<span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 第五个旁支</span></span><br><span class=\"line\">    fetchInstance.<span class=\"title function_\">cancel</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"attr\">loading</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">loading</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">data</span>,</span><br><span class=\"line\">    <span class=\"attr\">error</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">error</span>,</span><br><span class=\"line\">    <span class=\"attr\">params</span>: fetchInstance.<span class=\"property\">state</span>.<span class=\"property\">params</span> || [],</span><br><span class=\"line\">    <span class=\"attr\">cancel</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">cancel</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">refresh</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">refresh</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">refreshAsync</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">refreshAsync</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">run</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">run</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">runAsync</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">runAsync</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">    <span class=\"attr\">mutate</span>: <span class=\"title function_\">useMemoizedFn</span>(fetchInstance.<span class=\"property\">mutate</span>.<span class=\"title function_\">bind</span>(fetchInstance)),</span><br><span class=\"line\">  &#125; <span class=\"keyword\">as</span> <span class=\"title class_\">Result</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;;</span><br><span class=\"line\">&#125;<span class=\"comment\">// 第七个旁支useMemoizedFn</span></span><br></pre></td></tr></table></figure>\n<p>上面一波粗略的阅读虽然遇到了6个旁支，但是根据变量的命名以及官方文档我们可以猜一猜useRequestImplement都干了什么事。</p>\n<p><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-latest\">useLatest</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-update\">useUpdate</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-creation\">useCreation</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-mount\">useMount</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-unmount\">useUnmount</a><br><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn\">useMemoizedFn</a></p>\n<p>通过文档可以看出useLatest的作用是返回某个参数的最新值，useCreation的作用是使某个值保持绝对不变（除非依赖发生变化）,useMemoizedFn的作用是使函数的地址永远不变。这三个都属于性能优化hook，对于我们理解useRequest可以暂时忽略。</p>\n<p>而useUpdate，顾名思义，返回一个强制刷新的函数，用于整个组件树重新渲染。</p>\n<p>useMount与useUnmount属于生命周期hook，分别在组件挂载与卸载时触发。</p>\n<p>综上，useRequestImplement做的事其实就是，通过new Fetch生成一个fetchInstance实例，参数除了serviceRef、fetchOptions、update外，还有initState。瞅一眼initState。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> p?.<span class=\"property\">onInit</span>?.(fetchOptions)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">type</span> <span class=\"title class_\">Plugin</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span> <span class=\"keyword\">extends</span> <span class=\"built_in\">any</span>[]&gt; = &#123;</span><br><span class=\"line\">  (<span class=\"attr\">fetchInstance</span>: <span class=\"title class_\">Fetch</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;, <span class=\"attr\">options</span>: <span class=\"title class_\">Options</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;): <span class=\"title class_\">PluginReturn</span>&lt;</span><br><span class=\"line\">    <span class=\"title class_\">TData</span>,</span><br><span class=\"line\">    <span class=\"title class_\">TParams</span></span><br><span class=\"line\">  &gt;;</span><br><span class=\"line\">  onInit?: <span class=\"function\">(<span class=\"params\">options: Options&lt;TData, TParams&gt;</span>) =&gt;</span> <span class=\"title class_\">Partial</span>&lt;<span class=\"title class_\">FetchState</span>&lt;<span class=\"title class_\">TData</span>, <span class=\"title class_\">TParams</span>&gt;&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从这两处可以看出每个plugin都可以有个onInit函数，返回值是部分FetchState对象，这个对象的集合就是initState。 瞅一眼Fetch的构造函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> serviceRef: MutableRefObject&lt;Service&lt;TData, TParams&gt;&gt;,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> options: Options&lt;TData, TParams&gt;,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> subscribe: Subscribe,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">public</span> initState: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;,</span></span><br><span class=\"line\"><span class=\"params\">  </span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      ...<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>,</span><br><span class=\"line\">      <span class=\"attr\">loading</span>: !options.<span class=\"property\">manual</span>,</span><br><span class=\"line\">      ...initState,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，onInit的作用其实就是在初始化fetchInstance时，通过插件的形式生成initState，initState会在new Fetch时作为state的默认值。</p>\n<p>回到主线，生成fetchInstance实例后，会在fetchInstance上放一些东西。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchInstance.<span class=\"property\">options</span> = fetchOptions;</span><br><span class=\"line\">  <span class=\"comment\">// run all plugins hooks</span></span><br><span class=\"line\">fetchInstance.<span class=\"property\">pluginImpls</span> = plugins.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">p</span>) =&gt;</span> <span class=\"title function_\">p</span>(fetchInstance, fetchOptions)); <span class=\"comment\">// 从这一句可以推出每个插件都是一个接收fetchInstance与fetchOptions的函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 执行所有的插件，并把结果存到fetchInstance.pluginImpls上</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16\">PluginReturn</a></p>\n<p>pluginImpls其实就是一个含有onBefore、onRequest…等生命周期函数的对象集合。而这些生命周期就是插件系统的灵魂。Fetch内部通过一个叫runPluginHandler的函数调用各个插件（pluginImpls）。</p>\n<p>大概瞅一眼<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L37\">runPluginHandler</a> 的实现</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">runPluginHandler</span>(<span class=\"params\">event: keyof PluginReturn&lt;TData, TParams&gt;, ...rest: <span class=\"built_in\">any</span>[]</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> r = <span class=\"variable language_\">this</span>.<span class=\"property\">pluginImpls</span>.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">i</span>) =&gt;</span> i[event]?.(...rest)).<span class=\"title function_\">filter</span>(<span class=\"title class_\">Boolean</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>(&#123;&#125;, ...r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们看Fetch内部都在什么时机调用runPluginHandler。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L43\">runAsync</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L136\">cancel</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155\">mutate</a></p>\n<p>runAsync方法会在请求的各个阶段调用runPluginHandler（请求前&#x2F;中&#x2F;后…），onBefore&#x2F;onRequest&#x2F;onSuccess…，而这些钩子函数或者直接干预runAsync的执行，或者通过返回<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/types.ts#L16\">约定的值</a> 来干预runAsync的执行。</p>\n<p>总的来说，所谓的插件就是一个返回PluginReturn的函数，而PluginReturn中的各个生命周期函数会在Fetch的关键方法执行时调用。</p>\n<p>这就是插件的工作原理，我们也可以写插件来执行上述过程。</p>\n<p>回到主线。在组件挂载时执行fetchInstance.run()（假设manual为false），组件卸载时执行fetchInstance.cancel()，然后返回一大堆fetchInstance的属性&#x2F;方法。</p>\n<h1 id=\"旁支\"><a href=\"#旁支\" class=\"headerlink\" title=\"旁支\"></a>旁支</h1><h2 id=\"Fetch类\"><a href=\"#Fetch类\" class=\"headerlink\" title=\"Fetch类\"></a>Fetch类</h2><p>用面向对象的思维封装了useRequest关于网络请求的几个api，在这里插一句话，我以前不重视面向对象那一套东西，其实在某些场景下，面向对象的可封装性与代码的可读性是优于函数式编程的，配合typescript的类型系统写起来不要太爽。</p>\n<p>Fetch洋洋洒洒150+代码，从run函数开刀。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"title function_\">run</span>(<span class=\"params\">...params: TParams</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">runAsync</span>(...params).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"variable language_\">this</span>.<span class=\"property\">options</span>.<span class=\"property\">onError</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run函数调用了runAsync函数。那run与runAsync有啥区别呢，文档是这样写的。<br><img src=\"https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/65b965bf-b6f8-4928-a641-0b986ccc5274-image.png\" alt=\"65b965bf-b6f8-4928-a641-0b986ccc5274-image.png\"><br>这句话具有误导作用，runAsync本质上是个async函数.<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L94\">onSuccess</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L103\">resolve</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L115\">onError</a><br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L124\">reject</a><br>代码很清晰，run调用了runAsync,后者在执行过程中不管是options里面的success&#x2F;error，还是promise形式的resolve&#x2F;reject都会执行。</p>\n<p>而整个runAsync的执行过程分为三部分，请求前&#x2F;中&#x2F;后。</p>\n<p>请求前：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">count</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> currentCount = <span class=\"variable language_\">this</span>.<span class=\"property\">count</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  stopNow = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  returnNow = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  ...state</span><br><span class=\"line\">&#125; = <span class=\"variable language_\">this</span>.<span class=\"title function_\">runPluginHandler</span>(<span class=\"string\">&#x27;onBefore&#x27;</span>, params);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// stop request</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stopNow) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">loading</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  params,</span><br><span class=\"line\">  ...state,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// return now</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (returnNow) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(state.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">options</span>.<span class=\"property\">onBefore</span>?.(params);</span><br></pre></td></tr></table></figure>\n<p>可以先忽略那个奇怪的count，还是挺简单的，先是调用了所有插件的onBefore钩子。如果stopNow &#x3D;&#x3D;&#x3D; true，返回一个空的promise，否则调用setState设置params和loading，这里的setState和react的setState是雷锋和雷峰塔的关系。<br><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L29\">setState</a></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">setState</span>(<span class=\"params\">s: Partial&lt;FetchState&lt;TData, TParams&gt;&gt; = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">        ...<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>,</span><br><span class=\"line\">        ...s,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">subscribe</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用了一个奇怪的subscribe函数，这个subscribe就是Fetch实例化时传入的update函数（useUpdate），目的是使组件rerender，让react组件拿到最新的Fetch成员变量。</p>\n<p>回到runAsync主线。如果returnNow &#x3D;&#x3D;&#x3D; true，返回空的promise，与前一步骤不同的是，这时的loading是true。然后调用options的onBefore函数，说明插件的onBefore是先于options.onBefore执行的，并且可以干预是否执行options.onBefore。</p>\n<p>请求中与请求后分别对应try&#x2F;catch代码块，暂且忽略count，先调用插件的onRequest钩子，请求可以在插件中发起，假如插件没有返回servicePromise或者没有请求，runAsync会自己执行server，请求完成以后设置state，调用options.onSuccess，插件的onSuccess钩子，options.onFinally。</p>\n<p>请求后与请求中思路类似，就不重复了。回过头来看那个count发现除了runAsync，cancel也访问了count，从这里大概能猜到，runAsync中之所以有那么多currentCount与count的比对，目的就是检测请求有没有被取消（并不会真正的取消那条请求）</p>\n<p>剩下的refresh、refreshAsync与mutate，前两个就不说了，来看<a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/Fetch.ts#L155\">mutate</a> 的实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">targetData</span>: <span class=\"title class_\">TData</span> | <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// @ts-ignore</span></span><br><span class=\"line\">  targetData = <span class=\"title function_\">data</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  targetData = data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">runPluginHandler</span>(<span class=\"string\">&#x27;onMutate&#x27;</span>, targetData);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: targetData,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码很清晰，所做的事就是不调用server直接setState(data)，顺便调用插件的onMutate钩子，从代码来看，data还可以是个函数。</p>\n<h2 id=\"hooks\"><a href=\"#hooks\" class=\"headerlink\" title=\"hooks\"></a>hooks</h2><h3 id=\"useLatest\"><a href=\"#useLatest\" class=\"headerlink\" title=\"useLatest\"></a>useLatest</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useLatest/index.ts\">useLatest</a><br>简简单单几行代码，道不出这个hooks的真谛，我们来看官方<a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-latest\">例子</a> 。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> latestCountRef = <span class=\"title function_\">useLatest</span>(count);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(latestCountRef.<span class=\"property\">current</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>把useLatest去掉</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以自己用codesanbox运行运行一下这段代码，会发现jsx中count的值永远都是1。为什么会这样呢？这是因为每次setInterval在触发回调时，这个回调函数的地址都是一样的，也就是说每次调用的回调函数都是同一个，一旦函数唯一，该函数在创建时拥有的闭包就唯一，而count在每次rerender时都会重新生成，所以储存在setInterval函数闭包里的count永远都是第一次的count。</p>\n<p>稍微改一点代码，验证一下这个过程。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">  <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">  <span class=\"title function_\">func</span>()</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n<p>每次输出的func.time都是同一个值，count也是同一个值。这就验证了上述函数唯一，闭包唯一的结论。</p>\n<p>那怎么才能让代码正常运行呢？有两种解决方案：</p>\n<ol>\n<li>函数不唯一。</li>\n<li>函数唯一，但是闭包里的count是不可变的。</li>\n</ol>\n<p>第一种方案：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(count+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"title function_\">func</span>()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;unbind&#x27;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [count]);</span><br></pre></td></tr></table></figure>\n<p>看起来挺好的，只需要改变一些useEffect的依赖，但是从log可以看出，会不停的输出unbind，所以这种方式是通过不停的unbind&#x2F;bind的方式来实现函数的不唯一，这就不好了。</p>\n<p>第二种方案：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> latesCount = <span class=\"title function_\">useRef</span>(count)</span><br><span class=\"line\">  latesCount.<span class=\"property\">current</span> = count</span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">func</span> = (<span class=\"params\"></span>)=&gt;&#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;count&#x27;</span>,count)</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(latesCount.<span class=\"property\">current</span>+<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func.<span class=\"property\">time</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> interval = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(func.<span class=\"property\">time</span>)</span><br><span class=\"line\">      <span class=\"title function_\">func</span>()</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;unbind&#x27;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(interval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count: &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从log可以看出func唯一，func中的count也唯一，但是jsx中的count会持续的增加。这是因为setCount的第一个参数不再是func闭包中不变的count，而是latesCount.current。</p>\n<h3 id=\"useMemoizedFn\"><a href=\"#useMemoizedFn\" class=\"headerlink\" title=\"useMemoizedFn\"></a>useMemoizedFn</h3><p><a href=\"https://ahooks-next.surge.sh/zh-CN/hooks/use-memoized-fn\">官方例子</a></p>\n<p>为什么存在这个hook，useCallback又有什么缺点。为什么要保证函数的地址永远不变，举个例子来看一看这个问题。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useLatest &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;ahooks&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Child</span> = (<span class=\"params\">props</span>)=&gt;&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次点击add count button，Child组件都会rerender，万一Child组件很大，或者嵌套层次很深呢，这无疑带来了巨大的性能问题。</p>\n<p>用React.memo包一下会好一点。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样点击add count button，Child组件就不渲染了。但是React.momo在props变化时还是会rerender，代码改成这样。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// const latestCountRef = useLatest(count);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[count])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClickHandler&#125;</span>&gt;</span>add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">func</span>=<span class=\"string\">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>可以发现点击add count button，Child组件竟然重新渲染了，由此可见，每次setCount，onClickHandler都会指向一个新的函数地址。怎么规避呢，来看一看useMemoizedFn的实现。</p>\n<p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useMemoizedFn/index.ts\">useMemoizedFn</a></p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> useMemoizedFn&lt;T <span class=\"keyword\">extends</span> noop&gt;(<span class=\"attr\">fn</span>: T) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (process.<span class=\"property\">env</span>.<span class=\"property\">NODE_ENV</span> === <span class=\"string\">&#x27;development&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">`useMemoizedFn expected parameter is a function, got <span class=\"subst\">$&#123;<span class=\"keyword\">typeof</span> fn&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fnRef = useRef&lt;T&gt;(fn);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// why not write `fnRef.current = fn`?</span></span><br><span class=\"line\">  <span class=\"comment\">// https://github.com/alibaba/hooks/issues/728</span></span><br><span class=\"line\">  fnRef.<span class=\"property\">current</span> = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> fn, [fn]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> memoizedFn = useRef&lt;T&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!memoizedFn.<span class=\"property\">current</span>) &#123;</span><br><span class=\"line\">    memoizedFn.<span class=\"property\">current</span> = <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// eslint-disable-next-line @typescript-eslint/no-invalid-this</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> fnRef.<span class=\"property\">current</span>.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> memoizedFn.<span class=\"property\">current</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>useMemoizedFn本质上是个高阶函数。有两个useRef，一个存储变化的fn，一个存储永远不变的memoizedFn，调用useMemoizedFn时真正调用的是memoizedFn，然后在memoizedFn内部调用最新的fn。高阶函数的思路。</p>\n<p>PS: 这里有个想法，useCallback为啥会有这么多的问题，是不是我们用错了呢？react hooks的设计初衷是使函数式组件拥有状态，那我们要是能保证被useCallback缓存的函数都是纯函数，是不是就不存在闭包问题。假如上面的例子写成这样：</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickHandler = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\">count</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;,[])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">          onClickHandler(count)</span></span><br><span class=\"line\"><span class=\"language-xml\">      &#125;&#125;&gt;add count<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">func</span>=<span class=\"string\">&#123;onClickHandler&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Child</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>&#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child render&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>我是child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样写是不是也不存在闭包问题。</p>\n<p>2022.08.02更新，上面的写法还是有问题，虽然解决了函数的引用问题，但却大大增加了心智负担，假如某个方法有好几个依赖，并且有好几处调用，每次调用都要传大一堆“看似无用“的参数，这样就不如在定义函数时“标明”依赖方便。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\">a,b,c,d,e</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;,[])</span><br><span class=\"line\"><span class=\"title function_\">foo</span>(a,b,c,d,e)</span><br><span class=\"line\"><span class=\"comment\">//这样每次调用foo，都必须传a、b、c、d、e。这样倒不如定义foo时只写一遍依赖方便，但这样又会带来函数地址问题，所以还是需要useMemoizedFn，或者关注一下react新的hooks，useEvent</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"useCreation\"><a href=\"#useCreation\" class=\"headerlink\" title=\"useCreation\"></a>useCreation</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useCreation/index.ts\">useCreation</a><br><a href=\"https://ahooks.js.org/zh-CN/hooks/use-creation\">文档</a></p>\n<p>正如官方文档说的那样，useRef并不能保证参数绝对不变，所以需要useCreation，我们来看是怎么实现的。</p>\n<figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> useCreation&lt;T&gt;(<span class=\"attr\">factory</span>: <span class=\"function\">() =&gt;</span> T, <span class=\"attr\">deps</span>: <span class=\"title class_\">DependencyList</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; current &#125; = <span class=\"title function_\">useRef</span>(&#123;</span><br><span class=\"line\">    deps,</span><br><span class=\"line\">    <span class=\"attr\">obj</span>: <span class=\"literal\">undefined</span> <span class=\"keyword\">as</span> <span class=\"literal\">undefined</span> | T,</span><br><span class=\"line\">    <span class=\"attr\">initialized</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current.<span class=\"property\">initialized</span> === <span class=\"literal\">false</span> || !<span class=\"title function_\">depsAreSame</span>(current.<span class=\"property\">deps</span>, deps)) &#123;</span><br><span class=\"line\">    current.<span class=\"property\">deps</span> = deps;</span><br><span class=\"line\">    current.<span class=\"property\">obj</span> = <span class=\"title function_\">factory</span>();</span><br><span class=\"line\">    current.<span class=\"property\">initialized</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> current.<span class=\"property\">obj</span> <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个参数不再是实例本身，而是返回实例的工厂函数，第二个参数是依赖，类型和内置hook类型一样。用一个useRef来保存实例相关的一些参数，只有当initialized为false或者deps发生变化时，才重新执行工厂函数，最后返回实例，如果该实例没有依赖，那么该实例就会唯一。</p>\n<h3 id=\"useUpdate\"><a href=\"#useUpdate\" class=\"headerlink\" title=\"useUpdate\"></a>useUpdate</h3><figure class=\"highlight typescript\"><figcaption><span>jsx</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">useUpdate</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [, setState] = <span class=\"title function_\">useState</span>(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">useCallback</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">setState</span>(&#123;&#125;), []);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> useUpdate;</span><br></pre></td></tr></table></figure>\n<p>我们都知道，调用useState的setState会使组件树重新渲染，利用这一点可以达到强制刷新的目的。</p>\n<h3 id=\"useMount\"><a href=\"#useMount\" class=\"headerlink\" title=\"useMount\"></a>useMount</h3><h3 id=\"useUnmount\"><a href=\"#useUnmount\" class=\"headerlink\" title=\"useUnmount\"></a>useUnmount</h3><p>useMount与useUnmount。这俩算是最没存在感的hook，内部实现原理都是useEffect。</p>\n<h1 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h1><h2 id=\"内置插件\"><a href=\"#内置插件\" class=\"headerlink\" title=\"内置插件\"></a>内置插件</h2><h3 id=\"useDebouncePlugin\"><a href=\"#useDebouncePlugin\" class=\"headerlink\" title=\"useDebouncePlugin\"></a>useDebouncePlugin</h3><p><a href=\"https://github.com/alibaba/hooks/blob/master/packages/hooks/src/useRequest/src/plugins/useDebouncePlugin.ts\">useDebouncePlugin</a><br>大致看一下代码，发现核心实现是调了lodash的debounce方法，那为什么不直接用lodash，究其原因，还要从debounce的原理说起。</p>\n<p><a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">debounce</a><br>这东西真反直觉，debounce本质上是个高阶函数，你传一个func函数，它给你返回一个debounced函数，至于剩下的那些lastArgs、lastThis…变量，全存在debounced函数的闭包中，所以保持debounced的唯一（闭包唯一）是重中之重。看一个非react的例子。</p>\n<p><a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E4%BE%A6%E5%90%AC%E5%99%A8\">vue debounce</a><br>created时在this上放了一个debouncedGetAnswer函数，就是为了保持debounced的闭包唯一。</p>\n<p>所以不论是这里的useDebouncePlugin还是单独的useDebounceFn，所做的事都是让debounced函数在组件多次渲染中保持唯一。</p>\n<h2 id=\"自定义插件\"><a href=\"#自定义插件\" class=\"headerlink\" title=\"自定义插件\"></a>自定义插件</h2><p>PS: 最近业务比较忙，再加上ahooks代码不停在变动。先合到master，等过段时间再看。</p>\n","categories":[],"tags":[]}