<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学习recycler-view | Hexo</title><meta name="author" content="likaiqiang"><meta name="copyright" content="likaiqiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。 https:&#x2F;&#x2F;github.com&#x2F;hdcoo&#x2F;recycler-view 大概原理先去这里 ,下载demo源代码，clone下来后npm install,然后访问h">
<meta property="og:type" content="article">
<meta property="og:title" content="学习recycler-view">
<meta property="og:url" content="https://likaiqianglearn.cn/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。 https:&#x2F;&#x2F;github.com&#x2F;hdcoo&#x2F;recycler-view 大概原理先去这里 ,下载demo源代码，clone下来后npm install,然后访问h">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg">
<meta property="article:published_time" content="2021-11-20T23:36:13.000Z">
<meta property="article:modified_time" content="2022-02-02T02:17:09.083Z">
<meta property="article:author" content="likaiqiang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://likaiqianglearn.cn/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#ffffff"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"/><link rel="mask-icon" href="/img/siteicon/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习recycler-view',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-02 02:17:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/QQ图片20210723090732.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学习recycler-view</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-20T23:36:13.000Z" title="Created 2021-11-20 23:36:13">2021-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-02-02T02:17:09.083Z" title="Updated 2022-02-02 02:17:09">2022-02-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学习recycler-view"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大数据的列表滚动一直是很头疼的问题，尤其无限滚动这种场景，不像人家安卓，有RecyclerView这种内置组件可以用。前端只能可怜巴巴的自己实现，幸好前人栽树，后人乘凉，业界有同行已经写了一些实现，本文将要介绍的便是其中一种。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hdcoo/recycler-view">https://github.com/hdcoo/recycler-view</a></p>
<h1 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h1><p>先去<a target="_blank" rel="noopener" href="https://github.com/hdcoo/recycler-view-demo">这里</a> ,下载demo源代码，clone下来后npm install,然后访问<a target="_blank" rel="noopener" href="http://localhost:5211/recycler-view-demo/%EF%BC%8C">http://localhost:5211/recycler-view-demo/，</a> 我们要介绍的是经典两列布局的瀑布流，也就是入口是waterfall.js的那个例子。</p>
<p>demo项目运行起来以后，打开控制台发现每个例子的布局都很奇怪。正常情况下我们写一个局部滚动，代码应该是这样的。</p>
<iframe src="https://codesandbox.io/embed/boring-lehmann-kwve4?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<p>可是这个库的布局是这样的</p>
<iframe src="https://codesandbox.io/embed/practical-blackburn-qmf1w?fontsize=14&hidenavigation=1&theme=dark" title="awesome-mestorf-nb8r2" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>

<p>内层元素是以绝对定位+translate的方式“贴”上去的，比起普通的流式布局，这样做的好处是一旦周围的元素有变化（位置变化或者干脆从dom树中删除），主体元素的位置不会变化。我们可以利用这一特性，在页面初始化中只渲染能覆盖一屏的元素个数（假如是15个），在滚动容器的过程中，势必有一些元素滚出屏幕（A），又有新的元素将要出现在屏幕内（B），我们重复利用滚出屏幕的废弃元素（A），改变他们的translate，使其出现在B应该出现的位置，然后改变B的数据。这样即使有成千上万条数据，渲染在容器内的dom也仅仅只有15个（可能大于15，只有B的个数大于A的个数时，才会createElement）。这就是核心所在。</p>
<p>回到官方的两列瀑布流例子</p>
<p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB.gif?versionId=CAEQGxiBgICh8q_s5xciIGI0MWQyYTQ3MDdiZDRlZGI4YTViYWY1YjNlZDM2NTYy"></p>
<p>从图中可以看出变化的仅仅是translate，外层recycler-scroller的最大滚动高度很大，随着页面的滚动，可见的元素仅仅是那几个被反复利用的元素，其实recycler-scroller下部有大片看不到的空白，实际高度是由一个宽高都为1的绝对定位元素（sentine）撑开的，这个元素的top便是scroller的最大滚动高度。</p>
<p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d8fd84a1-1504-4020-93f7-a550314c1459-image.png" alt="d8fd84a1-1504-4020-93f7-a550314c1459-image.png"></p>
<p>为啥有个container，以我的理解，从这个库的原理来看，container的作用仅仅是区分可见元素的dom与sentine，方便管理（比如说往container里面append元素）。</p>
<h1 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h1><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p>从dom结构来看，整个库分为三部分：Scroller &#x3D; Containe + Sentine。</p>
<p>从代码层次来看，整个库分为Recyler、Render与Source。Recyler是核心实现，Render负责dom的创建&#x2F;更新以及不可见元素的回收利用。Source顾名思义数据之源，由于这个库的原理所限，每项数据必须提供height与scrollTop。</p>
<h2 id="单行代码分析"><a href="#单行代码分析" class="headerlink" title="单行代码分析"></a>单行代码分析</h2><p>首先入口文件是waterfail.js</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getWaterfallRecycler</span>(<span class="params">scroller, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Recycler(scroller, <span class="keyword">new</span> WaterfallSource(), &#123;</span><br><span class="line">    container,</span><br><span class="line">    <span class="attr">renderer</span>: <span class="keyword">new</span> NumberRenderer()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要一个提供数据与每项数据的位置参数的Source实例，需要一个提供每项元素具体render实现以及回收&#x2F;释放屏幕外元素的Render实例，需要一个产生滚动的的滚动容器（scroller），以及用于管理屏幕内（准确说应该是当下渲染出的元素）的元素。</p>
<p>接下来看Recycler的具体实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">EventEmitter</span> <span class="title">implements</span> <span class="title">IRecycler</span>&lt;<span class="title">T</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>EventEmitter是一个简短的消息发射器，用于向外界通知Recycler的各种情况，比如说是否正在滚动以及是否滚到了底部。</p>
<p>我基于作者的注释给与补充</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recycler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">EventEmitter</span> <span class="title">implements</span> <span class="title">IRecycler</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">scroller: Window | HTMLElement, sources: ISource&lt;T&gt; | <span class="built_in">Array</span>&lt;ISource&lt;T&gt;&gt;, options: IOptions&lt;T&gt;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化统一 scroller 操作接口</span></span><br><span class="line">        <span class="built_in">this</span>.scrollerOperations = <span class="keyword">new</span> ScrollerOperations(scroller);</span><br><span class="line">        <span class="comment">// 滚动元素可以是普通的dom，也可以是window，这个类抹平了两者的差异。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.scrollerOperations.isScrollerValid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> Exceptions.TypeError(<span class="string">&#x27;Invalid scroller, must be window or inside document.body&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动容器</span></span><br><span class="line">        <span class="built_in">this</span>.scroller = scroller;</span><br><span class="line">        <span class="built_in">this</span>.scrollerHeight = <span class="built_in">this</span>.scrollerOperations.getOffsetHeight();</span><br><span class="line">        <span class="comment">// scrollerHeight即scroller的offsetHeight，具体到这个例子上，即recycler-scroller的offsetheight calc(100% - 60px)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认渲染器</span></span><br><span class="line">        <span class="built_in">this</span>.renderer = options.renderer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 容纳元素的容器</span></span><br><span class="line">        <span class="built_in">this</span>.container = options.container || <span class="built_in">this</span>.scrollerOperations.getElement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶部和底部预留空间</span></span><br><span class="line">        <span class="built_in">this</span>.topPreserved = <span class="built_in">Math</span>.max(options.topPreserved || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.bottomPreserved = <span class="built_in">Math</span>.max(options.bottomPreserved || <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这两项是为了适应scroller顶部或底部有额外元素的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 滚动正反方向预渲染元素个数</span></span><br><span class="line">        <span class="built_in">this</span>.runwayItems = options.runwayItems || <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">this</span>.runwayItemsOpposite = options.runwayItemsOpposite || <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在滚动过程中，我们看到的container里面元素的覆盖面不止一屏的高度，应该加上runwayItems与runwayItemsOpposite个元素的高度，之所以设计这两个参数，我猜是为了竟可能的减少白屏时间。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 距离底部多少个元素时触发加载更多</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = options.threshold || <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 这个底部指的是具有实际滚动高度的scroller的底部，而不是看到的container</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许多个实例，可以在实例之间切换（为了能在同一个 scroller 中切换不同的内容，比如搜索结果和原列表之间切换）</span></span><br><span class="line">        <span class="built_in">this</span>.initRunways(sources);</span><br><span class="line">        <span class="built_in">this</span>.activatedRunway = Recycler.getDefaultRunwayKey(sources);</span><br><span class="line">        <span class="comment">// 作者设计这个runway可能真由他所说，用于在同一个scroller中切换不同的内容，但是初次阅读源码这个概念反而成为一种干扰，所以可以先认为runway就是一个保存了滚动过程中各种重要参数的对象。</span></span><br><span class="line">        <span class="comment">// 稍后会介绍runway</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 Dom 事件监听器</span></span><br><span class="line">        <span class="built_in">this</span>.scrollListener = <span class="keyword">new</span> ScrollListener(<span class="built_in">this</span>.scroller);</span><br><span class="line">        <span class="built_in">this</span>.resizeListener = <span class="keyword">new</span> ResizeListener();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撑开滚动容器</span></span><br><span class="line">        <span class="built_in">this</span>.sentinel = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sentinel.style.position = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.sentinel.style.width = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.sentinel.style.height = <span class="string">&#x27;1px&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.scrollerOperations.appendChild(<span class="built_in">this</span>.sentinel);</span><br><span class="line">        <span class="comment">// scroller = container + Sentine，container里面的元素全部绝对定位，container本身是没有高度的，但是scroller却能滚动，原因就是内部有一个top很大的绝对定位元素撑开的，而这个元素的top就是由每一项数据的height计算得知的。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据是否启用硬件加速选择模板</span></span><br><span class="line">        <span class="keyword">if</span> (options.enableAcceleration) &#123;</span><br><span class="line">            <span class="built_in">this</span>.transformTemplate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px, 0)`</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.transformTemplate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="string">`translate(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>px)`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 container position style</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.getComputedStyle(<span class="built_in">this</span>.container).position === <span class="string">&#x27;static&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.container.style.position = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哨兵位置</span></span><br><span class="line">        <span class="built_in">this</span>.setSentinelPosition();</span><br><span class="line">        <span class="comment">//给Sentine元素设置top值，以便撑开scroller</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听事件，根据 scroller 需要不同的监听方式</span></span><br><span class="line">        <span class="built_in">this</span>.scrollListener.on(<span class="built_in">this</span>.onScroll.bind(<span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">// 监听scroller的滚动事件，以便实时的渲染屏幕内的元素、回收屏幕外的元素，所以this.onScroll做的事很关键。</span></span><br><span class="line">        <span class="keyword">if</span> (options.handleWindowResize) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resizeListener.on(<span class="built_in">this</span>.onResize.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 runways，并调用对应的 source.mount() 方法，可以在此监听一些事件（比如配置 lazyload）</span></span><br><span class="line">        mapObject(<span class="built_in">this</span>.runways, <span class="function">(<span class="params">runway</span>) =&gt;</span> &#123;</span><br><span class="line">            execute(<span class="function">() =&gt;</span> runway.source.mount(<span class="built_in">this</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 可以跳过这一句</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染视图（如果 sources 不为空的话）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getRunway().source.getLength(<span class="built_in">this</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.update();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数据不为空的话，渲染出第一屏数据，this.update内部会调用this.onScroll</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 onInitialized</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.emit(Recycler.Events.Initialized, <span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">//通知外界框架已经初始化完毕，并渲染出第一屏数据。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来说明constructor中几个重要的步骤。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.initRunways(sources);</span><br><span class="line"><span class="built_in">this</span>.activatedRunway = Recycler.getDefaultRunwayKey(sources);</span><br></pre></td></tr></table></figure>
<p>initRunways调用了addRunway,addRunway调用了getInitialRunway。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> getInitialRunway&lt;U&gt;(source: ISource&lt;U&gt;): IRunway&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstAttachedItem</span>: <span class="number">0</span>, </span><br><span class="line">      <span class="attr">lastAttachedItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">firstScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">lastScreenItem</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">requestInProgress</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">runwayMaxScrollTop</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">nodes</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">screenNodes</span>: newSet(),</span><br><span class="line">      source,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码很明显，runway就是一个保存了在滚动过程中几个比较重要参数的对象。</p>
<p>scrollTop：scroller的scrollTop</p>
<p>requestInProgress：是否正在请求数据，</p>
<p>nodes：渲染出来的元素集合（不仅仅是屏幕内的元素）</p>
<p>screenNodes：nodes的缓存</p>
<p>runwayMaxScrollTop：scroller的最大滚动高度，即Sentine的top值，可以由source的height计算得出。</p>
<p>至于firstAttachedItem&#x2F;lastAttachedItem&#x2F;firstScreenItem&#x2F;lastScreenItem这两对的意思？？为什么是两对，这个后面会解释，这里认为只有一对好了，即firstScreenItem&#x2F;lastScreenItem，意思是把source中的哪几项渲染到container内。</p>
<p>这样，initRunways的意思是初始化了这样一个对象，至于activatedRunway暂且跳过。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.update()</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">update</span>(<span class="params">disableRender?: <span class="built_in">boolean</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.scrollerHeight = <span class="built_in">this</span>.scrollerOperations.getOffsetHeight();</span><br><span class="line">    <span class="built_in">this</span>.getRunway().runwayMaxScrollTop = <span class="built_in">this</span>.getRunwayMaxScrollTop();</span><br><span class="line">    <span class="built_in">this</span>.setSentinelPosition();</span><br><span class="line">    <span class="built_in">this</span>.emit(Recycler.Events.Update, <span class="built_in">this</span>, disableRender);</span><br><span class="line">    !disableRender &amp;&amp; <span class="built_in">this</span>.onScroll();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>upadte内部首先算出scroller的滚动高度，调用setSentinelPosition，然后手动调用onScroll方法渲染出第一屏元素。所以关键是onScroll的实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L285">onScroll</a></p>
<p>去繁从简,onScroll干的事首先算出在当前滚动中应该被渲染元素的索引（先不考虑具体的实现），然后根据滚动的方向调用fill方法渲染html</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hdcoo/recycler-view/blob/master/src/Recycler.ts#L332">fill</a></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fixedStart = <span class="built_in">Math</span>.max(<span class="number">0</span>, start);</span><br><span class="line"><span class="keyword">const</span> fixedEnd = <span class="built_in">Math</span>.min(runway.source.getLength(<span class="built_in">this</span>) - <span class="number">1</span>, end);</span><br></pre></td></tr></table></figure>
<p>这两句很疑惑，为什么要重新计算start和end呢</p>
<p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/d23cee97-7080-4a8f-89b0-24e87b67e522-image.png" alt="d23cee97-7080-4a8f-89b0-24e87b67e522-image.png"></p>
<p><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/%E5%8A%A8%E7%94%BB2.gif?versionId=CAEQGxiBgIC7n4v85xciIDNhYjIwMTQ3YTZlOTQ5MmFiMGMzZTU3ZWE5OWZlNmZh"></p>
<p>从图中可以看出由于runwayItemsOpposite与runwayItems的存在，算出来的start可能小于0，end可能大于source的最大长度，所以需要重新计算，这就是为什么initRunway方法里面有两对关于start、end的值的原因。</p>
<p>算出正确的start、end后调用了attachContent。</p>
<p>attachContent分两步：</p>
<ol>
<li>根据start、end释放屏幕外的元素。这里有两步，首先更新runway.nodes与runway.screenNodes，screenNodes是nodes的缓存，这俩货只负责渲染container内部的元素，实现dom的重复利用的是renderer.release方法。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> release(el: HTMLElement, <span class="attr">recycler</span>: IRecycler&lt;T&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue.using.delete(el);</span><br><span class="line">    <span class="built_in">this</span>.queue.unused.push(el);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>调用release方法时缓存了废弃的元素。</p>
<ol start="2">
<li>渲染当前滚动屏幕内的元素。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="title">attachContent</span>(<span class="params">start: <span class="built_in">number</span>, end: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="built_in">this</span>.getRunway();</span><br><span class="line">    <span class="keyword">const</span> benchNodes = []; <span class="comment">// 板凳元素，即等待被放到 DOM tree 里的节点</span></span><br><span class="line">    <span class="keyword">const</span> changedNodes: IChangedNodes = []; <span class="comment">// 有变化的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点是释放在屏幕外的元素</span></span><br><span class="line">    <span class="built_in">this</span>.freeUnusedNodes(start, end, <span class="built_in">this</span>.isForceUpdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从渲染起始点到渲染终止点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果 node 存在于缓存中，说明元素本来就在屏幕上，不需要做什么（除非指定强制更新）</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.isForceUpdate &amp;&amp; runway.nodes[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> renderer = <span class="built_in">this</span>.getRenderer(i);</span><br><span class="line">      <span class="keyword">const</span> data = runway.source.getData(i, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用渲染函数，获得一个节点</span></span><br><span class="line">      <span class="comment">// 这个节点可能在屏幕上，也可能不在，取决于渲染器的设计（是否有缓存）和当前滚动的深度</span></span><br><span class="line">      <span class="comment">// 如果该节点在屏幕上，性能会最佳，因为只需要改变一下 translate 就行了，不需要 layout</span></span><br><span class="line">      <span class="keyword">const</span> node = runway.nodes[i] = renderer.render(data, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向缓存中存入一个节点，用于移除</span></span><br><span class="line">      runway.screenNodes.add(node);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向变化的节点数组中加入一项，等待改变样式（translate, height, etc...）</span></span><br><span class="line">      changedNodes.push(&#123;node, <span class="attr">index</span>: i&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点的父元素不是指定的容器，则加入板凳元素数组中</span></span><br><span class="line">      <span class="keyword">if</span> (node.parentNode !== <span class="built_in">this</span>.container) &#123;</span><br><span class="line">        benchNodes.push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量修改节点样式</span></span><br><span class="line">    <span class="built_in">this</span>.setNodesStyles(changedNodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量加入元素到容器中</span></span><br><span class="line">    <span class="keyword">while</span> (benchNodes.length) &#123;</span><br><span class="line">      <span class="built_in">this</span>.container.appendChild(benchNodes.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也许可以加载更多</span></span><br><span class="line">    <span class="built_in">this</span>.maybeLoadMore(end);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这几行代码算是比较核心的实现。如果runway.nodes[i]存在，则不渲染，即使不存在，会调用renderer.render方法，这个方法会优先从render的缓存中pop一个元素出来，改变它的translate和data从而实现dom的重复利用。</p>
<p>并且为了更高的性能，定义了changedNodes与benchNodes，前者包含当次滚动中需要渲染的所有元素（缓存中的元素+新创建的元素），后者仅仅是新创建的元素，这样仅仅只需要改变前者的transtrate，把后者append到container中就可以了。</p>
<p>这样，整个流程便走完了，后面在scroller滚动过程中会反复调用this.onScroll，思路和上面的一样。</p>
<h1 id="简短的流程"><a href="#简短的流程" class="headerlink" title="简短的流程"></a>简短的流程</h1><p>去繁从简，从构造函数开始，整个流程如下：<br>constructor -&gt; this.update() -&gt; this.onScroll() -&gt; (this.getFirstScreenItem;this.getLastScreenItem,计算出理论上container内渲染元素的start、end索引) -&gt; (this.fill(),计算出实际的start、end索引) -&gt; (this.attachContent(),准备根据start、end更新container内的元素)</p>
<p>把attachContent单拎出来。</p>
<p>this.attachContent() -&gt; (this.freeUnusedNodes(),释放屏幕外的元素，其实是放入render的unused中) -&gt; (渲染屏幕内的元素)</p>
<p>再过滤一遍，核心实现就三步：</p>
<ol>
<li>依据上次的start、end计算本次的start、end (getFirstScreenItem、getLastScreenItem)</li>
<li>依据start、end释放屏幕外的元素</li>
<li>依据start、end更新屏幕内的元素</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> getFirstScreenItem(initialAnchorItem: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="built_in">this</span>.getRunway();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.source.getLength(<span class="built_in">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本次scrollTop大于上次firstScreenItem对应的scrollTop，所以是往下滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.source.getScrollTop(i, <span class="built_in">this</span>) + runway.source.getHeight(i, <span class="built_in">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">//从上一次firstScreenItem的下一个元素开始往后遍历，一直找到scrollTop大于当前scrollTop的元素索引</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.source.getScrollTop(++i, <span class="built_in">this</span>) + runway.source.getHeight(i, <span class="built_in">this</span>) &lt;= scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚动相反</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.source.getScrollTop(--i, <span class="built_in">this</span>) + runway.source.getHeight(i, <span class="built_in">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面的循环得到的 i 的意义是在屏幕之上的最后一个元素</span></span><br><span class="line">        <span class="comment">// 我们需要的是 在屏幕内的第一个元素</span></span><br><span class="line">        <span class="comment">// 故加 1</span></span><br><span class="line">        i &lt; sourceLastIndex &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> getLastScreenItem(initialAnchorItem: <span class="built_in">number</span>, <span class="attr">scrollTop</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的scrollTop是scroller的scrollTop + scroller的offsetHeight</span></span><br><span class="line">    <span class="keyword">let</span> i = initialAnchorItem;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="built_in">this</span>.getRunway();</span><br><span class="line">    <span class="keyword">const</span> sourceLastIndex = runway.source.getLength(<span class="built_in">this</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果是往上滚</span></span><br><span class="line">    <span class="keyword">if</span> (runway.source.getScrollTop(i, <span class="built_in">this</span>) &gt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// 从上一次的lastScreenItem的上一个元素往前遍历，一直找到scrollTop小于当前scrollTop的元素索引</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; runway.source.getScrollTop(--i, <span class="built_in">this</span>) &gt;= scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 逻辑与往上滚相反</span></span><br><span class="line">      <span class="keyword">while</span> (i &lt; sourceLastIndex &amp;&amp; runway.source.getScrollTop(++i, <span class="built_in">this</span>) &lt; scrollTop) &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面的循环得到的 i 的意义是首个 scrollTop &gt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 我们需要的是 最后一个 scrollTop &lt;= 给定 scrollTop 的 item</span></span><br><span class="line">      <span class="comment">// 故减 1</span></span><br><span class="line">      i &gt; <span class="number">0</span> &amp;&amp; i &lt; sourceLastIndex &amp;&amp; --i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="title">freeUnusedNodes</span>(<span class="params">start: <span class="built_in">number</span>, end?: <span class="built_in">number</span>, force?: <span class="built_in">boolean</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> runway = <span class="built_in">this</span>.getRunway();</span><br><span class="line">    <span class="keyword">if</span> (force || start &gt; runway.lastAttachedItem || end &lt; runway.firstAttachedItem) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.freeNodesFromStart(runway.firstAttachedItem, <span class="built_in">Math</span>.min(runway.source.getLength(<span class="built_in">this</span>), runway.lastAttachedItem + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能处理某种边界情况</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.freeNodesFromStart(runway.firstAttachedItem, start);</span><br><span class="line">    <span class="built_in">this</span>.freeNodesFromEnd(end, runway.lastAttachedItem);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较简单，依次释放屏幕上次边界以外的元素，释放方法就是使用for循环依次放入render的unused中。</p>
<p>最后就是更新屏幕内的元素，更新方法是优先复用render的unused中的元素，仅仅改变他们的translate，不会引起重排，如果item很复杂的话，render.update方法也会消耗性能，但这是外部控制的。如果render.unused中没有元素，则需要createDom（与render.update类似） -&gt; appendDom，除了首次渲染，不会出现高频appendDom的情况。</p>
<p>所以就库本身来说，性能还是挺高的。</p>
<p>最后，由于这个库的特殊布局，它能实现很多种UI效果，普通的多列、甚至复杂的多列瀑布流。不足的地方就是每个item都需要知道height与scrollTop。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">likaiqiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://likaiqianglearn.cn/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/">https://likaiqianglearn.cn/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/"><img class="prev-cover" src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">学习react-whether</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/QQ图片20210723090732.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">likaiqiang</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%A6%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">大概原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">具体的代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">整体设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">单行代码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E7%9F%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">简短的流程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/" title="学习java内部类"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习java内部类"/></a><div class="content"><a class="title" href="/2022/01/09/%E5%AD%A6%E4%B9%A0java%E5%86%85%E9%83%A8%E7%B1%BB/" title="学习java内部类">学习java内部类</a><time datetime="2022-01-09T22:04:25.000Z" title="Created 2022-01-09 22:04:25">2022-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/" title="学习vue-clamp"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习vue-clamp"/></a><div class="content"><a class="title" href="/2021/12/21/%E5%AD%A6%E4%B9%A0vue-clamp/" title="学习vue-clamp">学习vue-clamp</a><time datetime="2021-12-21T22:34:11.000Z" title="Created 2021-12-21 22:34:11">2021-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/" title="学习react-whether"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习react-whether"/></a><div class="content"><a class="title" href="/2021/11/21/%E5%AD%A6%E4%B9%A0react-whether/" title="学习react-whether">学习react-whether</a><time datetime="2021-11-21T21:52:20.000Z" title="Created 2021-11-21 21:52:20">2021-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/" title="学习recycler-view"><img src="https://likaiqiang-blog.oss-cn-beijing.aliyuncs.com/images/微信图片_20211121110405.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学习recycler-view"/></a><div class="content"><a class="title" href="/2021/11/20/%E5%AD%A6%E4%B9%A0recycler-view/" title="学习recycler-view">学习recycler-view</a><time datetime="2021-11-20T23:36:13.000Z" title="Created 2021-11-20 23:36:13">2021-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By likaiqiang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 博客更新啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍭查看新品🍬</span></a></div></div><script>if ('serviceWorker' in navigator) {
    if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.addEventListener('controllerchange', function() {
            showNotification()
        })
    }
    window.addEventListener('load', function() {
        navigator.serviceWorker.register('/sw.js')
    })
}
function showNotification() {
    if (GLOBAL_CONFIG.Snackbar) {
        var snackbarBg =
            document.documentElement.getAttribute('data-theme') === 'light' ?
                GLOBAL_CONFIG.Snackbar.bgLight :
                GLOBAL_CONFIG.Snackbar.bgDark
        var snackbarPos = GLOBAL_CONFIG.Snackbar.position
        Snackbar.show({
            text: '✨ 博客更新啦！ 👉',
            backgroundColor: snackbarBg,
            duration: 500000,
            pos: snackbarPos,
            actionText: '🍭查看新品🍬',
            actionTextColor: '#fff',
            onActionClick: function(e) {
                location.reload()
            },
        })
    } else {
        var showBg =
            document.documentElement.getAttribute('data-theme') === 'light' ?
                '#49b1f5' :
                '#1f1f1f'
        var cssText = `top: 0; background: ${showBg};`
        document.getElementById('app-refresh').style.cssText = cssText
    }
}</script></div></body></html>